/* ---- file: execute_and_or.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_and_or.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:12:56 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_and(t_ast *node, t_shell *shell)
{
	int ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret == 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

int execute_or(t_ast *node, t_shell *shell)
{
	int ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret != 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

/* ---- file: execute_ast.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_ast.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:12:24 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "ast.h"
#include "parser.h"
#include "exec.h"

// replace complete file content of function execute_ast with this version
int     execute_ast(t_ast *node, t_shell *shell)
{
        int     ret;

        if (!node)
                return (0);

        // *** NO tocar señales aquí: el padre las ajusta antes de llamar. ***

        if (node->type == N_COMMAND)
                ret = execute_command(node, shell);
        else if (node->type == N_PIPE)
                ret = execute_pipe(node, shell);
        else if (node->type == N_AND)
                ret = execute_and(node, shell);
        else if (node->type == N_OR)
                ret = execute_or(node, shell);
        else if (node->type == N_SUBSHELL)
                ret = execute_subshell(node, shell);
        else if (node->type == N_SEQUENCE)
                ret = execute_sequence(node, shell);
        else if (node->type == N_BACKGROUND)
                ret = execute_background(node, shell);
        else if (node->type == N_REDIR)
        {
                ft_dprintf(2, "minishell: syntax error near unexpected token `newline'\n");
                shell->exit_status = 2;
                ret = 2;
        }
        else
        {
                ft_dprintf(2, "minishell: command not found\n");
                shell->exit_status = 127;
                ret = 127;
        }

        // *** NO restaurar señales de prompt aquí. ***

        return (ret);
}

/* ---- file: execute_background.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_background.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:16:53 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_background(t_ast *node, t_shell *shell)
{
        pid_t   pid = fork();
        if (pid < 0)
        {
                ft_dprintf(2, "minishell: fork error\n");
                return (shell->exit_status = 1);
        }
        if (pid == 0)
        {
                signal(SIGINT, SIG_DFL);
                signal(SIGQUIT, SIG_DFL);
                shell->in_child = 1;

                int code = execute_ast(node->bin.left, shell);
                _exit(code);
        }
        // Padre no espera en background; status de shell no cambia (bash deja $? tal cual)
        // Si no quieres imprimir [1] PID, comenta la línea siguiente:
        // ft_dprintf(1, "[1] %d\n", pid);
        return shell->exit_status;
}

/* ---- file: execute_command.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:21:42 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"
#include "exec.h"
#include "ast.h"
#include "builtins.h"

/*
// --- helper local ---
static int is_all_n(const char *s)
{
	(void)s;
	
	return (0);
}
*/

static void set_child_signals_default(void)
{
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
}

void restore_std_fds(int original_stdin, int original_stdout, int original_stderr)
{
    if (original_stdin != -1)  { dup2(original_stdin, STDIN_FILENO);  close(original_stdin);  }
    if (original_stdout != -1) { dup2(original_stdout, STDOUT_FILENO); close(original_stdout); }
    if (original_stderr != -1) { dup2(original_stderr, STDERR_FILENO); close(original_stderr); }
}

int execute_command(t_ast *node, t_shell *shell)
{
    pid_t   pid;
    char    **env;
    char    *exec_path;
    int     original_stdin = -1, original_stdout = -1, original_stderr = -1;

    if (!node || !node->cmd.argv || !node->cmd.argv[0])
        return (shell->exit_status = 0);

    if (node->cmd.argv[0][0] == '\0')
    {
        ft_dprintf(2, "minishell: : command not found\n");
        return (shell->exit_status = 127);
    }

    // *** CASO: ejecutamos dentro de un HIJO ya forkeado (pipes, subshell, background)
    if (shell->in_child)
    {
        // El hijo debe tener señales por defecto
        set_child_signals_default();

        // Redirecciones se aplican AQUÍ (en el propio hijo)
        if (apply_redirections(node->cmd.redirections) != 0)
            _exit(1);

        // Builtin en hijo: ejecutar y salir
        if (is_builtin(node->cmd.argv[0]))
        {
            int st = run_builtin(node, shell);
            _exit(st);
        }

        // Externo en hijo: resolver y execve
        exec_path = find_executable(node->cmd.argv[0], shell);
        if (!exec_path)
            _exit(print_exec_error(shell, node->cmd.argv[0], ENOENT));

        env = env_to_array(shell->env);
        if (!env)
        {
            free(exec_path);
            _exit(1);
        }

        execve(exec_path, node->cmd.argv, env);
        // Si llegamos aquí, execve falló
        int err = errno;
        free(exec_path);
        // env no se libera estrictamente necesario (salimos ya)
        _exit(print_exec_error(shell, node->cmd.argv[0], err));
    }

    // *** CASO: proceso PADRE (no forkeado todavía) ***
    // Builtins en el padre: aplicar redirecciones temporalmente
    if (is_builtin(node->cmd.argv[0]))
    {
        original_stdin  = dup(STDIN_FILENO);
        original_stdout = dup(STDOUT_FILENO);
        original_stderr = dup(STDERR_FILENO);
        if (original_stdin == -1 || original_stdout == -1 || original_stderr == -1)
        {
            perror("minishell: dup");
            if (original_stdin  != -1) close(original_stdin);
            if (original_stdout != -1) close(original_stdout);
            if (original_stderr != -1) close(original_stderr);
            return (shell->exit_status = 1);
        }
        if (apply_redirections(node->cmd.redirections) != 0)
        {
            restore_std_fds(original_stdin, original_stdout, original_stderr);
            return (shell->exit_status = 1);
        }
        shell->exit_status = run_builtin(node, shell);
        restore_std_fds(original_stdin, original_stdout, original_stderr);
        return shell->exit_status;
    }

    // Externo: fork y exec en el HIJO
    exec_path = find_executable(node->cmd.argv[0], shell);
    if (!exec_path)
        return print_exec_error(shell, node->cmd.argv[0], ENOENT);

    env = env_to_array(shell->env);
    if (!env)
    {
        free(exec_path);
        return (shell->exit_status = 1);
    }

    pid = fork();
    if (pid < 0)
    {
        free(exec_path);
        ft_free_strtab(env);
        return print_exec_error(shell, node->cmd.argv[0], errno);
    }
    if (pid == 0) // hijo real
    {
        set_child_signals_default();

        // Redirecciones SOLO en el hijo para externos
        if (apply_redirections(node->cmd.redirections) != 0)
            _exit(1);

        execve(exec_path, node->cmd.argv, env);
        // fallo
        int err = errno;
        _exit(print_exec_error(shell, node->cmd.argv[0], err));
    }

    // padre espera al HIJO y traduce status
    int st = 0;
    waitpid(pid, &st, 0);
    if (WIFEXITED(st))
        shell->exit_status = WEXITSTATUS(st);
    else if (WIFSIGNALED(st))
        shell->exit_status = 128 + WTERMSIG(st);
    else
        shell->exit_status = 1;

    free(exec_path);
    ft_free_strtab(env);
    return shell->exit_status;
}

/* ---- file: execute_heredocs.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_heredocs.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 11:45:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

/*
** Heredoc: Lee líneas hasta 'delimiter', escribe en un pipe y devuelve fd lectura.
** ¡No libera recursos ajenos ni imprime nada si el pipe falla!
*/
int	heredoc_prepare(const char *delimiter)
{
	int		pipefd[2];
	char	*line;
	size_t	del_len;

	del_len = ft_strlen(delimiter);
	if (pipe(pipefd) == -1)
		return (-1);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_DFL);
	while (1)
	{
		line = readline("> ");
		if (!line)
			break;
		if (ft_strncmp(line, delimiter, del_len) == 0 && line[del_len] == '\0')
		{
			free(line);
			break;
		}
		write(pipefd[1], line, ft_strlen(line));
		write(pipefd[1], "\n", 1);
		free(line);
	}
	close(pipefd[1]);
	signal(SIGQUIT, SIG_DFL);
	signal(SIGINT, SIG_DFL);
	return (pipefd[0]);
}

/* ---- file: execute_pipe.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:16:23 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int     execute_pipe(t_ast *node, t_shell *shell)
{
        int     pipefd[2];
        pid_t   pid_left;
        pid_t   pid_right;
        int     status_left = 0;
        int     status_right = 0;

        if (pipe(pipefd) == -1)
        {
                ft_dprintf(2, "minishell: pipe error\n");
                shell->exit_status = 1;
                return (1);
        }

        pid_left = fork();
        if (pid_left == 0)
        {
                // hijo izquierdo: escribe en pipe
                signal(SIGINT, SIG_DFL);
                signal(SIGQUIT, SIG_DFL);
                shell->in_child = 1;

                close(pipefd[0]);
                if (dup2(pipefd[1], STDOUT_FILENO) < 0) _exit(1);
                close(pipefd[1]);

                int code = execute_ast(node->bin.left, shell);
                _exit(code);
        }

        pid_right = fork();
        if (pid_right == 0)
        {
                // hijo derecho: lee del pipe
                signal(SIGINT, SIG_DFL);
                signal(SIGQUIT, SIG_DFL);
                shell->in_child = 1;

                close(pipefd[1]);
                if (dup2(pipefd[0], STDIN_FILENO) < 0) _exit(1);
                close(pipefd[0]);

                int code = execute_ast(node->bin.right, shell);
                _exit(code);
        }

        close(pipefd[0]);
        close(pipefd[1]);

        // Esperar a ambos, pero el status del PIPE es el del DERECHO (como bash)
        waitpid(pid_left, &status_left, 0);
        waitpid(pid_right, &status_right, 0);

        if (WIFEXITED(status_right))
                shell->exit_status = WEXITSTATUS(status_right);
        else if (WIFSIGNALED(status_right))
                shell->exit_status = 128 + WTERMSIG(status_right);
        else
                shell->exit_status = 1;

        return shell->exit_status;
}

/* ---- file: execute_redirections.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:12:04 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:18:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "ast.h"

static int	redirect_to(int fd, int std_fd)
{
	int	ret;

	ret = 0;
	if (dup2(fd, std_fd) < 0)
	{
		perror("minishell: dup2");
		close(fd);
		ret = 1;
	}
	close(fd);
	return (ret);
}

static int	handle_heredoc(t_ast *redir)
{
    int	fd;

	fd = heredoc_prepare(redir->redir.delimiter);  // <--- antes: heredoc_read
	if (fd < 0)
		return (1);
	return (redirect_to(fd, STDIN_FILENO));
}


int	open_redirection(t_ast *redir)
{
	int	fd;

	fd = -1;
	if (!redir || redir->type != N_REDIR)
		return (-1);
	if (redir->redir.redir_type == REDIR_IN)
		fd = open(redir->redir.filename, O_RDONLY);
	else if (redir->redir.redir_type == REDIR_OUT)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_FORCE)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redir.redir_type == REDIR_ERR)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND_ERR)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redir.redir_type == REDIR_ALL)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND_ALL)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	return (fd);
}

static int	handle_dup_redir(t_ast *redir)
{
	int	target;
	int	std_fd;

	target = redir->redir.redir_fd;
	if (redir->redir.redir_type == REDIR_DUP_OUT)
		std_fd = 1;
	else
		std_fd = 0;
	if (target == std_fd)
		return (0);
	if (dup2(target, std_fd) < 0)
	{
		perror("minishell: dup2");
		return (1);
	}
	return (0);
}

int	handle_simple_redir(t_ast *redir)
{
	int	fd;
	int	ret;

	fd = open_redirection(redir);
	ret = 0;
	if (fd < 0)
	{
		// Imprime error si open falla
		perror(redir->redir.filename);
		ret = 1;
	}
	else if (redir->redir.redir_type == REDIR_IN)
		ret = redirect_to(fd, STDIN_FILENO);
	else if (redir->redir.redir_type == REDIR_OUT
		|| redir->redir.redir_type == REDIR_FORCE
		|| redir->redir.redir_type == REDIR_APPEND)
		ret = redirect_to(fd, STDOUT_FILENO);
	else if (redir->redir.redir_type == REDIR_ERR
		|| redir->redir.redir_type == REDIR_APPEND_ERR)
		ret = redirect_to(fd, STDERR_FILENO);
	else if (redir->redir.redir_type == REDIR_ALL
		|| redir->redir.redir_type == REDIR_APPEND_ALL)
	{
		if (dup2(fd, STDOUT_FILENO) < 0)
			ret = 1;
		else if (dup2(fd, STDERR_FILENO) < 0)
			ret = 1;
		close(fd);
	}
	return (ret);
}

int	apply_redirections(t_ast *redir_list)
{
	t_ast	*curr;
	int		fail;

	fail = 0;
	curr = redir_list;
	while (curr)
	{
		if (curr->type != N_REDIR)
			return (1);
		if (curr->redir.redir_type == REDIR_HEREDOC)
		{
			if (handle_heredoc(curr))
				fail = 1;
		}
		else if (curr->redir.redir_type == REDIR_DUP_IN
			|| curr->redir.redir_type == REDIR_DUP_OUT)
		{
			if (handle_dup_redir(curr))
				fail = 1;
		}
		else
		{
			if (handle_simple_redir(curr))
				fail = 1;
		}
		curr = curr->bin.right;
	}
	if (fail)
		return (1);
	return (0);
}
/* ---- file: execute_sequence.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_sequence.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_sequence(t_ast *node, t_shell *shell)
{
	execute_ast(node->bin.left, shell);
	return (execute_ast(node->bin.right, shell));
}

/* ---- file: execute_subshell.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_subshell.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:16:37 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_subshell(t_ast *node, t_shell *shell)
{
        pid_t   pid;
        int     status = 0;

        pid = fork();
        if (pid < 0)
        {
                ft_dprintf(2, "minishell: fork error\n");
                return (shell->exit_status = 1);
        }
        if (pid == 0)
        {
                signal(SIGINT, SIG_DFL);
                signal(SIGQUIT, SIG_DFL);
                shell->in_child = 1;

                int code = execute_ast(node->subshell.child, shell);
                _exit(code);
        }
        if (waitpid(pid, &status, 0) == -1)
                return (shell->exit_status = 1);

        if (WIFEXITED(status))
                shell->exit_status = WEXITSTATUS(status);
        else if (WIFSIGNALED(status))
                shell->exit_status = 128 + WTERMSIG(status);
        else
                shell->exit_status = 1;
        return shell->exit_status;
}

/* ---- file: execute_utils.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:27:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"
#include "exec.h"
#include "ast.h"
#include <errno.h>
#include <sys/stat.h>

int	is_executable(char *path)
{
	struct stat	st;

	if (stat(path, &st) != 0)
		return (0);
	if (S_ISDIR(st.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	return (access(path, X_OK) == 0);
}

char	*join_path(const char *dir, const char *file)
{
	char	*tmp;
	size_t	len_dir;
	size_t	len_file;
	size_t	i;

	len_dir = ft_strlen(dir);
	len_file = ft_strlen(file);
	tmp = malloc(len_dir + 1 + len_file + 1);
	if (!tmp)
		return (NULL);
	ft_memcpy(tmp, dir, len_dir);
	tmp[len_dir] = '/';
	i = 0;
	while (i < len_file)
	{
		tmp[len_dir + 1 + i] = file[i];
		i++;
	}
	tmp[len_dir + 1 + len_file] = '\0';
	return (tmp);
}

static int	has_slash(char *cmd)
{
	int	i;

	if (!cmd)
		return (0);
	i = 0;
	while (cmd[i])
	{
		if (cmd[i] == '/')
			return (1);
		i++;
	}
	return (0);
}

static char	*find_path_executable(char *cmd, char **paths)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path(paths[i], cmd);
		if (!full_path)
			return (NULL);
		if (is_executable(full_path))
			return (full_path); // No liberar, lo devolvemos
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*find_executable(char *cmd, t_shell *shell)
{
	char	**paths;
	char	*res;
	char	*path_value;

	if (!cmd)
		return (NULL);
	if (has_slash(cmd))
	{
		if (is_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_value = get_env_value(shell, "PATH");
	if (!path_value || path_value[0] == '\0')
		return (NULL);
	paths = ft_split(path_value, ':');
	if (!paths)
		return (NULL);
	res = find_path_executable(cmd, paths);
	ft_free_strtab(paths);
	return (res);
}

