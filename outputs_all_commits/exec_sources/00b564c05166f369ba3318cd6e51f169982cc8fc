/* ---- file: execute_and_or.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_and_or.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:12:56 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_and(t_ast *node, t_shell *shell)
{
	int ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret == 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

int execute_or(t_ast *node, t_shell *shell)
{
	int ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret != 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

/* ---- file: execute_ast.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_ast.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 10:47:46 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "ast.h"
#include "parser.h"
#include "exec.h"

int	execute_ast(t_ast *node, t_shell *shell)
{
	if (!node)
		return (0);
	if (node->type == N_COMMAND)
		return (execute_command(node, shell));
	else if (node->type == N_PIPE)
		return (execute_pipe(node, shell));
	else if (node->type == N_AND)
		return (execute_and(node, shell));
	else if (node->type == N_OR)
		return (execute_or(node, shell));
	else if (node->type == N_SUBSHELL)
		return (execute_subshell(node, shell));
	else if (node->type == N_SEQUENCE)
		return (execute_sequence(node, shell));
	else if (node->type == N_BACKGROUND)
		return (execute_background(node, shell));
	else if (node->type == N_REDIR)
	{
		ft_dprintf(2, "minishell: syntax error near unexpected token `newline'");
		shell->exit_status = 2;
		return (1);
	}
	// ðŸ”§ Caso por defecto: tipo de nodo desconocido
	ft_dprintf(2, "minishell: command not found\n");
	shell->exit_status = 127;
	return (127);
}

/* ---- file: execute_background.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_background.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 18:54:37 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_background(t_ast *node, t_shell *shell)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		ft_dprintf(2, "minishell: fork error\n");
		shell->exit_status = 1;
		return (1);
	}
	if (pid == 0)
	{
		execute_ast(node->bin.left, shell);
		exit(shell->exit_status);
	}
	// padre no espera al hijo en background
	shell->exit_status = 0;
	ft_dprintf(1,"[1] %d\n", pid);
	return (0);
}

/* ---- file: execute_command.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 19:09:27 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"
#include "exec.h"
#include "ast.h"
#include "builtins.h"

int	execute_command(t_ast *node, t_shell *shell)
{
	pid_t	pid;
	char	**env;
	char	*exec_path;
	int		ret;

	if (!node || !node->cmd.argv || !node->cmd.argv[0])
		return (0);

	if (node->cmd.argv[0][0] == '\0')
	{
		ft_dprintf(2, "minishell: : command not found\n");
		shell->exit_status = 127;
		return (127);
	}
	if (g_signal)
	{
		shell->exit_status = 130;
		g_signal = 0;
		return (130);
	}
	if (is_builtin(node->cmd.argv[0]))
	{
		shell->exit_status = run_builtin(node, shell);
		return (shell->exit_status);
	}
	exec_path = find_executable(node->cmd.argv[0], shell);
	if (!exec_path)
		return (print_exec_error(shell, node->cmd.argv[0], errno));
	env = env_to_array(shell->env);
	if (!env)
	{
		free(exec_path);
		return (1);
	}
	pid = fork();
	if (pid < 0)
	{
		free(exec_path);
		ft_free_strtab(env);
		return (print_exec_error(shell, node->cmd.argv[0], errno));
	}
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		ret = apply_redirections(node->cmd.redirections);
		if (ret != 0)
			exit(1);
		execve(exec_path, node->cmd.argv, env);
		print_exec_error(shell, node->cmd.argv[0], errno);
		exit(127);
	}
	waitpid(pid, &shell->exit_status, 0);
	if (WIFEXITED(shell->exit_status))
		shell->exit_status = WEXITSTATUS(shell->exit_status);
	else if (WIFSIGNALED(shell->exit_status))
		shell->exit_status = 128 + WTERMSIG(shell->exit_status);
	free(exec_path);
	ft_free_strtab(env);
	return (shell->exit_status);
}

/* ---- file: execute_heredocs.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_heredocs.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 11:45:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

/*
** Heredoc: Lee lÃ­neas hasta 'delimiter', escribe en un pipe y devuelve fd lectura.
** Â¡No libera recursos ajenos ni imprime nada si el pipe falla!
*/
int	heredoc_prepare(const char *delimiter)
{
	int		pipefd[2];
	char	*line;
	size_t	del_len;

	del_len = ft_strlen(delimiter);
	if (pipe(pipefd) == -1)
		return (-1);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_DFL);
	while (1)
	{
		line = readline("> ");
		if (!line)
			break;
		if (ft_strncmp(line, delimiter, del_len) == 0 && line[del_len] == '\0')
		{
			free(line);
			break;
		}
		write(pipefd[1], line, ft_strlen(line));
		write(pipefd[1], "\n", 1);
		free(line);
	}
	close(pipefd[1]);
	signal(SIGQUIT, SIG_DFL);
	signal(SIGINT, SIG_DFL);
	return (pipefd[0]);
}

/* ---- file: execute_pipe.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:25:31 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int	execute_pipe(t_ast *node, t_shell *shell)
{
	int		pipefd[2];
	pid_t	pid_left;
	pid_t	pid_right;
	int		status_left;
	int		status_right;

	if (pipe(pipefd) == -1)
	{
		ft_dprintf(2, "minishell: pipe error\n");
		shell->exit_status = 1;
		return (1);
	}
	pid_left = fork();
	if (pid_left == 0)
	{
		// Proceso hijo izquierdo: escribe en pipe
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[1]);
		exit(execute_ast(node->bin.left, shell));
	}
	pid_right = fork();
	if (pid_right == 0)
	{
		// Proceso hijo derecho: lee del pipe
		close(pipefd[1]);
		dup2(pipefd[0], STDIN_FILENO);
		close(pipefd[0]);
		exit(execute_ast(node->bin.right, shell));
	}
	close(pipefd[0]);
	close(pipefd[1]);
	waitpid(pid_left, &status_left, 0);
	waitpid(pid_right, &status_right, 0);
	if (WIFEXITED(status_right))
		shell->exit_status = WEXITSTATUS(status_right);
	else
		shell->exit_status = 1;
	return (shell->exit_status);
}

/* ---- file: execute_redirections.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:12:04 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 18:23:36 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "ast.h"

static int	redirect_to(int fd, int std_fd)
{
	int	ret;

	ret = 0;
	if (dup2(fd, std_fd) < 0)
	{
		perror("minishell: dup2");
		close(fd);
		ret = 1;
	}
	close(fd);
	return (ret);
}

static int	handle_heredoc(t_ast *redir)
{
	int	fd;

	fd = heredoc_read(redir->redir.delimiter);
	if (fd < 0)
		return (1);
	return (redirect_to(fd, STDIN_FILENO));
}

int	open_redirection(t_ast *redir)
{
	int	fd;

	fd = -1;
	if (!redir || redir->type != N_REDIR)
		return (-1);
	if (redir->redir.redir_type == REDIR_IN)
		fd = open(redir->redir.filename, O_RDONLY);
	else if (redir->redir.redir_type == REDIR_OUT)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_FORCE)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redir.redir_type == REDIR_ERR)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND_ERR)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redir.redir_type == REDIR_ALL)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND_ALL)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	return (fd);
}

static int	handle_dup_redir(t_ast *redir)
{
	int	target;
	int	std_fd;

	target = redir->redir.redir_fd;
	if (redir->redir.redir_type == REDIR_DUP_OUT)
		std_fd = 1;
	else
		std_fd = 0;
	if (target == std_fd)
		return (0);
	if (dup2(target, std_fd) < 0)
	{
		perror("minishell: dup2");
		return (1);
	}
	return (0);
}

int	handle_simple_redir(t_ast *redir)
{
	int	fd;
	int	ret;

	fd = open_redirection(redir);
	ret = 0;
	if (fd < 0)
	{
		// Imprime error si open falla
		perror(redir->redir.filename);
		ret = 1;
	}
	else if (redir->redir.redir_type == REDIR_IN)
		ret = redirect_to(fd, STDIN_FILENO);
	else if (redir->redir.redir_type == REDIR_OUT
		|| redir->redir.redir_type == REDIR_FORCE
		|| redir->redir.redir_type == REDIR_APPEND)
		ret = redirect_to(fd, STDOUT_FILENO);
	else if (redir->redir.redir_type == REDIR_ERR
		|| redir->redir.redir_type == REDIR_APPEND_ERR)
		ret = redirect_to(fd, STDERR_FILENO);
	else if (redir->redir.redir_type == REDIR_ALL
		|| redir->redir.redir_type == REDIR_APPEND_ALL)
	{
		if (dup2(fd, STDOUT_FILENO) < 0)
			ret = 1;
		else if (dup2(fd, STDERR_FILENO) < 0)
			ret = 1;
		close(fd);
	}
	return (ret);
}

int	apply_redirections(t_ast *redir_list)
{
	t_ast	*curr;
	int		fail;

	fail = 0;
	curr = redir_list;
	while (curr)
	{
		if (curr->type != N_REDIR)
			return (1);
		if (curr->redir.redir_type == REDIR_HEREDOC)
		{
			if (handle_heredoc(curr))
				fail = 1;
		}
		else if (curr->redir.redir_type == REDIR_DUP_IN
			|| curr->redir.redir_type == REDIR_DUP_OUT)
		{
			if (handle_dup_redir(curr))
				fail = 1;
		}
		else
		{
			if (handle_simple_redir(curr))
				fail = 1;
		}
		curr = curr->bin.right;
	}
	if (fail)
		return (1);
	return (0);
}
/* ---- file: execute_sequence.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_sequence.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_sequence(t_ast *node, t_shell *shell)
{
	execute_ast(node->bin.left, shell);
	return (execute_ast(node->bin.right, shell));
}

/* ---- file: execute_subshell.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_subshell.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:13:24 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_subshell(t_ast *node, t_shell *shell)
{
	pid_t	pid;
	int		status;

	pid = fork();
	if (pid < 0)
	{
		ft_dprintf(2, "minishell: fork error\n");
		shell->exit_status = 1;
		return (1);
	}
	if (pid == 0)
	{
		execute_ast(node->subshell.child, shell);
		exit(shell->exit_status);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else
		shell->exit_status = 1;
	return (shell->exit_status);
}

/* ---- file: execute_utils.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:27:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"
#include "exec.h"
#include "ast.h"
#include <errno.h>
#include <sys/stat.h>

int	is_executable(char *path)
{
	struct stat	st;

	if (stat(path, &st) != 0)
		return (0);
	if (S_ISDIR(st.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	return (access(path, X_OK) == 0);
}

char	*join_path(const char *dir, const char *file)
{
	char	*tmp;
	size_t	len_dir;
	size_t	len_file;
	size_t	i;

	len_dir = ft_strlen(dir);
	len_file = ft_strlen(file);
	tmp = malloc(len_dir + 1 + len_file + 1);
	if (!tmp)
		return (NULL);
	ft_memcpy(tmp, dir, len_dir);
	tmp[len_dir] = '/';
	i = 0;
	while (i < len_file)
	{
		tmp[len_dir + 1 + i] = file[i];
		i++;
	}
	tmp[len_dir + 1 + len_file] = '\0';
	return (tmp);
}

static int	has_slash(char *cmd)
{
	int	i;

	if (!cmd)
		return (0);
	i = 0;
	while (cmd[i])
	{
		if (cmd[i] == '/')
			return (1);
		i++;
	}
	return (0);
}

static char	*find_path_executable(char *cmd, char **paths)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path(paths[i], cmd);
		if (!full_path)
			return (NULL);
		if (is_executable(full_path))
			return (full_path); // No liberar, lo devolvemos
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*find_executable(char *cmd, t_shell *shell)
{
	char	**paths;
	char	*res;
	char	*path_value;

	if (!cmd)
		return (NULL);
	if (has_slash(cmd))
	{
		if (is_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_value = get_env_value(shell, "PATH");
	if (!path_value || path_value[0] == '\0')
		return (NULL);
	paths = ft_split(path_value, ':');
	if (!paths)
		return (NULL);
	res = find_path_executable(cmd, paths);
	ft_free_strtab(paths);
	return (res);
}

