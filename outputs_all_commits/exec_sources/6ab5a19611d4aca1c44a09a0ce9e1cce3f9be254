/* ---- file: execute_and_or.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_and_or.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:12:56 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_and(t_ast *node, t_shell *shell)
{
	int ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret == 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

int execute_or(t_ast *node, t_shell *shell)
{
	int ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret != 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

/* ---- file: execute_ast.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_ast.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 10:47:46 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "ast.h"
#include "parser.h"
#include "exec.h"

int	execute_ast(t_ast *node, t_shell *shell)
{
	if (!node)
		return (0);
	if (node->type == N_COMMAND)
		return (execute_command(node, shell));
	else if (node->type == N_PIPE)
		return (execute_pipe(node, shell));
	else if (node->type == N_AND)
		return (execute_and(node, shell));
	else if (node->type == N_OR)
		return (execute_or(node, shell));
	else if (node->type == N_SUBSHELL)
		return (execute_subshell(node, shell));
	else if (node->type == N_SEQUENCE)
		return (execute_sequence(node, shell));
	else if (node->type == N_BACKGROUND)
		return (execute_background(node, shell));
	else if (node->type == N_REDIR)
	{
		ft_dprintf(2, "minishell: syntax error near unexpected token `newline'");
		shell->exit_status = 2;
		return (1);
	}
	// 游댢 Caso por defecto: tipo de nodo desconocido
	ft_dprintf(2, "minishell: command not found\n");
	shell->exit_status = 127;
	return (127);
}

/* ---- file: execute_background.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_background.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 18:54:37 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_background(t_ast *node, t_shell *shell)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		ft_dprintf(2, "minishell: fork error\n");
		shell->exit_status = 1;
		return (1);
	}
	if (pid == 0)
	{
		execute_ast(node->bin.left, shell);
		exit(shell->exit_status);
	}
	// padre no espera al hijo en background
	shell->exit_status = 0;
	ft_dprintf(1,"[1] %d\n", pid);
	return (0);
}

/* ---- file: execute_command.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/22 13:17:56 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "env.h"
#include "exec.h"
#include "ast.h"
#include "builtins.h"

int execute_command(t_ast *node, t_shell *shell)
{
    pid_t   pid;
    char    **env;
    char    *exec_path;
    int     ret;
    int     original_stdin;
    int     original_stdout;
    int     original_stderr;

    if (!node || !node->cmd.argv || !node->cmd.argv[0])
        return (0);

    if (node->cmd.argv[0][0] == '\0')
    {
        ft_dprintf(2, "minishell: : command not found\n");
        shell->exit_status = 127;
        return (127);
    }
    if (g_signal) // Global variable for signal handling
    {
        shell->exit_status = 130;
        g_signal = 0;
        return (130);
    }

    // --- PASO 1: GUARDAR LOS FDs ORIGINALES ---
    // Esto se hace SIEMPRE, ya que las redirecciones pueden afectar tanto a built-ins como a comandos externos.
    original_stdin = dup(STDIN_FILENO);
    original_stdout = dup(STDOUT_FILENO);
    original_stderr = dup(STDERR_FILENO);

    if (original_stdin == -1 || original_stdout == -1 || original_stderr == -1) {
        perror("minishell: dup");
        shell->exit_status = 1;
        return (1);
    }

    // --- PASO 2: APLICAR LAS REDIRECCIONES ---
    // Llama a apply_redirections en el proceso principal.
    // Esta funci칩n deber칤a manejar todos los tipos de redirecci칩n (<, >, >>, <<).
    // Si apply_redirections falla (ej. archivo no existe para lectura), deber칤a devolver un error.
    ret = apply_redirections(node->cmd.redirections);
    if (ret != 0)
    {
        // Si hay un error en las redirecciones, restauramos y salimos.
        restore_std_fds(original_stdin, original_stdout, original_stderr);
        return (1); // Exit with error
    }

    // --- PASO 3: EJECUCI칍N DEL COMANDO ---
    if (is_builtin(node->cmd.argv[0]))
    {
        // Si es un built-in, se ejecuta directamente en el proceso de la shell.
        // run_builtin ya deber칤a usar los FDs redirigidos (ej. STDOUT_FILENO).
        shell->exit_status = run_builtin(node, shell);

        // --- PASO 4: RESTAURAR LOS FDs ORIGINALES ---
        // 춰MUY IMPORTANTE para built-ins!
        restore_std_fds(original_stdin, original_stdout, original_stderr);
        return (shell->exit_status);
    }
    else // Si no es un built-in, es un comando externo
    {
        exec_path = find_executable(node->cmd.argv[0], shell);
        if (!exec_path)
        {
            // Restaurar FDs antes de devolver error
            restore_std_fds(original_stdin, original_stdout, original_stderr);
            return (print_exec_error(shell, node->cmd.argv[0], errno));
        }
        env = env_to_array(shell->env);
        if (!env)
        {
            free(exec_path);
            restore_std_fds(original_stdin, original_stdout, original_stderr);
            return (1);
        }
        
        pid = fork();
        if (pid < 0)
        {
            free(exec_path);
            ft_free_strtab(env);
            restore_std_fds(original_stdin, original_stdout, original_stderr);
            return (print_exec_error(shell, node->cmd.argv[0], errno));
        }
        if (pid == 0) // Proceso hijo
        {
            // Para comandos externos, los FDs ya est치n redirigidos en el padre,
            // pero el hijo los hereda. A칰n as칤, es buena pr치ctica llamarlo aqu칤 de nuevo
            // si la l칩gica de `apply_redirections` maneja cierre de FDs que no son std
            // o para asegurar que el hijo tiene los correctos antes de execve.
            // Ojo: Si apply_redirections abre FDs nuevos, deben cerrarse tras el dup2.
            
            // Si apply_redirections *abre* y *cierra* FDs, y s칩lo hace el dup2,
            // entonces no es necesario volver a llamarla aqu칤. Los FDs se heredan.
            // Si apply_redirections solo usa dup2, los FDs originales est치n cerrados.
            // La 칰nica raz칩n para llamarlo de nuevo es si quieres que el hijo maneje
            // sus propios FDs temporales (como heredoc) que el padre no.
            
            // Para mantenerlo simple y seguro, es mejor que apply_redirections
            // solo realice dup2, y que los FDs de archivos abiertos para redirecci칩n
            // se cierren inmediatamente despu칠s de cada dup2.
            
            // Ejemplo: open("file", ...) -> new_fd; dup2(new_fd, STDOUT_FILENO); close(new_fd);
            // Esto asegura que solo STDIN/OUT/ERR est칠n abiertos y redirigidos.

            signal(SIGINT, SIG_DFL); // Restablecer manejadores de se침al para el hijo
            signal(SIGQUIT, SIG_DFL);
            
            // No necesitas `apply_redirections` aqu칤 de nuevo si ya se hizo en el padre
            // y los FDs se cierran inmediatamente despu칠s del dup2.
            // Sin embargo, si tu apply_redirections abre muchos FDs y los mantiene abiertos
            // (lo cual NO es recomendable), entonces podr칤as necesitar una forma
            // de cerrar FDs no est치ndar en el hijo antes de execve.

            execve(exec_path, node->cmd.argv, env);
            // Si execve falla, imprime error y sale del hijo
            print_exec_error(shell, node->cmd.argv[0], errno);
            exit(127);
        }
        // Proceso padre
        waitpid(pid, &shell->exit_status, 0);
        if (WIFEXITED(shell->exit_status))
            shell->exit_status = WEXITSTATUS(shell->exit_status);
        else if (WIFSIGNALED(shell->exit_status))
            shell->exit_status = 128 + WTERMSIG(shell->exit_status);
        
        free(exec_path);
        ft_free_strtab(env);

        // --- PASO 4: RESTAURAR LOS FDs ORIGINALES ---
        // 춰Tambi칠n importante para comandos externos!
        restore_std_fds(original_stdin, original_stdout, original_stderr);
    }
    return (shell->exit_status);
}

// --- NUEVA FUNCI칍N DE AYUDA ---
// Funci칩n para restaurar los descriptores de archivo est치ndar
void restore_std_fds(int original_stdin, int original_stdout, int original_stderr)
{
    // Restaurar STDIN, STDOUT, STDERR a sus valores originales.
    // Aseg칰rate de que los FDs originales no sean -1 antes de usarlos.
    if (original_stdin != -1)
    {
        dup2(original_stdin, STDIN_FILENO);
        close(original_stdin);
    }
    if (original_stdout != -1)
    {
        dup2(original_stdout, STDOUT_FILENO);
        close(original_stdout);
    }
    if (original_stderr != -1)
    {
        dup2(original_stderr, STDERR_FILENO);
        close(original_stderr);
    }
}

/* ---- file: execute_heredocs.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_heredocs.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 11:45:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

/*
** Heredoc: Lee l칤neas hasta 'delimiter', escribe en un pipe y devuelve fd lectura.
** 춰No libera recursos ajenos ni imprime nada si el pipe falla!
*/
int	heredoc_prepare(const char *delimiter)
{
	int		pipefd[2];
	char	*line;
	size_t	del_len;

	del_len = ft_strlen(delimiter);
	if (pipe(pipefd) == -1)
		return (-1);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_DFL);
	while (1)
	{
		line = readline("> ");
		if (!line)
			break;
		if (ft_strncmp(line, delimiter, del_len) == 0 && line[del_len] == '\0')
		{
			free(line);
			break;
		}
		write(pipefd[1], line, ft_strlen(line));
		write(pipefd[1], "\n", 1);
		free(line);
	}
	close(pipefd[1]);
	signal(SIGQUIT, SIG_DFL);
	signal(SIGINT, SIG_DFL);
	return (pipefd[0]);
}

/* ---- file: execute_pipe.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:25:31 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int	execute_pipe(t_ast *node, t_shell *shell)
{
	int		pipefd[2];
	pid_t	pid_left;
	pid_t	pid_right;
	int		status_left;
	int		status_right;

	if (pipe(pipefd) == -1)
	{
		ft_dprintf(2, "minishell: pipe error\n");
		shell->exit_status = 1;
		return (1);
	}
	pid_left = fork();
	if (pid_left == 0)
	{
		// Proceso hijo izquierdo: escribe en pipe
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[1]);
		exit(execute_ast(node->bin.left, shell));
	}
	pid_right = fork();
	if (pid_right == 0)
	{
		// Proceso hijo derecho: lee del pipe
		close(pipefd[1]);
		dup2(pipefd[0], STDIN_FILENO);
		close(pipefd[0]);
		exit(execute_ast(node->bin.right, shell));
	}
	close(pipefd[0]);
	close(pipefd[1]);
	waitpid(pid_left, &status_left, 0);
	waitpid(pid_right, &status_right, 0);
	if (WIFEXITED(status_right))
		shell->exit_status = WEXITSTATUS(status_right);
	else
		shell->exit_status = 1;
	return (shell->exit_status);
}

/* ---- file: execute_redirections.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:12:04 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/22 13:40:41 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

// --- Funciones Auxiliares ---

// Redirige 'fd_to_redirect_from' a 'target_std_fd' (ej., 1 para stdout).
// Cierra 'fd_to_redirect_from' despu칠s de dup2.
static int  redirect_to(int fd_to_redirect_from, int target_std_fd)
{
    if (dup2(fd_to_redirect_from, target_std_fd) < 0)
    {
        perror("minishell: dup2");
        close(fd_to_redirect_from); // Asegurarse de cerrar el FD si dup2 falla
        return (1); // Indica fallo
    }
    close(fd_to_redirect_from); // 춰IMPORTANTE! Cierra el FD original despu칠s de duplicarlo
    return (0); // Indica 칠xito
}

// Maneja la redirecci칩n de heredoc (<<).
// Asume que heredoc_read crea un archivo temporal o pipe y devuelve un FD.
// ... (resto del c칩digo igual) ...
static int  handle_heredoc(t_ast *redir_node)
{
    int fd;
    // CORRECCI칍N: Acceder directamente a 'delimiter' dentro de 'redir'
    fd = heredoc_read(redir_node->redir.delimiter);
    if (fd < 0)
        return (1);
    return (redirect_to(fd, STDIN_FILENO));
}

int open_redirection(t_ast *redir_node)
{
    int fd;
    int flags;
    mode_t mode;

    fd = -1;
    if (!redir_node)
        return (-1);

    flags = 0;
    mode = 0644;

    // CORRECCI칍N: Acceder directamente a 'redir_type' y 'filename' dentro de 'redir'
    if (redir_node->redir.redir_type == REDIR_IN)
        flags = O_RDONLY;
    else if (redir_node->redir.redir_type == REDIR_OUT || redir_node->redir.redir_type == REDIR_FORCE)
        flags = O_WRONLY | O_CREAT | O_TRUNC;
    else if (redir_node->redir.redir_type == REDIR_APPEND)
        flags = O_WRONLY | O_CREAT | O_APPEND;
    else if (redir_node->redir.redir_type == REDIR_ERR || redir_node->redir.redir_type == REDIR_ALL)
        flags = O_WRONLY | O_CREAT | O_TRUNC;
    else if (redir_node->redir.redir_type == REDIR_APPEND_ERR || redir_node->redir.redir_type == REDIR_APPEND_ALL)
        flags = O_WRONLY | O_CREAT | O_APPEND;
    else
    {
        ft_dprintf(2, "minishell: internal error: unexpected redirection type in open_redirection\n");
        return (-1);
    }
    
    if (flags & O_CREAT)
        fd = open(redir_node->redir.filename, flags, mode);
    else
        fd = open(redir_node->redir.filename, flags);

    return (fd);
}

static int  handle_dup_redir(t_ast *redir_node)
{
    int src_fd;
    int dest_fd;

    // CORRECCI칍N: Acceder directamente a 'redir_fd' y 'filename' dentro de 'redir'
    dest_fd = redir_node->redir.redir_fd;

    if (ft_strcmp(redir_node->redir.filename, "-") == 0)
        src_fd = -1;
    else
    {
        src_fd = ft_atoi(redir_node->redir.filename);
    }

    if (src_fd == -1)
    {
        if (close(dest_fd) < 0)
        {
            perror("minishell: close");
            return (1);
        }
        return (0);
    }
    
    if (dest_fd == src_fd)
        return (0);

    if (dup2(src_fd, dest_fd) < 0)
    {
        perror("minishell: dup2");
        return (1);
    }
    return (0);
}

int handle_simple_redir(t_ast *redir_node)
{
    int fd;
    int target_std_fd;

    fd = open_redirection(redir_node);
    if (fd < 0)
    {
        perror(redir_node->redir.filename);
        return (1);
    }

    // A칌ADIMOS LA L칍GICA PARA REDIR_ERR y REDIR_APPEND_ERR AQU칈
    if (redir_node->redir.redir_fd != -1)
        target_std_fd = redir_node->redir.redir_fd;
    else if (redir_node->redir.redir_type == REDIR_IN || redir_node->redir.redir_type == REDIR_HEREDOC)
        target_std_fd = STDIN_FILENO;
    else if (redir_node->redir.redir_type == REDIR_OUT || redir_node->redir.redir_type == REDIR_APPEND || redir_node->redir.redir_type == REDIR_FORCE)
        target_std_fd = STDOUT_FILENO;
    // ---> INSERTA ESTE BLOQUE AQU칈 <---
    else if (redir_node->redir.redir_type == REDIR_ERR || redir_node->redir.redir_type == REDIR_APPEND_ERR)
        target_std_fd = STDERR_FILENO; // <--- 춰Esta es la clave para 2> y 2>>!
    // ------------------------------------
    else // Este 'else' deber칤a capturar REDIR_ALL y REDIR_APPEND_ALL, u otros casos no manejados.
    {
        // Esto solo se ejecuta si el tipo de redirecci칩n es REDIR_ALL o REDIR_APPEND_ALL
        // O si hay un tipo inesperado no cubierto en los 'if' anteriores.
        // La l칩gica para REDIR_ALL/APPEND_ALL la manejaremos aqu칤 mismo, en lugar de un 'if' separado fuera.
        if (redir_node->redir.redir_type == REDIR_ALL || redir_node->redir.redir_type == REDIR_APPEND_ALL)
        {
            if (redirect_to(fd, STDOUT_FILENO) != 0)
            {
                return (1);
            }
            if (dup2(STDOUT_FILENO, STDERR_FILENO) < 0)
            {
                perror("minishell: dup2 for stderr");
                return (1);
            }
            return (0);
        }
        else
        {
            // Si llegamos aqu칤 con otro tipo de redirecci칩n, es un error de l칩gica.
            ft_dprintf(2, "minishell: internal error: unhandled redirection type in handle_simple_redir\n");
            close(fd); // Aseg칰rate de cerrar el FD abierto si no se va a usar
            return (1);
        }
    }
    
    // Si no fue REDIR_ALL/APPEND_ALL, entonces se usa el target_std_fd determinado arriba
    return (redirect_to(fd, target_std_fd));
}

int apply_redirections(t_ast *redir_list)
{
    t_ast   *curr;
    int     fail;

    fail = 0;
    curr = redir_list;

    while (curr)
    {
        if (curr->type != N_REDIR)
        {
            ft_dprintf(2, "minishell: internal error: expected N_REDIR node in redirection list\n");
            return (1);
        }

        // CORRECCI칍N: Acceder directamente a 'redir_type' dentro de 'redir'
        if (curr->redir.redir_type == REDIR_HEREDOC)
        {
            if (handle_heredoc(curr))
                fail = 1;
        }
        else if (curr->redir.redir_type == REDIR_DUP_IN || curr->redir.redir_type == REDIR_DUP_OUT)
        {
            if (handle_dup_redir(curr))
                fail = 1;
        }
        else
        {
            if (handle_simple_redir(curr))
                fail = 1;
        }

        if (fail)
        {
            return (1);
        }

        // Se mantiene `curr = curr->bin.right;` asumiendo que tu AST organiza las redirecciones as칤.
        curr = curr->bin.right;
    }
    return (0);
}

/* ---- file: execute_sequence.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_sequence.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_sequence(t_ast *node, t_shell *shell)
{
	execute_ast(node->bin.left, shell);
	return (execute_ast(node->bin.right, shell));
}

/* ---- file: execute_subshell.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_subshell.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:13:24 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_subshell(t_ast *node, t_shell *shell)
{
	pid_t	pid;
	int		status;

	pid = fork();
	if (pid < 0)
	{
		ft_dprintf(2, "minishell: fork error\n");
		shell->exit_status = 1;
		return (1);
	}
	if (pid == 0)
	{
		execute_ast(node->subshell.child, shell);
		exit(shell->exit_status);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else
		shell->exit_status = 1;
	return (shell->exit_status);
}

/* ---- file: execute_utils.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:27:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"
#include "exec.h"
#include "ast.h"
#include <errno.h>
#include <sys/stat.h>

int	is_executable(char *path)
{
	struct stat	st;

	if (stat(path, &st) != 0)
		return (0);
	if (S_ISDIR(st.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	return (access(path, X_OK) == 0);
}

char	*join_path(const char *dir, const char *file)
{
	char	*tmp;
	size_t	len_dir;
	size_t	len_file;
	size_t	i;

	len_dir = ft_strlen(dir);
	len_file = ft_strlen(file);
	tmp = malloc(len_dir + 1 + len_file + 1);
	if (!tmp)
		return (NULL);
	ft_memcpy(tmp, dir, len_dir);
	tmp[len_dir] = '/';
	i = 0;
	while (i < len_file)
	{
		tmp[len_dir + 1 + i] = file[i];
		i++;
	}
	tmp[len_dir + 1 + len_file] = '\0';
	return (tmp);
}

static int	has_slash(char *cmd)
{
	int	i;

	if (!cmd)
		return (0);
	i = 0;
	while (cmd[i])
	{
		if (cmd[i] == '/')
			return (1);
		i++;
	}
	return (0);
}

static char	*find_path_executable(char *cmd, char **paths)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path(paths[i], cmd);
		if (!full_path)
			return (NULL);
		if (is_executable(full_path))
			return (full_path); // No liberar, lo devolvemos
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*find_executable(char *cmd, t_shell *shell)
{
	char	**paths;
	char	*res;
	char	*path_value;

	if (!cmd)
		return (NULL);
	if (has_slash(cmd))
	{
		if (is_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_value = get_env_value(shell, "PATH");
	if (!path_value || path_value[0] == '\0')
		return (NULL);
	paths = ft_split(path_value, ':');
	if (!paths)
		return (NULL);
	res = find_path_executable(cmd, paths);
	ft_free_strtab(paths);
	return (res);
}

