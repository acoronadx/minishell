/* ---- file: execute_and_or.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_and_or.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:49:04 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_and(t_ast *node, t_shell *shell)
{
    int ret;

    ret = execute_ast(node->bin.left, shell);
    if (ret == 0)
        ret = execute_ast(node->bin.right, shell);
    else
        shell->exit_status = ret;
    return (ret);
}

int execute_or(t_ast *node, t_shell *shell)
{
    int ret;

    ret = execute_ast(node->bin.left, shell);
    if (ret != 0)
        ret = execute_ast(node->bin.right, shell);
    else
        shell->exit_status = ret;
    return (ret);
}

/* ---- file: execute_ast.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_ast.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:48:43 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_ast(t_ast *node, t_shell *shell)
{
    int ret;

    if (!node)
        return (0);
    if (node->type == N_COMMAND)
        ret = execute_command(node, shell);
    else if (node->type == N_PIPE)
        ret = execute_pipe(node, shell);
    else if (node->type == N_AND)
        ret = execute_and(node, shell);
    else if (node->type == N_OR)
        ret = execute_or(node, shell);
    else if (node->type == N_SUBSHELL)
        ret = execute_subshell(node, shell);
    else if (node->type == N_SEQUENCE)
        ret = execute_sequence(node, shell);
    else if (node->type == N_BACKGROUND)
        ret = execute_background(node, shell);
    else if (node->type == N_REDIR)
    {
        ft_dprintf(2, "minishell: syntax error near unexpected token `newline'\n");
        shell->exit_status = 2;
        ret = 1;
    }
    else
    {
        ft_dprintf(2, "minishell: command not found\n");
        shell->exit_status = 127;
        ret = 127;
    }
    return (ret);
}

/* ---- file: execute_background.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_background.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:49:41 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_background(t_ast *node, t_shell *shell)
{
    pid_t pid;

    pid = fork();
    if (pid < 0)
    {
        ft_dprintf(2, "minishell: fork error\n");
        shell->exit_status = 1;
        return (1);
    }
    if (pid == 0)
    {
        /* Hijo: señales por defecto para comportamiento bash-like */
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        _exit(execute_ast(node->bin.left, shell) & 0xFF);
    }
    /* Padre: no espera al hijo en background */
    shell->exit_status = 0;
    ft_dprintf(1, "[1] %d\n", pid);
    return (0);
}

/* ---- file: execute_command.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:03 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void restore_std_fds(int saved_in, int saved_out, int saved_err)
{
    if (saved_in  != -1) { dup2(saved_in,  STDIN_FILENO);  close(saved_in);  }
    if (saved_out != -1) { dup2(saved_out, STDOUT_FILENO); close(saved_out); }
    if (saved_err != -1) { dup2(saved_err, STDERR_FILENO); close(saved_err); }
}

int execute_command(t_ast *node, t_shell *shell)
{
    pid_t   pid;
    char    **env;
    char    *exec_path;
    int     status;

    if (!node || !node->cmd.argv || !node->cmd.argv[0])
        return (0);

    if (node->cmd.argv[0][0] == '\0')
    {
        ft_dprintf(2, "minishell: : command not found\n");
        shell->exit_status = 127;
        return (127);
    }

    /* -------- BUILTIN en el PADRE (con redirecciones) -------- */
    if (is_builtin(node->cmd.argv[0]))
    {
        int saved_in  = dup(STDIN_FILENO);
        int saved_out = dup(STDOUT_FILENO);
        int saved_err = dup(STDERR_FILENO);

        if (saved_in == -1 || saved_out == -1 || saved_err == -1)
        {
            perror("minishell: dup");
            if (saved_in  != -1) close(saved_in);
            if (saved_out != -1) close(saved_out);
            if (saved_err != -1) close(saved_err);
            shell->exit_status = 1;
            return (1);
        }
        if (apply_redirections(node->cmd.redirections) != 0)
        {
            restore_std_fds(saved_in, saved_out, saved_err);
            shell->exit_status = 1;
            return (1);
        }
        shell->exit_status = run_builtin(node, shell);
        restore_std_fds(saved_in, saved_out, saved_err);
        return (shell->exit_status);
    }

    /* -------- EXTERNOS -------- */
    exec_path = find_executable(node->cmd.argv[0], shell);
    if (!exec_path)
        return (print_exec_error(shell, node->cmd.argv[0], errno));

    env = env_to_array(shell->env);
    if (!env)
    {
        free(exec_path);
        shell->exit_status = 1;
        return (1);
    }

    pid = fork();
    if (pid < 0)
    {
        int ret = print_exec_error(shell, node->cmd.argv[0], errno);
        free(exec_path);
        ft_free_strtab(env);
        return (ret);
    }
    if (pid == 0)
    {
        /* --- HIJO --- */
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);

        if (apply_redirections(node->cmd.redirections) != 0)
            _exit(1);

        execve(exec_path, node->cmd.argv, env);
        print_exec_error(shell, node->cmd.argv[0], errno);
        _exit(127);
    }

    /* --- PADRE --- */
    if (waitpid(pid, &status, 0) == -1)
        shell->exit_status = 1;
    else if (WIFEXITED(status))
        shell->exit_status = WEXITSTATUS(status);
    else if (WIFSIGNALED(status))
    {
        int sig = WTERMSIG(status);
        shell->exit_status = 128 + sig;
        if (sig == SIGINT)
            write(STDOUT_FILENO, "\n", 1);
        else if (sig == SIGQUIT)
            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
    }
    else
        shell->exit_status = 1;

    free(exec_path);
    ft_free_strtab(env);
    return (shell->exit_status);
}

/* ---- file: execute_heredocs.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_heredocs.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:51:44 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int heredoc_prepare(const char *delimiter)
{
    int     pipefd[2];
    char   *line;
    size_t  del_len;

    del_len = ft_strlen(delimiter);
    if (pipe(pipefd) == -1)
        return (-1);

    /* Mientras se lee heredoc: hijo “modalidad lectura” */
    signal(SIGQUIT, SIG_IGN);
    signal(SIGINT,  SIG_DFL);

    while (1)
    {
        line = readline("> ");
        if (!line)
            break;
        if (ft_strncmp(line, delimiter, del_len) == 0 && line[del_len] == '\0')
        {
            free(line);
            break;
        }
        write(pipefd[1], line, ft_strlen(line));
        write(pipefd[1], "\n", 1);
        free(line);
    }
    close(pipefd[1]);

    /* Restaurar por si otros caminos esperan valores DFL */
    signal(SIGQUIT, SIG_DFL);
    signal(SIGINT,  SIG_DFL);
    return (pipefd[0]);
}

/* ---- file: execute_pipe.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:18 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_pipe(t_ast *node, t_shell *shell)
{
    int     pipefd[2];
    pid_t   pid_l, pid_r;
    int     st_l = 0, st_r = 0;

    if (pipe(pipefd) == -1)
    {
        ft_dprintf(2, "minishell: pipe error\n");
        shell->exit_status = 1;
        return (1);
    }

    pid_l = fork();
    if (pid_l == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        close(pipefd[0]);
        if (dup2(pipefd[1], STDOUT_FILENO) < 0)
            _exit(1);
        close(pipefd[1]);
        _exit(execute_ast(node->bin.left, shell) & 0xFF);
    }

    pid_r = fork();
    if (pid_r == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        close(pipefd[1]);
        if (dup2(pipefd[0], STDIN_FILENO) < 0)
            _exit(1);
        close(pipefd[0]);
        _exit(execute_ast(node->bin.right, shell) & 0xFF);
    }

    close(pipefd[0]);
    close(pipefd[1]);

    if (waitpid(pid_l, &st_l, 0) < 0)
        st_l = 0;
    if (waitpid(pid_r, &st_r, 0) < 0)
        st_r = 0;

    if (WIFEXITED(st_r))
        shell->exit_status = WEXITSTATUS(st_r);
    else if (WIFSIGNALED(st_r))
    {
        int sig = WTERMSIG(st_r);
        if (sig == SIGINT)
            write(STDOUT_FILENO, "\n", 1);
        else if (sig == SIGQUIT)
            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
        shell->exit_status = 128 + sig;
    }
    else
        shell->exit_status = 1;

    return (shell->exit_status);
}

/* ---- file: execute_redirections.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:12:04 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 13:03:19 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "ast.h"
#include "minishell.h"

/* -------------------------------------------------------------------------- */
/* helpers                                                                    */
/* -------------------------------------------------------------------------- */

static int  redirect_to(int fd, int std_fd)
{
    int ret = 0;

    if (dup2(fd, std_fd) < 0)
    {
        perror("minishell: dup2");
        close(fd);
        ret = 1;
    }
    close(fd);
    return (ret);
}

static int  handle_heredoc(t_ast *redir)
{
    int fd = heredoc_read(redir->redir.delimiter);

    if (fd < 0)
        return (1);
    return (redirect_to(fd, STDIN_FILENO));
}

int         open_redirection(t_ast *redir)
{
    int fd = -1;

    if (!redir || redir->type != N_REDIR)
        return (-1);

    if (redir->redir.redir_type == REDIR_IN)
        fd = open(redir->redir.filename, O_RDONLY);
    else if (redir->redir.redir_type == REDIR_OUT)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    else if (redir->redir.redir_type == REDIR_FORCE)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    else if (redir->redir.redir_type == REDIR_APPEND)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
    else if (redir->redir.redir_type == REDIR_ERR)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    else if (redir->redir.redir_type == REDIR_APPEND_ERR)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
    else if (redir->redir.redir_type == REDIR_ALL)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    else if (redir->redir.redir_type == REDIR_APPEND_ALL)
        fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
    return (fd);
}

static int  handle_dup_redir(t_ast *redir)
{
    int target = redir->redir.redir_fd;
    int std_fd = (redir->redir.redir_type == REDIR_DUP_OUT) ? STDOUT_FILENO
                                                            : STDIN_FILENO;

    if (target == std_fd)
        return (0);
    if (dup2(target, std_fd) < 0)
    {
        perror("minishell: dup2");
        return (1);
    }
    return (0);
}

int         handle_simple_redir(t_ast *redir)
{
    int fd;
    int ret = 0;

    fd = open_redirection(redir);
    if (fd < 0)
    {
        perror(redir->redir.filename);
        return (1);
    }
    if (redir->redir.redir_type == REDIR_IN)
        ret = redirect_to(fd, STDIN_FILENO);
    else if (redir->redir.redir_type == REDIR_OUT
        || redir->redir.redir_type == REDIR_FORCE
        || redir->redir.redir_type == REDIR_APPEND)
        ret = redirect_to(fd, STDOUT_FILENO);
    else if (redir->redir.redir_type == REDIR_ERR
        || redir->redir.redir_type == REDIR_APPEND_ERR)
        ret = redirect_to(fd, STDERR_FILENO);
    else if (redir->redir.redir_type == REDIR_ALL
        || redir->redir.redir_type == REDIR_APPEND_ALL)
    {
        if (dup2(fd, STDOUT_FILENO) < 0)
            ret = 1;
        else if (dup2(fd, STDERR_FILENO) < 0)
            ret = 1;
        close(fd);
    }
    return (ret);
}

int         apply_redirections(t_ast *redir_list)
{
    t_ast   *curr = redir_list;
    int     fail = 0;

    while (curr)
    {
        if (curr->type != N_REDIR)
            return (1);
        if (curr->redir.redir_type == REDIR_HEREDOC)
        {
            if (handle_heredoc(curr))
                fail = 1;
        }
        else if (curr->redir.redir_type == REDIR_DUP_IN
            || curr->redir.redir_type == REDIR_DUP_OUT)
        {
            if (handle_dup_redir(curr))
                fail = 1;
        }
        else
        {
            if (handle_simple_redir(curr))
                fail = 1;
        }
        curr = curr->bin.right;
    }
    return (fail ? 1 : 0);
}

/* ---- file: execute_sequence.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_sequence.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_sequence(t_ast *node, t_shell *shell)
{
	execute_ast(node->bin.left, shell);
	return (execute_ast(node->bin.right, shell));
}

/* ---- file: execute_subshell.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_subshell.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:32 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_subshell(t_ast *node, t_shell *shell)
{
    pid_t pid;
    int   st = 0;

    pid = fork();
    if (pid < 0)
    {
        ft_dprintf(2, "minishell: fork error\n");
        shell->exit_status = 1;
        return (1);
    }
    if (pid == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        _exit(execute_ast(node->subshell.child, shell) & 0xFF);
    }
    if (waitpid(pid, &st, 0) < 0)
        shell->exit_status = 1;
    else if (WIFEXITED(st))
        shell->exit_status = WEXITSTATUS(st);
    else if (WIFSIGNALED(st))
    {
        int sig = WTERMSIG(st);
        if (sig == SIGINT)
            write(STDOUT_FILENO, "\n", 1);
        else if (sig == SIGQUIT)
            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
        shell->exit_status = 128 + sig;
    }
    else
        shell->exit_status = 1;

    return (shell->exit_status);
}

/* ---- file: execute_utils.c ---- */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:27:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"
#include "exec.h"
#include "ast.h"
#include <errno.h>
#include <sys/stat.h>

int	is_executable(char *path)
{
	struct stat	st;

	if (stat(path, &st) != 0)
		return (0);
	if (S_ISDIR(st.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	return (access(path, X_OK) == 0);
}

char	*join_path(const char *dir, const char *file)
{
	char	*tmp;
	size_t	len_dir;
	size_t	len_file;
	size_t	i;

	len_dir = ft_strlen(dir);
	len_file = ft_strlen(file);
	tmp = malloc(len_dir + 1 + len_file + 1);
	if (!tmp)
		return (NULL);
	ft_memcpy(tmp, dir, len_dir);
	tmp[len_dir] = '/';
	i = 0;
	while (i < len_file)
	{
		tmp[len_dir + 1 + i] = file[i];
		i++;
	}
	tmp[len_dir + 1 + len_file] = '\0';
	return (tmp);
}

static int	has_slash(char *cmd)
{
	int	i;

	if (!cmd)
		return (0);
	i = 0;
	while (cmd[i])
	{
		if (cmd[i] == '/')
			return (1);
		i++;
	}
	return (0);
}

static char	*find_path_executable(char *cmd, char **paths)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path(paths[i], cmd);
		if (!full_path)
			return (NULL);
		if (is_executable(full_path))
			return (full_path); // No liberar, lo devolvemos
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*find_executable(char *cmd, t_shell *shell)
{
	char	**paths;
	char	*res;
	char	*path_value;

	if (!cmd)
		return (NULL);
	if (has_slash(cmd))
	{
		if (is_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_value = get_env_value(shell, "PATH");
	if (!path_value || path_value[0] == '\0')
		return (NULL);
	paths = ft_split(path_value, ':');
	if (!paths)
		return (NULL);
	res = find_path_executable(cmd, paths);
	ft_free_strtab(paths);
	return (res);
}

