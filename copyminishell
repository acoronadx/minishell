/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast.h                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 15:24:41 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 19:36:13 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef AST_H
# define AST_H

/* Evitamos ciclos: no necesitamos lexer.h aquí, con una forward declaration basta. */
typedef struct s_token t_token;   /* <- forward declaration clave */
typedef struct s_ast   t_ast;
typedef struct s_shell t_shell;

# include "minishell.h"
# include "env.h"
# include "parser.h"

typedef enum e_node_type
{
    N_COMMAND,
    N_PIPE,
    N_REDIR,
    N_SUBSHELL,
    N_SEQUENCE,
    N_AND,
    N_OR,
    N_BACKGROUND
}   t_node_type;

typedef enum e_redir_type
{
        REDIR_IN,
        REDIR_OUT,
        REDIR_APPEND,
        REDIR_HEREDOC,
        REDIR_ERR,
        REDIR_APPEND_ERR,
        REDIR_ALL,
        REDIR_APPEND_ALL,
        REDIR_FORCE,
        REDIR_DUP_IN,
        REDIR_DUP_OUT,
        REDIR_INVALID
}       t_redir_type;

struct s_ast
{
    t_node_type type;

    union
    {
        struct
        {
            char        **argv;
            struct s_ast *redirections; // lista ligada de N_REDIR
        } cmd;

        struct
        {
            char        *filename;
            char        *delimiter;
            t_redir_type redir_type;
            int         redir_fd;
        } redir;

        struct
        {
            struct s_ast *left;
            struct s_ast *right;
        } bin;

        struct
        {
            struct s_ast *child;
            struct s_ast *redirections;
        } subshell;
    };
};

/* Constructores */
t_ast   *ast_new_command(char **argv, t_ast *redirections);
t_ast   *ast_new_redir(char *filename, char *delimiter,
                       t_redir_type redir_type, int redir_fd);
t_ast   *ast_new_binary(t_node_type type, t_ast *left, t_ast *right);
t_ast   *ast_new_subshell(t_ast *child, t_ast *redirections);
t_ast   *create_command_node(char **argv, t_ast *redir_list_head);

/* Otros */
t_ast   *ast_copy(t_ast *node);
void    free_ast(t_ast *node);
void    free_ast_recursive(t_ast *node);
int     check_syntax(t_ast *node);
int     is_lparen(t_token *tok);
t_ast   *build_ast(t_token *tokens);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast.h                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 15:24:41 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 15:26:54 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef AST_H
# define AST_H

/* Evitamos ciclos: no necesitamos lexer.h aquí, con una forward declaration basta. */
typedef struct s_token t_token;   /* <- forward declaration clave */
typedef struct s_ast   t_ast;
typedef struct s_shell t_shell;

# include "minishell.h"
# include "env.h"
# include "parser.h"

typedef enum e_node_type
{
    N_COMMAND,
    N_PIPE,
    N_REDIR,
    N_SUBSHELL,
    N_SEQUENCE,
    N_AND,
    N_OR,
    N_BACKGROUND
}   t_node_type;

typedef enum e_redir_type
{
        REDIR_IN,
        REDIR_OUT,
        REDIR_APPEND,
        REDIR_HEREDOC,
        REDIR_ERR,
        REDIR_APPEND_ERR,
        REDIR_ALL,
        REDIR_APPEND_ALL,
        REDIR_FORCE,
        REDIR_DUP_IN,
        REDIR_DUP_OUT,
        REDIR_INVALID
}       t_redir_type;

struct s_ast
{
    t_node_type type;

    union
    {
        struct
        {
            char        **argv;
            struct s_ast *redirections; // lista ligada de N_REDIR
        } cmd;

        struct
        {
            char        *filename;
            char        *delimiter;
            t_redir_type redir_type;
            int         redir_fd;
        } redir;

        struct
        {
            struct s_ast *left;
            struct s_ast *right;
        } bin;

        struct
        {
            struct s_ast *child;
            struct s_ast *redirections;
        } subshell;
    };
};

/* Constructores */
t_ast   *ast_new_command(char **argv, t_ast *redirections);
t_ast   *ast_new_redir(char *filename, char *delimiter,
                       t_redir_type redir_type, int redir_fd);
t_ast   *ast_new_binary(t_node_type type, t_ast *left, t_ast *right);
t_ast   *ast_new_subshell(t_ast *child, t_ast *redirections);
t_ast   *create_command_node(char **argv, t_ast *redir_list_head);

/* Otros */
t_ast   *ast_copy(t_ast *node);
void    free_ast(t_ast *node);
void    free_ast_recursive(t_ast *node);
int     check_syntax(t_ast *node);
int     is_lparen(t_token *tok);
t_ast   *build_ast(t_token *tokens);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:31:23 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:32:47 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BUILTINS_H
#define BUILTINS_H

#include "minishell.h"
#include "ast.h"
#include "exec.h"

int	is_builtin(const char *cmd);
int	run_builtin(t_ast *node, t_shell *shell);
int	run_echo(char **argv);
int	run_cd(char **argv, t_shell *shell);
int	run_pwd(void);
int	run_export(char **argv, t_shell *shell);
int	run_unset(char **argv, t_shell *shell);
int	run_env(t_shell *shell);
int	run_exit(char **argv, t_shell *shell);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.h                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/27 19:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/22 13:26:00 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ENV_H
# define ENV_H

# include "minishell.h"

typedef struct s_shell t_shell;
typedef struct s_env t_env;

// --- Prototipos de funciones de init_env_list.c ---
t_env   *init_env_list(char **envp);
t_env	*env_create(char *key, char *value, int exported);
void	env_add_back(t_env **env, t_env *new);

// --- Prototipos de funciones de env_free.c ---
void    free_env_list(t_env *env);

// --- Prototipos de funciones de manipulación de env ---
char	*get_env_value(t_shell *shell, const char *key);
char	**env_to_array(t_env *env);


#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.h                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:08:04 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 18:00:07 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef EXEC_H
# define EXEC_H

# include "minishell.h"
# include "ast.h"
# include <sys/types.h>

/* Ejecución del AST */
int	execute_ast(t_ast *node, t_shell *shell);
int	execute_command(t_ast *node, t_shell *shell);
int	execute_pipe(t_ast *node, t_shell *shell);
int	execute_and(t_ast *node, t_shell *shell);
int	execute_or(t_ast *node, t_shell *shell);
int	execute_subshell(t_ast *node, t_shell *shell);
int	execute_sequence(t_ast *node, t_shell *shell);
int	execute_background(t_ast *node, t_shell *shell);

/* Redirecciones */
int	open_redirection(t_ast *redir);
int	handle_simple_redir(t_ast *redir);
int	apply_redirections(t_ast *redir_list);

/* Heredoc */
int	heredoc_prepare(const char *delimiter);

/* Auxiliares */
void	restore_std_fds(int original_stdin, int original_stdout, int original_stderr);
char	*join_path(const char *dir, const char *file);
int		is_executable(char *path);
char	*find_executable(char *cmd, t_shell *shell);

/* Errores */
int		print_exec_error(t_shell *shell, const char *cmd, int err_code);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/27 20:17:25 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:31:54 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef EXPAND_H
# define EXPAND_H

# include "minishell.h"
# include "env.h"

/* expand.c */
int     expand_variables(t_shell *shell);
char    *expand_token(const char *str, t_shell *shell);

/* expand_dollar.c */
char    *expand_value(const char *str, int *i, t_shell *shell);
int     handle_dollar(const char *str, int *i, char *dst, int j, t_shell *shell);

/* calculate_expand_len.c */
size_t  calculate_expanded_len(const char *str, t_shell *shell);
size_t  handle_dollar_len(const char *str, int *i, t_shell *shell);

/* handle_expand_cases.c */
size_t  handle_pid_len(void);
size_t  handle_exit_status_len(t_shell *shell);
char    *get_program_name_str(t_shell *shell);

/* expand_tilde.c */
char    *expand_tilde_internal(const char *str, t_shell *shell);
size_t  get_tilde_prefix_len(const char *str);

/* expand_utils.c */
char    *find_var(t_env *env, char *name);

/* quote_removal.c */
void    remove_quotes(t_token *tokens);

/* word_splitting.c */
void    perform_word_splitting(t_shell *shell);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 15:24:24 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/31 16:22:50 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LEXER_H
# define LEXER_H

/* Importante: NO incluir minishell.h aquí para evitar ciclos. */
/* Incluye solo lo mínimo estrictamente necesario. */
# include <stddef.h>

/* ------------------------- Tipos de token ------------------------- */
typedef enum e_token_type
{
        T_WORD,
        T_PIPE,         // |
        T_OR,           // ||
        T_AND,          // &&
        T_BG,           // &
        T_SEMI,         // ;
        T_REDIR_IN,     // <
        T_REDIR_OUT,    // >
        T_APPEND,       // >>
        T_HEREDOC,      // <<
        T_REDIR_ERR,    // 2>
        T_APPEND_ERR,   // 2>>
        T_REDIR_ALL,    // &>
        T_APPEND_ALL,   // &>>
        T_FORCE_OUT,    // >|
        T_HEREDOC_STR,  // <<< (Bash-specific)
        T_DUP_IN,       // <&
        T_DUP_OUT,      // >&
        T_LPAREN,       // (
        T_RPAREN,       // )
        T_LBRACE,       // {
        T_RBRACE,       // }
        T_EQUAL,        // =
        T_UNKNOWN
}       t_token_type;

typedef enum e_quote
{
        NO_QUOTE,
        SINGLE_QUOTE,
        DOUBLE_QUOTE
}       t_quote;

typedef struct s_token
{
        char            *value;     /* texto literal (incluye comillas si las hay) */
        t_token_type    type;
        t_quote         quoted;     /* comillado delimitador del token (si aplica) */
        struct s_token  *next;
}       t_token;

/* ------------------------- API del lexer ------------------------- */
t_token         *lexer(const char *line);

/* Construcción/gestión de lista */
t_token         *token_new(char *value, t_token_type type, t_quote quote);
void            token_addback(t_token **lst, t_token *new);
void            free_token_list(t_token *tok);
void            next_token(t_token **cur);

/* Funciones de extracción */
int             get_operator(const char *line, int i, t_token **lst);
int             get_word(const char *line, int i, t_token **lst);

/* Detección y utilidades */
int             is_operator(const char *str, t_token_type *type, int *len);
t_token_type    get_token_type(const char *str, int len);
t_token_type    get_pipe_and_or(const char *str, int len);
t_token_type    get_semi_redir_left(const char *str, int len);
t_token_type    get_redir_right(const char *str, int len);
t_token_type    get_redir_special(const char *str, int len);

void            free_lexer_list_on_error(t_token **lst);
int             try_add_token(t_token **lst, char *str, t_token_type type, t_quote quote);

/* Utilidades específicas de bash */
void            strip_comment_if_applicable(char *line);
char            *remove_backslashes_for_token(const char *src, t_quote quote);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 13:10:22 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 03:11:47 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

#include <stdio.h>
#include <stdbool.h>
#include <fcntl.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <termios.h>
#include <errno.h>
#include <linux/limits.h>
#include <limits.h>
#include "libft.h"
#include "env.h"
#include "lexer.h"
#include "parser.h"
#include "ast.h"
#include "exec.h"
#include "builtins.h"
#include "signals.h"

typedef struct s_ast t_ast;
typedef struct s_shell t_shell;
typedef struct s_token t_token;

typedef struct s_env
{
    char            *key;
    char            *value;
    struct s_env    *next;
	int             exported;
}                   t_env;

typedef struct s_shell
{
        t_env           *env;
        char            *line;
        t_token         *tokens;
        t_ast           *ast;
        int             exit_status;
		int				in_child;  // 0 por defecto; en hijos se pone a 1 antes de ejecutar AST
        int             is_interactive;
        int             is_script;
        int             is_one_command;
        int             should_exit;
        char            *program_name;
        int             pid; // PID del shell actual (¡Correcto! Usado para $$, $BASHPID)
}       t_shell;

extern volatile sig_atomic_t   g_signal;
// Shell modes and flags
int		run_shell_modes(int argc, char **argv, char **envp, t_shell *shell);

// Inicialización y limpieza del shell
int		init_shell_name(t_shell *shell, char **argv);
int		init_env(t_shell *shell, char **envp);
void    cleanup_shell(t_shell *shell);
void    cleanup_loop(t_shell *shell);
int		print_exec_error(t_shell *shell, const char *cmd, int err_code);

// Funciones de ayuda/uso/version
void	print_help(void);
void	print_usage(const char *invalid);
void	print_version(void);
int		handle_help_version(int argc, char **argv);

// Ejecución principal del shell
void	prueba_lexer(t_shell *shell);
void	prueba_env(t_shell *shell);
void	prueba_expansion(t_shell *shell);
void	prueba_ast(t_shell *shell);
void	print_ast_debug(t_ast *node, int level);

int		shell_exec(t_shell *shell);
//void	parse_and_execute(t_shell *shell);
//int		check_syntax(t_ast *ast);

// --- Modos ---
int   run_shell_modes(int argc, char **argv, char **envp, t_shell *shell);
void  run_interactive(t_shell *shell);
void  run_non_interactive(t_shell *shell);   // NUEVO

// --- Lectura de línea ---
char *read_line_interactive(t_shell *shell); // RENOMBRE de read_full_line
// en no-interactivo leeremos con get_next_line o similar (o readline sin prompt)

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 19:07:19 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 15:27:05 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSER_H
# define PARSER_H

/* Evitamos ciclos: no necesitamos lexer.h aquí si solo usamos punteros. */
typedef struct s_token t_token;   /* <- forward declaration */
typedef struct s_ast   t_ast;
typedef struct s_shell t_shell;

# include "minishell.h"
# include "ast.h"
# include "env.h"

/* Prototipos relacionados con redirecciones y parsing */
int     is_redirection(t_token *tok);
int     parse_redirections(t_token **cur, t_ast **head, t_ast **tail);
t_ast   *make_redir_node(t_token *redir_token, t_token *filename_token);
t_ast   *parse_sequence(t_token **cur);
t_ast   *parse_and_or(t_token **cur);
t_ast   *parser_line(t_shell *shell);
t_ast   *parse_pipeline(t_token **cur);
t_ast   *parse_background(t_token **cur);
t_ast   *parse_command_and_redirections(t_token **cur);
t_ast   *parse_subshell(t_token **cur);
char    **parse_arguments(t_token **cur);

/* Comandos simples / subshells */
t_ast   *parse_simple_command(t_token **cur);
t_ast   *parse_subshell(t_token **cur);
char    **parse_arguments(t_token **cur);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 08:56:24 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 12:07:10 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SIGNALS_H
# define SIGNALS_H

# include "minishell.h"

/* ÚNICA variable global permitida del proyecto */
extern volatile sig_atomic_t g_signal;

/* Prompt (interactivo): ^C aborta la línea, ^\ se ignora. */
void    setup_prompt_signals(void);

/* En el PADRE mientras se ejecutan comandos: ignorar INT/QUIT. */
void    setup_exec_parent_signals(void);

/* Para modo no-interactivo o para restaurar defaults explícitamente. */
void    setup_default_signals(void);

/* Alias de compatibilidad: inicializa señales de prompt. */
void    setup_signals(void);

/* Handlers del prompt */
void    handle_sigint(int sig);
void    handle_sigquit(int sig);

/* TTY: controlar si el terminal muestra ^C / ^\ (ECHOCTL). */
void    set_echoctl(int enable);

/* Compat: usados en tu código existente (simple envoltorio de set_echoctl) */
void    disable_vquit(void);   /* oculta ^C/^\\ en el prompt si quisieras */
void    restore_vquit(void);   /* vuelve a mostrar ^C/^\\ */

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 19:53:28 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/28 03:50:45 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

	#include "minishell.h"
	#include "ast.h"

	t_ast *ast_new_command(char **argv, t_ast *redirections)
	{
		t_ast *node = malloc(sizeof(t_ast));
		if (!node)
			return NULL;
		node->type = N_COMMAND;
		node->cmd.argv = argv;
		node->cmd.redirections = redirections;
		return (node);
	}

	t_ast *ast_new_redir(char *filename, char *delimiter,
						t_redir_type type, int redir_fd)
	{
		t_ast *node = malloc(sizeof(t_ast));
		if (!node)
			return NULL;
		node->type = N_REDIR;
		node->redir.filename = filename;
		node->redir.delimiter = delimiter;
		node->redir.redir_type = type;
		node->redir.redir_fd = redir_fd;
		return (node);
	}

	t_ast *ast_new_binary(t_node_type type, t_ast *left, t_ast *right)
	{
		t_ast *node = malloc(sizeof(t_ast));
		if (!node)
			return NULL;
		node->type = type;
		node->bin.left = left;
		node->bin.right = right;
		return (node);
	}

	t_ast *ast_new_subshell(t_ast *child, t_ast *redirections)
	{
		t_ast *node = malloc(sizeof(t_ast));
		if (!node)
			return NULL;
		node->type = N_SUBSHELL;
		node->subshell.child = child;
		node->subshell.redirections = redirections;
		return (node);
	}

	t_ast	*create_command_node(char **argv, t_ast *redir_list_head)
	{
		t_ast	*cmd;

		cmd = ast_new_command(argv, redir_list_head);
		if (!cmd)
			return (NULL);
		return (cmd);
	}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   build_ast.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 18:36:06 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/03 10:42:33 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"

/*
** Función principal del parser: construye el AST a partir de la lista de tokens.
** Devuelve la raíz del AST o NULL en caso de error.
*/
t_ast   *build_ast(t_token *tokens)
{
    t_token *cur;
    t_ast   *tree;

    cur = tokens;
    tree = parse_background(&cur); // Llama a la función de más alta precedencia
    if (!tree)
        return (NULL);
    
    // Si quedan tokens sin procesar, es un error de sintaxis que las funciones de abajo
    // no capturaron porque no formaban parte de ninguna regla sintáctica esperada.
    // Esto es muy importante para detectar cosas como "ls && ;" o "echo hello world extra_stuff"
    // donde "extra_stuff" no es parte de la sintaxis válida después de un comando simple.
    if (cur != NULL) // <-- Esta condición es correcta para detectar tokens no consumidos
    {
        ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n", cur->value);
        free_ast(tree);
        return (NULL);
    }
    return (tree);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_ast.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/28 02:30:28 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/28 03:56:18 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "ast.h"
#include "parser.h"
#include "lexer.h"

// Libera solo un nodo, sin liberar hijos ni cadenas externas
void free_ast(t_ast *node)
{
    if (!node)
        return;

    if (node->type == N_COMMAND)
    {
        if (node->cmd.argv)
            ft_free_strtab(node->cmd.argv); // función para liberar char** argv
        // redirections NO se liberan aquí, porque pueden ser compartidas o liberadas en free_ast_recursive
    }
    else if (node->type == N_REDIR)
    {
        if (node->redir.filename)
            free(node->redir.filename);
        if (node->redir.delimiter)
            free(node->redir.delimiter);
    }
    // No libera punteros a hijos (bin, subshell), solo el nodo actual
    free(node);
}

// Libera el árbol entero recursivamente (incluye hijos y redirecciones)
void free_ast_recursive(t_ast *node)
{
    if (!node)
        return;
    if (node->type == N_COMMAND)
    {
        free_ast_recursive(node->cmd.redirections);
        if (node->cmd.argv)
            ft_free_strtab(node->cmd.argv);
    }
    else if (node->type == N_REDIR)
    {
        if (node->redir.filename)
            free(node->redir.filename);
        if (node->redir.delimiter)
            free(node->redir.delimiter);
    }
    else if (node->type == N_SUBSHELL)
    {
        free_ast_recursive(node->subshell.child);
        free_ast_recursive(node->subshell.redirections);
    }
    else // para nodos binarios (PIPE, SEQUENCE, AND, OR, BACKGROUND)
    {
        free_ast_recursive(node->bin.left);
        free_ast_recursive(node->bin.right);
    }
    free(node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_builtin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:25:12 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:25:37 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"
#include "env.h"

// ----------- CD -----------
int	run_cd(char **argv, t_shell *shell)
{
	const char	*path;
	char		*home;

	path = argv[1];
	if (!path)
	{
		home = get_env_value(shell, "HOME");
		if (!home)
		{
			ft_putstr_fd("minishell: cd: HOME not set\n", 2);
			return (1);
		}
		path = home;
	}
	if (chdir(path) == -1)
	{
		ft_putstr_fd("minishell: cd: ", 2);
		ft_putstr_fd((char *)path, 2);
		ft_putstr_fd(": No such file or directory\n", 2);
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo_builtin.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:22:50 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 18:32:53 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"

static int  is_all_n(const char *s)
{
    int i;

    if (!s || s[0] != '-')
        return 0;
    i = 1;
    if (s[i] == '\0')
        return 0;              // solo "-" no cuenta
    while (s[i])
    {
        if (s[i] != 'n')
            return 0;
        i++;
    }
    return 1;                  // "-n", "-nn", "-nnn", ...
}

int run_echo(char **argv)
{
    int i;
    int no_newline;
    int first_arg_printed;

    i = 1;
    no_newline = 0;
    while (argv[i] && is_all_n(argv[i]))
    {
        no_newline = 1;
        i++;
    }

    first_arg_printed = 0;
    while (argv[i])
    {
        if (first_arg_printed)
            write(1, " ", 1);
        write(1, argv[i], ft_strlen(argv[i]));
        first_arg_printed = 1;
        i++;
    }

    if (!no_newline)
        write(1, "\n", 1);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_builtin.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:26:03 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:26:22 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"
#include "env.h"

// ----------- ENV -----------
int	run_env(t_shell *shell)
{
	t_env	*env;

	env = shell->env;
	while (env)
	{
		if (env->exported && env->value)
		{
			ft_putstr_fd(env->key, 1);
			ft_putchar_fd('=', 1);
			ft_putendl_fd(env->value, 1);
		}
		env = env->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_builtin.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:28:12 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:31:54 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"

// ----------- EXIT -----------

int	run_exit(char **argv, t_shell *shell)
{
	long	code;

	ft_putstr_fd("exit\n", 1);
	if (!argv[1])
		exit(shell->exit_status);
	if (!ft_isnumeric(argv[1]))
	{
		ft_dprintf(2, "minishell: exit: %s: numeric argument required\n", argv[1]);
		exit(255);
	}
	if (argv[2])
	{
		ft_dprintf(2, "minishell: exit: too many arguments\n");
		shell->exit_status = 1;
		return (1);
	}
	code = ft_atol(argv[1]);
	code = code & 255;
	exit((int)code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_builtin.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:26:37 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:27:03 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"
#include "env.h"

// ----------- EXPORT -----------
static int	valid_export_key(const char *key)
{
	int	i;

	i = 0;
	if (!key || !ft_isalpha(key[0]))
		return (0);
	while (key[i])
	{
		if (!ft_isalnum(key[i]) && key[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

int	run_export(char **argv, t_shell *shell)
{
	int		i;
	char	*sep;
	char	*key;
	char	*value;
	t_env	*envv;

	i = 1;
	while (argv[i])
	{
		sep = ft_strchr(argv[i], '=');
		if (sep)
		{
			key = ft_substr(argv[i], 0, sep - argv[i]);
			value = ft_strdup(sep + 1);
			if (valid_export_key(key))
			{
				envv = shell->env;
				while (envv)
				{
					if (ft_strcmp(envv->key, key) == 0)
					{
						free(envv->value);
						envv->value = ft_strdup(value);
						envv->exported = 1;
						break ;
					}
					envv = envv->next;
				}
				if (!envv)
					env_add_back(&shell->env, env_create(key, value, 1));
			}
			else
				ft_dprintf(2, "minishell: export: `%s': not a valid identifier\n", key);
			free(key);
			free(value);
		}
		else if (valid_export_key(argv[i]))
		{
			envv = shell->env;
			while (envv)
			{
				if (ft_strcmp(envv->key, argv[i]) == 0)
				{
					envv->exported = 1;
					break ;
				}
				envv = envv->next;
			}
			if (!envv)
				env_add_back(&shell->env, env_create(argv[i], "", 1));
		}
		else
			ft_dprintf(2, "minishell: export: `%s': not a valid identifier\n", argv[i]);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_builtin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:38:44 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 15:51:53 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

int	is_builtin(const char *cmd)
{
	if (!cmd)
		return (0);
	if (ft_strcmp(cmd, "echo") == 0
		|| ft_strcmp(cmd, "cd") == 0
		|| ft_strcmp(cmd, "pwd") == 0
		|| ft_strcmp(cmd, "export") == 0
		|| ft_strcmp(cmd, "unset") == 0
		|| ft_strcmp(cmd, "env") == 0
		|| ft_strcmp(cmd, "exit") == 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd_builtin.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:24:17 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:30:00 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"

// ----------- PWD -----------
int	run_pwd(void)
{
	char	buf[PATH_MAX];

	if (getcwd(buf, PATH_MAX))
	{
		ft_putendl_fd(buf, 1);
		return (0);
	}
	ft_putstr_fd("minishell: pwd: error retrieving current directory\n", 2);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_builtin.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:44:03 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:35:45 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "ast.h"
#include "exec.h"
#include "builtins.h"

int run_builtin(t_ast *node, t_shell *shell)
{
	char **argv;

	if (!node || !node->cmd.argv || !node->cmd.argv[0])
		return (1);
	argv = node->cmd.argv;
	if (ft_strcmp(argv[0], "echo") == 0)
		return (run_echo(argv));
	if (ft_strcmp(argv[0], "cd") == 0)
		return (run_cd(argv, shell));
	if (ft_strcmp(argv[0], "pwd") == 0)
		return (run_pwd());
	if (ft_strcmp(argv[0], "export") == 0)
		return (run_export(argv, shell));
	if (ft_strcmp(argv[0], "unset") == 0)
		return (run_unset(argv, shell));
	if (ft_strcmp(argv[0], "env") == 0)
		return (run_env(shell));
	if (ft_strcmp(argv[0], "exit") == 0)
		return (run_exit(argv, shell));
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset_builtin.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/04 12:27:13 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/04 12:27:44 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "builtins.h"

// ----------- UNSET -----------
int	run_unset(char **argv, t_shell *shell)
{
	int		i;
	t_env	*prev;
	t_env	*cur;

	i = 1;
	while (argv[i])
	{
		prev = NULL;
		cur = shell->env;
		while (cur)
		{
			if (ft_strcmp(cur->key, argv[i]) == 0)
			{
				if (prev)
					prev->next = cur->next;
				else
					shell->env = cur->next;
				free(cur->key);
				free(cur->value);
				free(cur);
				break ;
			}
			prev = cur;
			cur = cur->next;
		}
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_get_value.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:53:52 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:58:09 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"

char	*get_env_value(t_shell *shell, const char *key)
{
	t_env	*env;

	if (!shell || !key)
		return (NULL);
	env = shell->env;
	while (env)
	{
		if (env->key && !ft_strcmp(env->key, key))
			return (env->value);
		env = env->next;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_env_list.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 15:32:52 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/27 19:51:04 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"

/*
** free_env_list
** Libera toda la memoria de la lista enlazada de variables de entorno (t_env).
** - Recorre la lista nodo por nodo, liberando 'key', 'value' y el propio nodo.
** - Al finalizar, todos los elementos de la lista quedan correctamente liberados.
**
** Parámetros:
**   env: puntero al inicio de la lista enlazada de entorno (t_env*)
**
** Uso:
**   Llama a esta función al salir de la shell o cuando debas liberar todo el entorno.
*/
void	free_env_list(t_env *env)
{
	t_env	*tmp;

	while (env)
	{
		tmp = env->next;
		if (env->key)
			free(env->key);
		if (env->value)
			free(env->value);
		free(env);
		env = tmp;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_env_array.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:35:01 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 15:55:08 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"

static int	env_count(t_env *env)
{
	int	count;

	count = 0;
	while (env)
	{
		if (env->exported)
			count++;
		env = env->next;
	}
	return (count);
}

static char	*join_key_value(const char *key, const char *value)
{
	char	*tmp;
	char	*res;

	tmp = ft_strjoin(key, "=");
	if (!tmp)
		return (NULL);
	res = ft_strjoin(tmp, value);
	free(tmp);
	return (res);
}

char	**env_to_array(t_env *env)
{
	char	**env_array;
	int		size;
	int		i;

	size = env_count(env);
	env_array = (char **)ft_calloc(size + 1, sizeof(char *));
	if (!env_array)
		return (NULL);
	i = 0;
	while (env && i < size)
	{
		if (env->exported)
		{
			env_array[i] = join_key_value(env->key, env->value);
			if (!env_array[i])
			{
				ft_free_strtab(env_array);
				return (NULL);
			}
			i++;
		}
		env = env->next;
	}
	env_array[i] = NULL;
	return (env_array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_env_list.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/27 14:42:10 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/27 20:01:59 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_env_list.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 15:28:27 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/26 06:18:34 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"

/*
** Crea un nuevo nodo de variable de entorno (t_env).
** - key: nombre de la variable (ej: "USER")
** - value: valor de la variable (ej: "acoronadx")
** - exported: 1 si la variable está exportada, 0 si es local/interna
** Devuelve un puntero al nuevo nodo, o NULL si falla el malloc.
** El campo .next se inicializa a NULL.
*/
t_env	*env_create(char *key, char *value, int exported)
{
	t_env	*new;

	new = (t_env *)malloc(sizeof(t_env));
	if (!new)
		return (NULL);
	new->key = ft_strdup(key);
	if (value)
		new->value = ft_strdup(value);
	else
		new->value = NULL;
	new->exported = exported;
	new->next = NULL;
	return (new);
}

/*
** Añade un nodo t_env al final de la lista de entorno.
** - *env: puntero al inicio de la lista (puede ser NULL si está vacía)
** - new: nuevo nodo a añadir
** Si la lista está vacía, pone el nuevo como primer elemento.
** Si no, recorre la lista y lo añade al final.
** No hace nada si alguno de los punteros es NULL.
*/

void	env_add_back(t_env **env, t_env *new)
{
	t_env	*tmp;

	if (!env || !new)
		return ;
	if (!*env)
		*env = new;
	else
	{
		tmp = *env;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new;
	}
}

/*
** Inicializa la lista enlazada de entorno (t_env) a partir del array envp.
** - envp: array de strings "KEY=VALUE" que viene de main().
** Por cada string, separa la clave y el valor, crea un nodo y lo añade a la lista.
** Marca todas las variables como exportadas (exported = 1).
** Devuelve el inicio de la lista, o NULL si falla algún malloc.
** Ejemplo de uso: shell->env = init_env_list(envp);
*/
static t_env	*create_exported_env_var(char *str, t_env **env)
{
	char	*sep;
	char	*key;
	t_env	*new;

	sep = ft_strchr(str, '=');
	key = ft_substr(str, 0, sep - str);
	if (!key)
	{
		free_env_list(*env);
		return (NULL);
	}
	new = env_create(key, sep + 1, 1);
	free(key);
	if (!new)
	{
		free_env_list(*env);
		return (NULL);
	}
	env_add_back(env, new);
	return (*env);
}

t_env	*init_env_list(char **envp)
{
	t_env	*env;
	int		i;

	env = NULL;
	i = 0;
	while (envp[i])
	{
		if (ft_strchr(envp[i], '='))
		{
			if (!create_exported_env_var(envp[i], &env))
				return (NULL);
		}
		i++;
	}
	return (env);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_and_or.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:49:04 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_and(t_ast *node, t_shell *shell)
{
    int ret;

    ret = execute_ast(node->bin.left, shell);
    if (ret == 0)
        ret = execute_ast(node->bin.right, shell);
    else
        shell->exit_status = ret;
    return (ret);
}

int execute_or(t_ast *node, t_shell *shell)
{
    int ret;

    ret = execute_ast(node->bin.left, shell);
    if (ret != 0)
        ret = execute_ast(node->bin.right, shell);
    else
        shell->exit_status = ret;
    return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_ast.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:48:43 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_ast(t_ast *node, t_shell *shell)
{
    int ret;

    if (!node)
        return (0);
    if (node->type == N_COMMAND)
        ret = execute_command(node, shell);
    else if (node->type == N_PIPE)
        ret = execute_pipe(node, shell);
    else if (node->type == N_AND)
        ret = execute_and(node, shell);
    else if (node->type == N_OR)
        ret = execute_or(node, shell);
    else if (node->type == N_SUBSHELL)
        ret = execute_subshell(node, shell);
    else if (node->type == N_SEQUENCE)
        ret = execute_sequence(node, shell);
    else if (node->type == N_BACKGROUND)
        ret = execute_background(node, shell);
    else if (node->type == N_REDIR)
    {
        ft_dprintf(2, "minishell: syntax error near unexpected token `newline'\n");
        shell->exit_status = 2;
        ret = 1;
    }
    else
    {
        ft_dprintf(2, "minishell: command not found\n");
        shell->exit_status = 127;
        ret = 127;
    }
    return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_background.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:49:41 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_background(t_ast *node, t_shell *shell)
{
    pid_t pid;

    pid = fork();
    if (pid < 0)
    {
        ft_dprintf(2, "minishell: fork error\n");
        shell->exit_status = 1;
        return (1);
    }
    if (pid == 0)
    {
        /* Hijo: señales por defecto para comportamiento bash-like */
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        _exit(execute_ast(node->bin.left, shell) & 0xFF);
    }
    /* Padre: no espera al hijo en background */
    shell->exit_status = 0;
    ft_dprintf(1, "[1] %d\n", pid);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:03 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void restore_std_fds(int saved_in, int saved_out, int saved_err)
{
    if (saved_in  != -1) { dup2(saved_in,  STDIN_FILENO);  close(saved_in);  }
    if (saved_out != -1) { dup2(saved_out, STDOUT_FILENO); close(saved_out); }
    if (saved_err != -1) { dup2(saved_err, STDERR_FILENO); close(saved_err); }
}

int execute_command(t_ast *node, t_shell *shell)
{
    pid_t   pid;
    char    **env;
    char    *exec_path;
    int     status;

    if (!node || !node->cmd.argv || !node->cmd.argv[0])
        return (0);

    if (node->cmd.argv[0][0] == '\0')
    {
        ft_dprintf(2, "minishell: : command not found\n");
        shell->exit_status = 127;
        return (127);
    }

    /* -------- BUILTIN en el PADRE (con redirecciones) -------- */
    if (is_builtin(node->cmd.argv[0]))
    {
        int saved_in  = dup(STDIN_FILENO);
        int saved_out = dup(STDOUT_FILENO);
        int saved_err = dup(STDERR_FILENO);

        if (saved_in == -1 || saved_out == -1 || saved_err == -1)
        {
            perror("minishell: dup");
            if (saved_in  != -1) close(saved_in);
            if (saved_out != -1) close(saved_out);
            if (saved_err != -1) close(saved_err);
            shell->exit_status = 1;
            return (1);
        }
        if (apply_redirections(node->cmd.redirections) != 0)
        {
            restore_std_fds(saved_in, saved_out, saved_err);
            shell->exit_status = 1;
            return (1);
        }
        shell->exit_status = run_builtin(node, shell);
        restore_std_fds(saved_in, saved_out, saved_err);
        return (shell->exit_status);
    }

    /* -------- EXTERNOS -------- */
    exec_path = find_executable(node->cmd.argv[0], shell);
    if (!exec_path)
        return (print_exec_error(shell, node->cmd.argv[0], errno));

    env = env_to_array(shell->env);
    if (!env)
    {
        free(exec_path);
        shell->exit_status = 1;
        return (1);
    }

    pid = fork();
    if (pid < 0)
    {
        int ret = print_exec_error(shell, node->cmd.argv[0], errno);
        free(exec_path);
        ft_free_strtab(env);
        return (ret);
    }
    if (pid == 0)
    {
        /* --- HIJO --- */
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);

        if (apply_redirections(node->cmd.redirections) != 0)
            _exit(1);

        execve(exec_path, node->cmd.argv, env);
        print_exec_error(shell, node->cmd.argv[0], errno);
        _exit(127);
    }

    /* --- PADRE --- */
    if (waitpid(pid, &status, 0) == -1)
        shell->exit_status = 1;
    else if (WIFEXITED(status))
        shell->exit_status = WEXITSTATUS(status);
    else if (WIFSIGNALED(status))
    {
        int sig = WTERMSIG(status);
        shell->exit_status = 128 + sig;
        if (sig == SIGINT)
            write(STDOUT_FILENO, "\n", 1);
        else if (sig == SIGQUIT)
            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
    }
    else
        shell->exit_status = 1;

    free(exec_path);
    ft_free_strtab(env);
    return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_heredocs.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 18:01:40 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"

/*
** Heredoc: lee hasta 'delimiter', escribe en un pipe y devuelve fd de lectura.
** Se usa en tiempo de ejecución de la redirección.
*/
int	heredoc_prepare(const char *delimiter)
{
	int		pipefd[2];
	char	*line;
	size_t	dlen;

	if (!delimiter) return (-1);
	dlen = ft_strlen(delimiter);
	if (pipe(pipefd) == -1)
		return (-1);

	/* Mientras se lee el heredoc, ^C aborta lectura; ^\ se ignora */
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_DFL);

	while (1)
	{
		line = readline("> ");
		if (!line)
			break;
		if (ft_strncmp(line, delimiter, dlen) == 0 && line[dlen] == '\0')
		{
			free(line);
			break;
		}
		write(pipefd[1], line, ft_strlen(line));
		write(pipefd[1], "\n", 1);
		free(line);
	}
	close(pipefd[1]);

	/* Restauramos defaults típicos del hijo al salir del heredoc */
	signal(SIGQUIT, SIG_DFL);
	signal(SIGINT, SIG_DFL);
	return (pipefd[0]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:18 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_pipe(t_ast *node, t_shell *shell)
{
    int     pipefd[2];
    pid_t   pid_l, pid_r;
    int     st_l = 0, st_r = 0;

    if (pipe(pipefd) == -1)
    {
        ft_dprintf(2, "minishell: pipe error\n");
        shell->exit_status = 1;
        return (1);
    }

    pid_l = fork();
    if (pid_l == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        close(pipefd[0]);
        if (dup2(pipefd[1], STDOUT_FILENO) < 0)
            _exit(1);
        close(pipefd[1]);
        _exit(execute_ast(node->bin.left, shell) & 0xFF);
    }

    pid_r = fork();
    if (pid_r == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        close(pipefd[1]);
        if (dup2(pipefd[0], STDIN_FILENO) < 0)
            _exit(1);
        close(pipefd[0]);
        _exit(execute_ast(node->bin.right, shell) & 0xFF);
    }

    close(pipefd[0]);
    close(pipefd[1]);

    if (waitpid(pid_l, &st_l, 0) < 0)
        st_l = 0;
    if (waitpid(pid_r, &st_r, 0) < 0)
        st_r = 0;

    if (WIFEXITED(st_r))
        shell->exit_status = WEXITSTATUS(st_r);
    else if (WIFSIGNALED(st_r))
    {
        int sig = WTERMSIG(st_r);
        if (sig == SIGINT)
            write(STDOUT_FILENO, "\n", 1);
        else if (sig == SIGQUIT)
            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
        shell->exit_status = 128 + sig;
    }
    else
        shell->exit_status = 1;

    return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 15:12:04 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 18:01:30 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"

static int	redirect_to(int fd, int std_fd)
{
	int	ret = 0;
	if (dup2(fd, std_fd) < 0)
	{
		perror("minishell: dup2");
		close(fd);
		ret = 1;
	}
	close(fd);
	return (ret);
}

static int	handle_heredoc(t_ast *redir)
{
	int	fd = heredoc_prepare(redir->redir.delimiter);
	if (fd < 0)
		return (1);
	return (redirect_to(fd, STDIN_FILENO));
}

int	open_redirection(t_ast *redir)
{
	int	fd = -1;

	if (!redir || redir->type != N_REDIR) return (-1);
	if (redir->redir.redir_type == REDIR_IN)
		fd = open(redir->redir.filename, O_RDONLY);
	else if (redir->redir.redir_type == REDIR_OUT
		|| redir->redir.redir_type == REDIR_FORCE)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redir.redir_type == REDIR_ERR)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND_ERR)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redir.redir_type == REDIR_ALL)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redir.redir_type == REDIR_APPEND_ALL)
		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	return (fd);
}

static int	handle_dup_redir(t_ast *redir)
{
	int	target = redir->redir.redir_fd;
	int	std_fd = (redir->redir.redir_type == REDIR_DUP_OUT) ? STDOUT_FILENO : STDIN_FILENO;

	if (target == std_fd) return (0);
	if (dup2(target, std_fd) < 0)
	{
		perror("minishell: dup2");
		return (1);
	}
	return (0);
}

int	handle_simple_redir(t_ast *redir)
{
	int	fd = open_redirection(redir);
	int	ret = 0;

	if (fd < 0)
	{
		perror(redir->redir.filename);
		return (1);
	}
	if (redir->redir.redir_type == REDIR_IN)
		ret = redirect_to(fd, STDIN_FILENO);
	else if (redir->redir.redir_type == REDIR_OUT
		|| redir->redir.redir_type == REDIR_FORCE
		|| redir->redir.redir_type == REDIR_APPEND)
		ret = redirect_to(fd, STDOUT_FILENO);
	else if (redir->redir.redir_type == REDIR_ERR
		|| redir->redir.redir_type == REDIR_APPEND_ERR)
		ret = redirect_to(fd, STDERR_FILENO);
	else if (redir->redir.redir_type == REDIR_ALL
		|| redir->redir.redir_type == REDIR_APPEND_ALL)
	{
		if (dup2(fd, STDOUT_FILENO) < 0) ret = 1;
		else if (dup2(fd, STDERR_FILENO) < 0) ret = 1;
		close(fd);
	}
	return (ret);
}

int	apply_redirections(t_ast *redir_list)
{
	t_ast	*curr = redir_list;
	int		fail = 0;

	while (curr)
	{
		if (curr->type != N_REDIR)
			return (1);

		if (curr->redir.redir_type == REDIR_HEREDOC)
		{
			if (handle_heredoc(curr))
				fail = 1;
		}
		else if (curr->redir.redir_type == REDIR_DUP_IN
			|| curr->redir.redir_type == REDIR_DUP_OUT)
		{
			if (handle_dup_redir(curr))
				fail = 1;
		}
		else
		{
			if (handle_simple_redir(curr))
				fail = 1;
		}
		curr = curr->bin.right;
	}
	return (fail ? 1 : 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_sequence.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "exec.h"
#include "ast.h"

int execute_sequence(t_ast *node, t_shell *shell)
{
	execute_ast(node->bin.left, shell);
	return (execute_ast(node->bin.right, shell));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_subshell.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:32 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int execute_subshell(t_ast *node, t_shell *shell)
{
    pid_t pid;
    int   st = 0;

    pid = fork();
    if (pid < 0)
    {
        ft_dprintf(2, "minishell: fork error\n");
        shell->exit_status = 1;
        return (1);
    }
    if (pid == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        _exit(execute_ast(node->subshell.child, shell) & 0xFF);
    }
    if (waitpid(pid, &st, 0) < 0)
        shell->exit_status = 1;
    else if (WIFEXITED(st))
        shell->exit_status = WEXITSTATUS(st);
    else if (WIFSIGNALED(st))
    {
        int sig = WTERMSIG(st);
        if (sig == SIGINT)
            write(STDOUT_FILENO, "\n", 1);
        else if (sig == SIGQUIT)
            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
        shell->exit_status = 128 + sig;
    }
    else
        shell->exit_status = 1;

    return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 15:27:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"
#include "exec.h"
#include "ast.h"
#include <errno.h>
#include <sys/stat.h>

int	is_executable(char *path)
{
	struct stat	st;

	if (stat(path, &st) != 0)
		return (0);
	if (S_ISDIR(st.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	return (access(path, X_OK) == 0);
}

char	*join_path(const char *dir, const char *file)
{
	char	*tmp;
	size_t	len_dir;
	size_t	len_file;
	size_t	i;

	len_dir = ft_strlen(dir);
	len_file = ft_strlen(file);
	tmp = malloc(len_dir + 1 + len_file + 1);
	if (!tmp)
		return (NULL);
	ft_memcpy(tmp, dir, len_dir);
	tmp[len_dir] = '/';
	i = 0;
	while (i < len_file)
	{
		tmp[len_dir + 1 + i] = file[i];
		i++;
	}
	tmp[len_dir + 1 + len_file] = '\0';
	return (tmp);
}

static int	has_slash(char *cmd)
{
	int	i;

	if (!cmd)
		return (0);
	i = 0;
	while (cmd[i])
	{
		if (cmd[i] == '/')
			return (1);
		i++;
	}
	return (0);
}

static char	*find_path_executable(char *cmd, char **paths)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path(paths[i], cmd);
		if (!full_path)
			return (NULL);
		if (is_executable(full_path))
			return (full_path); // No liberar, lo devolvemos
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*find_executable(char *cmd, t_shell *shell)
{
	char	**paths;
	char	*res;
	char	*path_value;

	if (!cmd)
		return (NULL);
	if (has_slash(cmd))
	{
		if (is_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_value = get_env_value(shell, "PATH");
	if (!path_value || path_value[0] == '\0')
		return (NULL);
	paths = ft_split(path_value, ':');
	if (!paths)
		return (NULL);
	res = find_path_executable(cmd, paths);
	ft_free_strtab(paths);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   calculate_expand_len.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/28 00:16:36 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:32:58 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"
#include "env.h"

size_t  handle_dollar_len(const char *str, int *i, t_shell *shell)
{
    char    *expanded;
    size_t  len;

    (*i)++; /* saltar '$' */
    expanded = expand_value(str, i, shell); /* avanza *i tras el nombre */
    if (!expanded)
        return (size_t)-1;
    len = ft_strlen(expanded);
    free(expanded);
    return len;
}

size_t  calculate_expanded_len(const char *str, t_shell *shell)
{
    size_t  total = 0;
    int     i = 0;
    t_quote q = NO_QUOTE;

    while (str[i])
    {
        if (str[i] == '\'')
        {
            if (q == NO_QUOTE) q = SINGLE_QUOTE;
            else if (q == SINGLE_QUOTE) q = NO_QUOTE;
            total += 1; i++; continue;
        }
        if (str[i] == '"')
        {
            if (q == NO_QUOTE) q = DOUBLE_QUOTE;
            else if (q == DOUBLE_QUOTE) q = NO_QUOTE;
            total += 1; i++; continue;
        }

        if (str[i] == '\\')
        {
            if (q == SINGLE_QUOTE) { total += 1; i += 1; continue; }
            if (q == DOUBLE_QUOTE)
            {
                if (str[i+1] == '\n') { i += 2; continue; }
                if (str[i+1]) { total += 2; i += 2; continue; } /* '\'+char */
                total += 1; i += 1; continue; /* '\' final */
            }
            /* NO_QUOTE */
            if (str[i+1] == '\n') { i += 2; continue; }
            if (str[i+1] == '$') { total += 1; i += 2; continue; } /* \$ -> '$' */
            total += 1; i += 1; continue; /* preservamos '\' */
        }

        if (q != SINGLE_QUOTE && str[i] == '$')
        {
            size_t add = handle_dollar_len(str, &i, shell);
            if (add == (size_t)-1) return (size_t)-1;
            total += add;
            continue;
        }

        if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i-1]) || str[i-1] == '='))
        {
            char *t = expand_tilde_internal(str + i, shell);
            if (!t) return (size_t)-1;
            total += ft_strlen(t);
            i += get_tilde_prefix_len(str + i);
            free(t);
            continue;
        }

        total += 1; i++;
    }
    return total;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 02:45:20 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:34:38 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"
#include "env.h"

char *expand_token(const char *str, t_shell *shell)
{
    if (!str) return NULL;

    /* Pre-calcular tamaño para evitar overflows (p.ej. $PATH muy largo) */
    size_t need = calculate_expanded_len(str, shell);
    if (need == (size_t)-1)
        return NULL;

    char *res = (char *)malloc(need + 1);
    if (!res) return NULL;

    int i = 0, j = 0;
    t_quote q = NO_QUOTE;

    while (str[i])
    {
        if (str[i] == '\'')
        {
            if (q == NO_QUOTE) q = SINGLE_QUOTE;
            else if (q == SINGLE_QUOTE) q = NO_QUOTE;
            res[j++] = str[i++];                 /* se quitará en remove_quotes */
            continue;
        }
        if (str[i] == '"')
        {
            if (q == NO_QUOTE) q = DOUBLE_QUOTE;
            else if (q == DOUBLE_QUOTE) q = NO_QUOTE;
            res[j++] = str[i++];
            continue;
        }

        if (str[i] == '\\')
        {
            if (q == SINGLE_QUOTE)
            {
                /* en '...' la barra es literal */
                res[j++] = '\\'; i++; continue;
            }
            if (q == DOUBLE_QUOTE)
            {
                if (str[i+1] == '\n') { i += 2; continue; } /* "\<nl>" desaparece */
                if (str[i+1])
                {
                    /* conservamos '\' + char; quote_removal decidirá si quitar '\' */
                    res[j++] = '\\';
                    res[j++] = str[i+1];
                    i += 2;
                    continue;
                }
                res[j++] = '\\'; i++; continue;            /* '\' final */
            }
            /* NO_QUOTE */
            if (str[i+1] == '\n') { i += 2; continue; }    /* continuación de línea */
            if (str[i+1] == '$') { i++; res[j++] = '$'; i++; continue; } /* \$ -> '$' literal */
            res[j++] = '\\'; i++; continue;                /* preservamos '\' */
        }

        if (q != SINGLE_QUOTE && str[i] == '$')
        {
            int added = handle_dollar(str, &i, res, j, shell); /* avanza i internamente */
            if (added < 0) { free(res); return NULL; }
            j += added;
            continue;
        }

        if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i-1]) || str[i-1] == '='))
        {
            char *t = expand_tilde_internal(str + i, shell);
            if (!t) { free(res); return NULL; }
            ft_strcpy(res + j, t);
            j += ft_strlen(t);
            i += get_tilde_prefix_len(str + i);
            free(t);
            continue;
        }

        res[j++] = str[i++];
    }
    res[j] = '\0';
    return res;
}

int expand_variables(t_shell *shell)
{
    t_token *t = shell->tokens;

    while (t)
    {
        char *expanded = expand_token(t->value, shell);
        if (!expanded)
            return -1;
        free(t->value);
        t->value = expanded;
        t = t->next;
    }
    /* Orden Bash: expansiones -> word splitting -> quote removal */
    perform_word_splitting(shell);
    remove_quotes(shell->tokens);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_dollar.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/28 00:15:35 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:33:11 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"
#include "env.h"

char *expand_value(const char *s, int *i, t_shell *shell)
{
    /* s[*i] es el carácter justo DESPUÉS del '$' */
    if (!s || !s[*i])
        return ft_strdup("");

    /* especiales */
    if (s[*i] == '?') { (*i)++; return ft_itoa(shell->exit_status); } /* $? */
    if (s[*i] == '$') { (*i)++; return ft_itoa(getpid()); }           /* $$ */
    if (s[*i] == '0') { (*i)++; return get_program_name_str(shell); } /* $0 */

    /* posicionales $1..$9 -> vacías si no existen */
    if (ft_isdigit((unsigned char)s[*i])) { (*i)++; return ft_strdup(""); }

    /* "$" seguido de comilla o fin -> "" (coincide con tus tests) */
    if (s[*i] == '"' || s[*i] == '\'' || s[*i] == '\0')
        return ft_strdup("");

    /* nombre de variable */
    if (ft_isalpha((unsigned char)s[*i]) || s[*i] == '_')
    {
        int start = *i;
        while (ft_isalnum((unsigned char)s[*i]) || s[*i] == '_') (*i)++;
        char *name = ft_substr(s, start, *i - start);
        if (!name) return NULL;
        char *val = find_var(shell->env, name);
        free(name);
        return ft_strdup(val ? val : "");
    }

    /* por defecto: trata el '$' como literal */
    (*i)++;
    return ft_strdup("$");
}

int handle_dollar(const char *s, int *i, char *dst, int j, t_shell *shell)
{
    char *expanded;
    int   len;

    (*i)++; /* saltar '$' en el input */
    expanded = expand_value(s, i, shell);
    if (!expanded) return -1;
    len = (int)ft_strlen(expanded);
    ft_memcpy(dst + j, expanded, len);
    free(expanded);
    return len;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_tilde.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 02:46:11 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:33:46 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"
#include "env.h"

char *expand_tilde_internal(const char *str, t_shell *shell)
{
    char *home;
    char *out;

    if (!str || *str != '~')
        return ft_strdup(str);

    if (ft_strlen(str) == 1 || str[1] == '/')
    {
        home = find_var(shell->env, "HOME");
        if (!home || *home == '\0')
            return ft_strdup(str);
        if (ft_strlen(str) == 1)
            return ft_strdup(home);
        out = ft_strjoin(home, str + 1); /* "~" + "/..." */
        return out;
    }
    /* ~user -> no implementado: copia tal cual */
    return ft_strdup(str);
}

size_t get_tilde_prefix_len(const char *str)
{
    if (!str || *str != '~') return 0;
    if (ft_strlen(str) == 1 || str[1] == '/') return 1 + (str[1] == '/');
    return 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/28 00:52:34 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:33:25 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"
#include "env.h"

char *find_var(t_env *env, char *name)
{
    while (env)
    {
        if (ft_strcmp(env->key, name) == 0)
            return (env->value ? env->value : "");
        env = env->next;
    }
    return "";
}

char *get_program_name_str(t_shell *shell)
{
    if (!shell->program_name)
        return ft_strdup("minishell");
    return ft_strdup(shell->program_name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_expand_cases.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/28 00:08:05 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:33:35 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"
#include "env.h"

size_t handle_exit_status_len(t_shell *shell)
{
    char   *s = ft_itoa(shell->exit_status);
    size_t  n;

    if (!s) return (size_t)-1;
    n = ft_strlen(s);
    free(s);
    return n;
}

size_t handle_pid_len(void)
{
    char   *s = ft_itoa(getpid());
    size_t  n;

    if (!s) return (size_t)-1;
    n = ft_strlen(s);
    free(s);
    return n;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quote_removal.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/21 13:49:35 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 14:33:59 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "expand.h"

static char *quote_remove_like_bash(const char *s)
{
    size_t n = ft_strlen(s);
    char  *out = (char *)malloc(n + 1);
    int    i = 0, j = 0;
    t_quote q = NO_QUOTE;

    if (!out) return NULL;

    while ( s[i] )
    {
        if (q == NO_QUOTE)
        {
            if (s[i] == '\\')
            {
                if (s[i+1] == '\n') { i += 2; continue; }
                if (s[i+1]) { i++; out[j++] = s[i++]; continue; }
                out[j++] = s[i++]; continue; /* '\' final literal */
            }
            if (s[i] == '\'') { q = SINGLE_QUOTE; i++; continue; }
            if (s[i] == '"')  { q = DOUBLE_QUOTE; i++; continue; }
            out[j++] = s[i++]; continue;
        }
        if (q == SINGLE_QUOTE)
        {
            if (s[i] == '\'') { q = NO_QUOTE; i++; continue; }
            out[j++] = s[i++]; continue;
        }
        /* q == DOUBLE_QUOTE */
        if (s[i] == '\\')
        {
            if (s[i+1] == '\n') { i += 2; continue; }
            if (s[i+1] && (s[i+1] == '$' || s[i+1] == '`' || s[i+1] == '"' || s[i+1] == '\\'))
            { i++; out[j++] = s[i++]; continue; }
            out[j++] = s[i++]; continue; /* '\' literal si no escapa especial */
        }
        if (s[i] == '"') { q = NO_QUOTE; i++; continue; }
        out[j++] = s[i++];
    }
    out[j] = '\0';
    return out;
}

void    remove_quotes(t_token *tokens)
{
    for (t_token *t = tokens; t; t = t->next)
    {
        char *clean = quote_remove_like_bash(t->value);
        if (!clean) return; /* Manejo básico de error */
        free(t->value);
        t->value = clean;
        t->quoted = NO_QUOTE;
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   word_splitting.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/21 15:11:12 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 18:00:49 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"   // try_add_token, t_token, types
#include "expand.h"  // t_quote

/* IFS por defecto: espacio, tab y newline */
static int is_ifs_space(unsigned char c)
{
    return (c == ' ' || c == '\t' || c == '\n');
}

/* Divide SOLO palabras (T_WORD) respetando comillas y backslashes */
static t_token *split_word_respecting_quotes(const char *s)
{
    t_token *head = NULL;
    size_t   n = ft_strlen(s);
    char    *buf = malloc(n + 1);
    size_t   i = 0, j;
    t_quote  q;

    if (!buf)
        return NULL;

    /* saltar IFS inicial (no escapado) */
    while (s[i] && is_ifs_space((unsigned char)s[i]))
        i++;

    while (s[i])
    {
        j = 0; q = NO_QUOTE;
        while (s[i])
        {
            char c = s[i];
            if (q == NO_QUOTE)
            {
                if (c == '\\')
                {
                    if (s[i+1] == '\n') { i += 2; continue; }
                    if (s[i+1]) { buf[j++] = '\\'; buf[j++] = s[i+1]; i += 2; continue; }
                    buf[j++] = '\\'; i++; continue;
                }
                if (c == '\'') { q = SINGLE_QUOTE; buf[j++] = c; i++; continue; }
                if (c == '"')  { q = DOUBLE_QUOTE; buf[j++] = c; i++; continue; }
                if (is_ifs_space((unsigned char)c)) break;
                buf[j++] = c; i++; continue;
            }
            else if (q == SINGLE_QUOTE)
            { buf[j++] = c; i++; if (c == '\'') q = NO_QUOTE; continue; }
            else /* DOUBLE_QUOTE */
            {
                if (c == '"') { buf[j++] = c; i++; q = NO_QUOTE; continue; }
                if (c == '\\')
                {
                    if (s[i+1] == '\n') { i += 2; continue; }
                    if (s[i+1]) { buf[j++] = '\\'; buf[j++] = s[i+1]; i += 2; continue; }
                }
                buf[j++] = c; i++; continue;
            }
        }
        if (j > 0)
        {
            char *field = malloc(j + 1);
            if (!field) { free_token_list(head); free(buf); return NULL; }
            ft_memcpy(field, buf, j); field[j] = '\0';
            if (!try_add_token(&head, field, T_WORD, NO_QUOTE))
            { free(field); free_token_list(head); free(buf); return NULL; }
        }
        while (s[i] && is_ifs_space((unsigned char)s[i]))
            i++;
    }
    free(buf);
    return head;
}

void    perform_word_splitting(t_shell *shell)
{
    t_token *current = shell->tokens;
    t_token *prev = NULL;

    while (current)
    {
        t_token *next_original = current->next;

        /* IMPORTANTÍSIMO:
           - SOLO dividimos si es una PALABRA (T_WORD)
           - y si no venía completamente entrecomillada */
        if (current->type == T_WORD && current->quoted == NO_QUOTE)
        {
            t_token *split = split_word_respecting_quotes(current->value);
            if (split == NULL)
            {
                /* Expansión → vacío sin comillas: elimina el token */
                if (prev) prev->next = next_original;
                else shell->tokens = next_original;
                free(current->value);
                free(current);
                current = next_original;
                continue;
            }
            /* Inserta lista nueva en lugar del token original */
            if (prev) prev->next = split;
            else shell->tokens = split;

            t_token *last = split;
            while (last->next) last = last->next;
            last->next = next_original;

            free(current->value);
            free(current);

            prev = last;
            current = next_original;
        }
        else
        {
            prev = current;
            current = next_original;
        }
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 16:07:05 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:40:49 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"

/*
** Reglas principales que seguimos (resumen):
** - Comentarios: un '#' que comienza una palabra (inicio de línea, tras espacio
**   no comillado o tras un operador) e *imprimible* y *no comillado* inicia un
**   comentario hasta fin de línea. (Bash: en modo interactivo depende de
**   shopt interactive_comments; aquí lo activamos siempre en no-interactivo).
**   Ref: Bash manual, "Comments". :contentReference[oaicite:0]{index=0}
**
** - Comillas:
**   * '...': literal, sin escapes, hasta la próxima ' (no se puede anidar). :contentReference[oaicite:1]{index=1}
**   * "...": backslash sólo escapa: $, `, ", \ y newline para continuación de
**            línea. (El resto de backslashes se preservan). :contentReference[oaicite:2]{index=2}
**   * fuera de comillas: '\' escapa el siguiente carácter; '\<newline>'
**     elimina ambos (continuación de línea POSIX). :contentReference[oaicite:3]{index=3}
**
** - Operadores reconocidos: ||, &&, |, ;, &, <, >, >>, <<, <<<, >|, <&, >&,
**   2>, 2>>, &>, &>>, paréntesis y llaves. (Algunos son Bash-specific, p.ej. &>, <<<). :contentReference[oaicite:4]{index=4}
**
** Nota: la *expansión* ($VAR, ~, etc.) no es parte del lexer; aquí sólo
** tokenizamos y marcamos si el token estaba comillado.
*/

static t_token *free_null_token_list(t_token **lst)
{
    free_token_list(*lst);
    *lst = NULL;
    return (NULL);
}

/* Detecta prefijos de fd redundantes: "1>", "0<", "2>&1"...;
 * aquí solo los saltamos para simplificar equivalencias de bash.
 * (No altera el AST, sólo evita tokens numéricos sueltos). */
static int  skip_default_fd_prefix(const char *s)
{
    if (s[0] == '1' && (s[1] == '>' || (s[1] == '<' && s[2] == '<')))
        return 1; /* 1>, 1<< */
    if (s[0] == '0' && (s[1] == '<' || (s[1] == '<' && s[2] == '<')))
        return 1; /* 0<, 0<< */
    if (s[0] == '2' && s[1] == '>' && s[2] == '&' && s[3] == '1')
        return 1; /* 2>&1 */
    return 0;
}

/* Sufijos fd redundantes tras un operador (>1, >>1, <&0, >&1...) */
static int  skip_default_fd_suffix(const char *s)
{
    if (s[0] == '>' && s[1] == '1' && s[2] != '>')
        return 1; /* >1 */
    if (s[0] == '>' && s[1] == '>' && s[2] == '1')
        return 1; /* >>1 */
    if (s[0] == '<' && s[1] == '&' && s[2] == '0')
        return 1; /* <&0 */
    if (s[0] == '>' && s[1] == '&' && s[2] == '1')
        return 1; /* >&1 */
    if (s[0] == '<' && s[1] == '<' && s[2] == '<' && s[3] == '1')
        return 1; /* <<<1 */
    return 0;
}

t_token *lexer(const char *raw_line)
{
    t_token *lst = NULL;
    int     i = 0, next_i = 0;

    if (!raw_line)
        return NULL;

    /* Hacemos una copia mutable para poder cortar comentarios de forma segura */
    char *line = ft_strdup(raw_line);
    if (!line)
        return NULL;

    /* Comentarios estilo bash: si # comienza palabra descomillada -> corta línea. */
    strip_comment_if_applicable(line); /* :contentReference[oaicite:5]{index=5} */

    while (line[i])
    {
        /* Saltar espacios fuera de comillas */
        while (line[i] && ft_isspace(line[i]))
            i++;
        if (!line[i])
            break;

        /* Normaliza casos 1>, 0<, 2>&1 (los fd explícitos por defecto) */
        i += skip_default_fd_prefix(line + i);

        if (is_operator(line + i, NULL, NULL))
        {
            next_i = get_operator(line, i, &lst);
            if (next_i < 0)
                return free_null_token_list(&lst);
            /* Saltar sufijos redundantes tras el operador */
            next_i += skip_default_fd_suffix(line + next_i);
        }
        else
        {
            next_i = get_word(line, i, &lst);
            if (next_i < 0)
                return free_null_token_list(&lst);
        }
        i = next_i;
    }

    free(line);
    return lst;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_get_opertator.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 14:55:24 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:41:35 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"

int     get_operator(const char *line, int i, t_token **lst)
{
        t_token_type    type;
        int             len;
        char            *op_str;

        if (!is_operator(line + i, &type, &len))
                return (i);
        op_str = ft_substr(line, i, len);
        if (!op_str)
        {
                free_lexer_list_on_error(lst);
                return (-1);
        }
        if (!try_add_token(lst, op_str, type, NO_QUOTE))
                return (-1);
        return (i + len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_get_word.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 14:25:33 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:41:46 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"

/*
** Avanza hasta el fin de una "palabra" al estilo bash:
** - Respeta comillas (simples/dobles) y sus reglas de escapes.
** - Fuera de comillas, '\' escapa siguiente char; '\\n' se elimina (continuación).
** - Un operador reconocido TERMINA la palabra si no estamos dentro de comillas.
** - Espacios no comillados también terminan palabra.
*/

static int word_end(const char *s, int i)
{
    t_quote q = NO_QUOTE;

    while (s[i])
    {
        char c = s[i];

        if (q == NO_QUOTE)
        {
            /* backslash fuera de comillas: escapa un char; "\<nl>" continúa línea. :contentReference[oaicite:8]{index=8} */
            if (c == '\\')
            {
                if (s[i + 1] == '\n') { i += 2; continue; }
                i += (s[i + 1] ? 2 : 1);
                continue;
            }
            /* comillas */
            if (c == '\'') { q = SINGLE_QUOTE; i++; continue; }
            if (c == '"')  { q = DOUBLE_QUOTE; i++; continue; }

            if (ft_isspace(c))
                break;

            /* operador -> fin de palabra */
            if (is_operator(s + i, NULL, NULL))
                break;

            i++;
        }
        else if (q == SINGLE_QUOTE)
        {
            /* dentro de '...': todo literal hasta siguiente ' (sin escapes). :contentReference[oaicite:9]{index=9} */
            if (c == '\'') q = NO_QUOTE;
            i++;
        }
        else /* DOUBLE_QUOTE */
        {
            /* dentro de "...": \ sólo escapa $, `, ", \ y newline. :contentReference[oaicite:10]{index=10} */
            if (c == '\\' && (s[i + 1] == '$' || s[i + 1] == '`'
                || s[i + 1] == '"' || s[i + 1] == '\\' || s[i + 1] == '\n'))
            {
                i += (s[i + 1] ? 2 : 1);
                continue;
            }
            if (c == '"') q = NO_QUOTE;
            i++;
        }
    }
    if (q != NO_QUOTE)
        return -1; /* comillas sin cerrar -> error sintaxis */
    return i;
}

int get_word(const char *line, int i, t_token **lst)
{
    int     start = i;
    int     end = word_end(line, i);
    char    *word;
    t_quote qtype = NO_QUOTE;

    if (end < 0)
    {
        fprintf(stderr, "minishell: syntax error: unclosed quote\n");
        free_lexer_list_on_error(lst);
        return -1;
    }
    if (end == start)
        return end;

    word = ft_substr(line, start, end - start);
    if (!word)
        return (free_lexer_list_on_error(lst), -1);

    /* Determina el comillado principal del token (si empieza por comilla) */
    if (word[0] == '\'') qtype = SINGLE_QUOTE;
    else if (word[0] == '"') qtype = DOUBLE_QUOTE;

    if (!try_add_token(lst, word, T_WORD, qtype))
    {
        free(word);
        return -1;
    }
    return end;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_strip_comments.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/24 13:45:00 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 13:45:00 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"

/*
** Bash: un comentario inicia si un '#' **comienza una palabra** no comillada:
** - inicio de línea
** - tras espacio no comillado
** - tras un operador
** Desde ahí hasta fin de línea se ignora. :contentReference[oaicite:6]{index=6}
**
** Aquí lo aplicamos siempre (en modo no interactivo de minishell).
*/
void    strip_comment_if_applicable(char *line)
{
    int i = 0;
    t_quote q = NO_QUOTE;
    int at_word_start = 1; /* al principio de la línea estamos al inicio de palabra */

    if (!line)
        return ;

    while (line[i])
    {
        char c = line[i];

        /* Gestión de escapes fuera/dentro de comillas según bash */
        if (q == NO_QUOTE)
        {
            if (c == '\\')
            {
                if (line[i + 1] == '\n')
                {
                    /* continuación de línea: elimina ambos */
                    /* desplazamos resto hacia atrás */
                    int j = i; 
                    while (line[j + 2]) { line[j] = line[j + 2]; j++; }
                    line[j] = '\0';
                    continue;
                }
                /* salta el próximo carácter como literal */
                if (line[i + 1]) i += 2; else i++;
                at_word_start = 0;
                continue;
            }
            if (c == '\'') { q = SINGLE_QUOTE; i++; at_word_start = 0; continue; }
            if (c == '"')  { q = DOUBLE_QUOTE; i++; at_word_start = 0; continue; }

            /* Si # comienza palabra y estamos fuera de comillas -> cortar */
            if (c == '#' && at_word_start)
            {
                line[i] = '\0';
                return ;
            }

            /* espacios reinician inicio-de-palabra */
            if (ft_isspace(c))
                at_word_start = 1;
            else
            {
                /* si el carácter actual inicia un operador, el siguiente es inicio-de-palabra */
                t_token_type t; int len;
                if (is_operator(line + i, &t, &len))
                {
                    i += len;
                    at_word_start = 1;
                    continue;
                }
                at_word_start = 0;
            }
            i++;
        }
        else if (q == SINGLE_QUOTE)
        {
            /* dentro de comillas simples: todo literal hasta la siguiente ' */
            if (c == '\'') q = NO_QUOTE;
            i++;
            at_word_start = 0;
        }
        else /* DOUBLE_QUOTE */
        {
            /* Dentro de dobles comillas, \ sólo escapa $, `, ", \ y newline. :contentReference[oaicite:7]{index=7} */
            if (c == '\\' && (line[i + 1] == '$' || line[i + 1] == '`'
                || line[i + 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '\n'))
            {
                if (line[i + 1] == '\n')
                {
                    /* quita la continuación de línea */
                    int j = i;
                    while (line[j + 2]) { line[j] = line[j + 2]; j++; }
                    line[j] = '\0';
                    continue;
                }
                i += (line[i + 1] ? 2 : 1);
                at_word_start = 0;
                continue;
            }
            if (c == '"') q = NO_QUOTE;
            i++;
            at_word_start = 0;
        }
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_types.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 16:42:46 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:42:23 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"

t_token_type    get_pipe_and_or(const char *str, int len)
{
    if (len == 2 && str[0] == '|' && str[1] == '|') return (T_OR);
    if (len == 2 && str[0] == '&' && str[1] == '&') return (T_AND);
    if (len == 1 && str[0] == '|') return (T_PIPE);
    if (len == 1 && str[0] == '&') return (T_BG);
    if (len == 1 && str[0] == ';') return (T_SEMI);
    if (len == 1 && str[0] == '(') return (T_LPAREN);
    if (len == 1 && str[0] == ')') return (T_RPAREN);
    if (len == 1 && str[0] == '{') return (T_LBRACE);
    if (len == 1 && str[0] == '}') return (T_RBRACE);
    return (T_UNKNOWN);
}

t_token_type    get_semi_redir_left(const char *str, int len)
{
    if (len == 1 && str[0] == '<') return (T_REDIR_IN);
    if (len == 2 && str[0] == '<' && str[1] == '<') return (T_HEREDOC);
    if (len == 3 && str[0] == '<' && str[1] == '<' && str[2] == '<') return (T_HEREDOC_STR);
    if (len == 2 && str[0] == '<' && str[1] == '&') return (T_DUP_IN);
    if (len == 1 && str[0] == '=') return (T_EQUAL);
    return (T_UNKNOWN);
}

t_token_type    get_redir_right(const char *str, int len)
{
    if (len == 2 && str[0] == '>' && str[1] == '>') return (T_APPEND);
    if (len == 2 && str[0] == '>' && str[1] == '|') return (T_FORCE_OUT);
    if (len == 2 && str[0] == '>' && str[1] == '&') return (T_DUP_OUT);
    if (len == 1 && str[0] == '>') return (T_REDIR_OUT);
    return (T_UNKNOWN);
}

t_token_type    get_redir_special(const char *str, int len)
{
    if (len == 3 && str[0] == '&' && str[1] == '>' && str[2] == '>') return (T_APPEND_ALL);
    if (len == 2 && str[0] == '&' && str[1] == '>') return (T_REDIR_ALL);
    if (len == 3 && str[0] == '2' && str[1] == '>' && str[2] == '>') return (T_APPEND_ERR);
    if (len == 2 && str[0] == '2' && str[1] == '>') return (T_REDIR_ERR);
    return (T_UNKNOWN);
}

t_token_type    get_token_type(const char *str, int len)
{
    t_token_type type;

    type = get_redir_special(str, len);
    if (type != T_UNKNOWN) return type;

    type = get_redir_right(str, len);
    if (type != T_UNKNOWN) return type;

    type = get_semi_redir_left(str, len);
    if (type != T_UNKNOWN) return type;

    type = get_pipe_and_or(str, len);
    if (type != T_UNKNOWN) return type;

    return T_WORD;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 16:36:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:50:38 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"

t_token *token_new(char *value, t_token_type type, t_quote quote)
{
        t_token *tok;

        tok = (t_token *)malloc(sizeof(t_token));
        if (!tok)
                return (NULL);
        tok->value = value;
        tok->type = type;
        tok->quoted = quote;
        tok->next = NULL;
        return (tok);
}

void    token_addback(t_token **lst, t_token *new)
{
        t_token *tmp;

        if (!lst || !new)
                return ;
        if (!*lst)
        {
                *lst = new;
                return ;
        }
        tmp = *lst;
        while (tmp->next)
                tmp = tmp->next;
        tmp->next = new;
}

void free_token_list(t_token *tok)
{
    t_token *next;

    while (tok)
    {
        next = tok->next;
        free(tok->value);
        free(tok);
        tok = next;
    }
}

void next_token(t_token **cur)
{
    if (cur && *cur)
        *cur = (*cur)->next;
}



int     is_operator(const char *str, t_token_type *type, int *len)
{
        static const char *ops[] = {
                "<<<", ">>", "<<", "||", "&&", "&>>", "&>", ">|", "<&", ">&",
                "2>>", "2>", "|",  "&",  ";",  "<",  ">",  "(",  ")",  "{", "}", "="
        };
        static const int  lens[] = {
                3,     2,    2,    2,    2,    3,     2,    2,    2,    2,
                3,     2,    1,    1,    1,    1,    1,    1,    1,    1,  1,  1
        };
        static const t_token_type types[] = {
                T_HEREDOC_STR, T_APPEND, T_HEREDOC, T_OR, T_AND, T_APPEND_ALL,
                T_REDIR_ALL,   T_FORCE_OUT, T_DUP_IN, T_DUP_OUT, T_APPEND_ERR,
                T_REDIR_ERR,   T_PIPE,  T_BG,  T_SEMI, T_REDIR_IN, T_REDIR_OUT,
                T_LPAREN, T_RPAREN, T_LBRACE, T_RBRACE, T_EQUAL
        };
        int i = 0;

        while (i < (int)(sizeof(lens)/sizeof(lens[0])))
        {
                if (ft_strncmp(str, ops[i], lens[i]) == 0)
                {
                        if (type) *type = types[i];
                        if (len)  *len  = lens[i];
                        return 1;
                }
                i++;
        }
        return 0;
}

void    free_lexer_list_on_error(t_token **lst)
{
        if (lst && *lst)
        {
                free_token_list(*lst);
                *lst = NULL;
        }
}

int     try_add_token(t_token **lst, char *str, t_token_type type, t_quote quote)
{
        t_token *tok = token_new(str, type, quote);
        if (!tok)
        {
                ft_strdel(&str);
                return 0;
        }
        token_addback(lst, tok);
        return 1;
}

/* Opcional: utilidad de eliminación de backslashes por tipo de comilla.
 * Útil si quieres “limpiar” el literal tras el lexer y antes de expandir. */
char    *remove_backslashes_for_token(const char *src, t_quote quote)
{
        char    *out;
        size_t  i = 0, j = 0;
        size_t  n = ft_strlen(src);

        out = malloc(n + 1);
        if (!out) return NULL;

        if (quote == SINGLE_QUOTE)
        {
                /* en '...' no hay escapes; copiamos tal cual */
                while (i < n) out[j++] = src[i++];
        }
        else if (quote == DOUBLE_QUOTE)
        {
                while (i < n)
                {
                        if (src[i] == '\\' && i + 1 < n &&
                           (src[i+1] == '$' || src[i+1] == '`' ||
                            src[i+1] == '"' || src[i+1] == '\\'))
                        { i++; out[j++] = src[i++]; }
                        else if (src[i] == '\\' && i + 1 < n && src[i+1] == '\n')
                        { i += 2; /* elimina continuación de línea */ }
                        else out[j++] = src[i++];
                }
        }
        else /* NO_QUOTE */
        {
                while (i < n)
                {
                        if (src[i] == '\\' && i + 1 < n && src[i+1] == '\n')
                        { i += 2; } /* elimina continuación de línea */
                        else if (src[i] == '\\' && i + 1 < n)
                        { i++; out[j++] = src[i++]; } /* escapa siguiente */
                        else out[j++] = src[i++];
                }
        }
        out[j] = '\0';
        return out;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc_read.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 01:06:08 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 04:29:30 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "signal.h"

/*
** heredoc_read:
** Lee un heredoc hasta el delimitador o interrupción por Ctrl+C (SIGINT).
** - Devuelve un fd de solo lectura si todo va bien.
** - Devuelve -1 si hubo interrupción o error.
*/

/* here-doc: lee hasta 'delimiter' (sin expansión aquí; eso se decide al parsear) */

int heredoc_read(char *delimiter)
{
    int   pipefd[2];
    char *line;

    if (!delimiter)
        return (-1);
    if (pipe(pipefd) < 0)
    {
        perror("minishell: pipe");
        return (-1);
    }

    /* Comportamiento típico: en heredoc el shell hijo maneja SIGINT/SIGQUIT por defecto */
    signal(SIGQUIT, SIG_DFL);
    signal(SIGINT, SIG_DFL);

    while (1)
    {
        line = readline("> ");
        if (!line)  /* EOF (Ctrl-D) */
            break;
        if (strcmp(line, delimiter) == 0)
        {
            free(line);
            break;
        }
        /* Sin expansión: se escribe tal cual con salto de línea */
        write(pipefd[1], line, strlen(line));
        write(pipefd[1], "\n", 1);
        free(line);
    }
    close(pipefd[1]);          /* Muy importante: cerrar escritura para que el lector vea EOF */
    return (pipefd[0]);        /* Devuelve fd de lectura */
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_and_or.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 18:38:03 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/28 03:02:13 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"

t_ast	*parse_and_or(t_token **cur)
{
	t_ast		*left;
	t_ast		*right;
	t_ast		*node;
	t_node_type	node_type;

	left = parse_pipeline(cur);
	if (!left)
		return (NULL);

	while (*cur && ((*cur)->type == T_AND || (*cur)->type == T_OR))
	{
		if ((*cur)->type == T_AND)
			node_type = N_AND;
		else
			node_type = N_OR;

		next_token(cur);
		if (!*cur)
		{
			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
			free_ast(left);
			return (NULL);
		}
		right = parse_pipeline(cur);
		if (!right)
		{
			free_ast(left);
			return (NULL);
		}
		node = ast_new_binary(node_type, left, right);
		if (!node)
		{
			free_ast(left);
			free_ast(right);
			return (NULL);
		}
		left = node;
	}
	return (left);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_arguments.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/28 03:14:32 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/30 16:35:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "lexer.h"

char	**add_argument(char **argv, int *argc, int *size, const char *value)
{
	char	**new_argv;
	size_t	old_bytes;
	size_t	new_bytes;

	if (*argc >= *size)
	{
		old_bytes = (size_t)(*size) * sizeof(char *);
		*size *= 2;
		new_bytes = (size_t)(*size + 1) * sizeof(char *);
		new_argv = (char **)ft_realloc(argv, old_bytes, new_bytes);
		if (!new_argv)
		{
			ft_free_strtab(argv);
			return (NULL);
		}
		argv = new_argv;
	}
	argv[*argc] = ft_strdup(value);
	if (!argv[*argc])
	{
		ft_free_strtab(argv);
		return (NULL);
	}
	(*argc)++;
	argv[*argc] = NULL;
	return (argv);
}

char	**parse_arguments(t_token **cur)
{
	int		size;
	int		argc;
	char	**argv;

	size = 4;
	argc = 0;
	argv = malloc(sizeof(char *) * (size + 1));
	if (!argv)
		return (NULL);
	argv[0] = NULL;
	while (*cur && (*cur)->type == T_WORD)
	{
		argv = add_argument(argv, &argc, &size, (*cur)->value);
		if (!argv)
			return (NULL);
		next_token(cur);
	}
	if (argc == 0)
	{
		free(argv);
		return (NULL);
	}
	return (argv);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_background.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 18:36:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 16:14:42 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"
#include "lexer.h"

t_ast	*parse_background(t_token **cur)
{
	t_ast	*left;
	t_ast	*right;
	t_ast	*node;

	left = parse_sequence(cur);
	if (!left)
		return (NULL);

	while (*cur && (*cur)->type == T_BG)
	{
		next_token(cur);
		if (!*cur || (*cur)->type == T_SEMI || (*cur)->type == T_PIPE
			|| (*cur)->type == T_AND || (*cur)->type == T_OR
			|| (*cur)->type == T_RPAREN)
		{
			// No hay más comandos, se permite background sin "right"
			node = ast_new_binary(N_BACKGROUND, left, NULL);
			if (!node)
			{
				free_ast(left);
				return (NULL);
			}
			left = node;
			break ;
		}
		right = parse_sequence(cur);
		if (!right)
		{
			free_ast(left);
			return (NULL);
		}
		node = ast_new_binary(N_BACKGROUND, left, right);
		if (!node)
		{
			free_ast(left);
			free_ast(right);
			return (NULL);
		}
		left = node;
	}
	return (left);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_command_and_redirection.c                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 06:56:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 16:15:45 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"
#include "lexer.h"

t_ast	*parse_command_and_redirections(t_token **cur)
{
	t_ast	*cmd_node;
	t_ast	*redir_head;
	t_ast	*redir_tail;

	cmd_node = NULL;
	redir_head = NULL;
	redir_tail = NULL;
	if (!parse_redirections(cur, &redir_head, &redir_tail))
		return (NULL);
	if (*cur && (*cur)->type == T_LPAREN)
		cmd_node = parse_subshell(cur);
	else if (*cur && (*cur)->type == T_WORD)
		cmd_node = parse_simple_command(cur);
	else
	{
		if (!redir_head)
		{
			ft_dprintf(2,
				"minishell: syntax error near unexpected token '%s'\n",
				*cur ? (*cur)->value : "newline");
			return (NULL);
		}
		ft_dprintf(2,
			"minishell: syntax error: command expected after redirections\n");
		free_ast(redir_head);
		return (NULL);
	}
	if (!cmd_node)
	{
		free_ast(redir_head);
		return (NULL);
	}
	if (!parse_redirections(cur, &redir_head, &redir_tail))
	{
		free_ast(cmd_node);
		free_ast(redir_head);
		return (NULL);
	}
	if (redir_head)
		cmd_node->cmd.redirections = redir_head;
	return (cmd_node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_pipeline.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 18:38:38 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/28 03:02:40 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"
#include "lexer.h"

t_ast	*parse_pipeline(t_token **cur)
{
	t_ast	*left;
	t_ast	*right;
	t_ast	*node;

	left = parse_command_and_redirections(cur);
	if (!left)
		return (NULL);

	while (*cur && (*cur)->type == T_PIPE)
	{
		next_token(cur);
		if (!*cur)
		{
			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
			free_ast(left);
			return (NULL);
		}
		right = parse_command_and_redirections(cur);
		if (!right)
		{
			free_ast(left);
			return (NULL);
		}
		node = ast_new_binary(N_PIPE, left, right);
		if (!node)
		{
			free_ast(left);
			free_ast(right);
			return (NULL);
		}
		left = node;
	}
	return (left);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_redirections.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 01:03:45 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 18:01:15 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"
#include "parser.h"
#include "ast.h"

static t_redir_type	token_type_to_redir_type(t_token_type type)
{
	if (type == T_REDIR_IN)      return REDIR_IN;
	if (type == T_REDIR_OUT)     return REDIR_OUT;
	if (type == T_APPEND)        return REDIR_APPEND;
	if (type == T_HEREDOC)       return REDIR_HEREDOC;
	if (type == T_REDIR_ERR)     return REDIR_ERR;
	if (type == T_APPEND_ERR)    return REDIR_APPEND_ERR;
	if (type == T_REDIR_ALL)     return REDIR_ALL;
	if (type == T_APPEND_ALL)    return REDIR_APPEND_ALL;
	if (type == T_FORCE_OUT)     return REDIR_FORCE;
	if (type == T_DUP_IN)        return REDIR_DUP_IN;
	if (type == T_DUP_OUT)       return REDIR_DUP_OUT;
	return REDIR_INVALID;
}

int	is_redirection(t_token *tok)
{
	if (!tok) return 0;
	return (tok->type == T_REDIR_IN || tok->type == T_REDIR_OUT
		|| tok->type == T_APPEND || tok->type == T_HEREDOC
		|| tok->type == T_REDIR_ERR || tok->type == T_APPEND_ERR
		|| tok->type == T_REDIR_ALL || tok->type == T_APPEND_ALL
		|| tok->type == T_FORCE_OUT || tok->type == T_DUP_IN
		|| tok->type == T_DUP_OUT);
}

int	parse_redirections(t_token **cur, t_ast **head, t_ast **tail)
{
	while (*cur && is_redirection(*cur))
	{
		t_token      *redir_tok = *cur;
		t_redir_type  rtype     = token_type_to_redir_type(redir_tok->type);
		t_token      *file_tok;
		t_ast        *new_redir;
		int           fd;

		next_token(cur);
		file_tok = *cur;
		if (!file_tok || file_tok->type != T_WORD || rtype == REDIR_INVALID)
		{
			ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n",
				file_tok ? file_tok->value : "newline");
			return (0);
		}

		if (rtype == REDIR_DUP_OUT || rtype == REDIR_DUP_IN)
		{
			if (!ft_isposfdstr(file_tok->value))
			{
				ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n", file_tok->value);
				return (0);
			}
			fd = ft_atoi(file_tok->value);
			new_redir = ast_new_redir(NULL, NULL, rtype, fd);
		}
		else if (rtype == REDIR_HEREDOC)
		{
			/* Guardamos SOLO el delimitador; se leerá en ejecución */
			new_redir = ast_new_redir(NULL, ft_strdup(file_tok->value), rtype, -1);
		}
		else
		{
			new_redir = ast_new_redir(ft_strdup(file_tok->value), NULL, rtype, -1);
		}

		if (!new_redir)
			return (0);

		next_token(cur);
		if (!*head) { *head = new_redir; *tail = new_redir; }
		else { (*tail)->bin.right = new_redir; *tail = new_redir; }
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_sequence.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/25 22:23:59 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 16:14:59 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"

t_ast	*parse_sequence(t_token **cur)
{
	t_ast	*left;
	t_ast	*right;
	t_ast	*node;

	left = parse_and_or(cur);
	if (!left)
		return (NULL);

	while (*cur && (*cur)->type == T_SEMI)
	{
		next_token(cur);
		if (!*cur)
		{
			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
			free_ast(left);
			return (NULL);
		}
		right = parse_and_or(cur);
		if (!right)
		{
			free_ast(left);
			return (NULL);
		}
		node = ast_new_binary(N_SEQUENCE, left, right);
		if (!node)
		{
			free_ast(left);
			free_ast(right);
			return (NULL);
		}
		left = node;
	}
	return (left);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_simple_command.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 18:39:45 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:14:36 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"
#include "lexer.h"

t_ast	*parse_simple_command(t_token **cur)
{
	t_ast	*redir_head = NULL;
	t_ast	*redir_tail = NULL;
	t_ast	*cmd_node;
	char	**argv;

	if (is_lparen(*cur))
	{
		cmd_node = parse_subshell(cur);
		if (!cmd_node)
			return (NULL);
		if (!parse_redirections(cur, &redir_head, &redir_tail))
		{
			free_ast(cmd_node);
			return (NULL);
		}
		cmd_node->subshell.redirections = redir_head;
		return (cmd_node);
	}

	if (!parse_redirections(cur, &redir_head, &redir_tail))
		return (NULL);

	argv = parse_arguments(cur);
	if (!argv)
	{
		if (redir_head)
		{
			free_ast(redir_head);
			ft_dprintf(2, "minishell: syntax error: empty command before redirection\n");
			return (NULL);
		}
		ft_dprintf(2, "minishell: syntax error: empty command or unexpected token\n");
		return (NULL);
	}

	if (!parse_redirections(cur, &redir_head, &redir_tail))
	{
		ft_free_strtab(argv);
		free_ast(redir_head);
		return (NULL);
	}

	cmd_node = ast_new_command(argv, redir_head);
	if (!cmd_node)
	{
		ft_free_strtab(argv);
		free_ast(redir_head);
		return (NULL);
	}
	return (cmd_node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_simple_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/13 19:05:39 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:52:11 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"   
#include "lexer.h"

int	is_lparen(t_token *tok)
{
	if (!tok)
		return (0);
	return (tok->type == T_LPAREN);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_subshell.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 00:59:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:14:29 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include "ast.h"
#include "lexer.h"

t_ast	*parse_subshell(t_token **cur)
{
	t_ast	*sub_ast;
	t_ast	*node;

	next_token(cur);
	if (!*cur)
	{
		ft_dprintf(2,
			"minishell: syntax error: unexpected end of input after '('\n");
		return (NULL);
	}
	sub_ast = parse_background(cur);
	if (!sub_ast)
		return (NULL);
	if (!(*cur) || (*cur)->type != T_RPAREN)
	{
		ft_dprintf(2, "minishell: syntax error: missing ')'\n");
		free_ast(sub_ast);
		return (NULL);
	}
	next_token(cur);
	node = ast_new_subshell(sub_ast, NULL);
	if (!node)
	{
		free_ast(sub_ast);
		return (NULL);
	}
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup_shell.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 03:25:37 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/24 14:52:36 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"
#include "env.h"

// --- NUEVO: helper para imprimir errores con mapeo 126/127 ---
static int has_slash_local(const char *s)
{
        for (; s && *s; s++) if (*s == '/') return 1;
        return 0;
}

int print_exec_error(t_shell *shell, const char *cmd, int err_code)
{
        int ret;

        if (!cmd || !*cmd)
        {
                ft_dprintf(2, "minishell: : command not found\n");
                shell->exit_status = 127;
                return 127;
        }

        if (!has_slash_local(cmd) && err_code == ENOENT)
        {
                // No hay '/', no encontrado en PATH → 127
                ft_dprintf(2, "minishell: %s: command not found\n", cmd);
                ret = 127;
        }
        else
        {
                // Ruta con '/', o encontrado pero no ejecutable u otros errores
                ft_dprintf(2, "minishell: %s: %s\n", cmd, strerror(err_code));
                if (err_code == EACCES || err_code == ENOEXEC || err_code == EISDIR || err_code == EPERM)
                        ret = 126;   // encontrado pero no se puede ejecutar → 126
                else if (err_code == ENOENT || err_code == ENOTDIR || err_code == ENAMETOOLONG || err_code == ELOOP)
                        ret = 127;   // no encontrado → 127
                else
                        ret = 126;   // por defecto, fallo de ejecución ≈ 126
        }
        shell->exit_status = ret;
        return ret;
}

// Limpia los recursos utilizados en cada iteración del bucle interactivo
// Esto se llama al final de cada iteración del bucle interactivo
// para evitar fugas de memoria y asegurar que cada comando se ejecute con un estado limpio
// y sin residuos de la iteración anterior.
void    cleanup_loop(t_shell *shell)
{
    if (shell->line)
    {
        free(shell->line);
        shell->line = NULL;
    }
    if (shell->tokens)
    {
        free_token_list(shell->tokens);
        shell->tokens = NULL;
    }
}

// Limpia todos los recursos del shell al finalizar
// Se asume que se llama al final de la ejecución del shell, ya sea al salir
// del bucle interactivo o al ejecutar un script o comando único.
// Libera la memoria utilizada por las estructuras del shell y restaura la configuración del terminal.
// También libera el nombre del programa (argv[0]) que se duplicó al inicio.
// Se debe llamar a esta función antes de que el programa termine
// para evitar fugas de memoria y asegurar que todos los recursos se liberen adecuadamente.
void    cleanup_shell(t_shell *shell)
{
    // Libera los recursos dinámicos
    if (shell->env)
    {
        free_env_list(shell->env); // Asumido que libera la lista enlazada del entorno
        shell->env = NULL;
    }
    if (shell->line)
    {
        free(shell->line);
        shell->line = NULL;
    }
    if (shell->tokens)
    {
        free_token_list(shell->tokens);
        shell->tokens = NULL;
    }
    if (shell->program_name)
    {
        free(shell->program_name);
        shell->program_name = NULL;
    }

    // Restaura la configuración del terminal (si aplica)
    restore_vquit(); // Asumido que restaura los manejadores de señales o modos del terminal
}

/*
int	print_exec_error(t_shell *shell, const char *cmd, int err_code)
{
	int	status;

	if (err_code == ENOENT)
	{
		ft_dprintf(2, "minishell: %s: command not found\n", cmd);
		status = 127;
	}
	else if (err_code == EACCES)
	{
		if (ft_strchr(cmd, '/'))
			ft_dprintf(2, "%s: Permission denied\n", cmd);
		else
			ft_dprintf(2, "minishell: %s: permission denied\n", cmd);
		status = 126;
	}
	else if (err_code == EISDIR)
	{
		ft_dprintf(2, "minishell: %s: is a directory\n", cmd);
		status = 126;
	}
	else
	{
		ft_dprintf(2, "minishell: %s: execution error\n", cmd);
		status = 1;
	}
	shell->exit_status = status;
	return (status);
}
*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_help_version.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/16 22:44:20 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/26 15:20:48 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_help_version(int argc, char **argv)
{
	if (argc == 2 && ft_strcmp(argv[1], "--help") == 0)
	{
		print_help();
		return (0);
	}
	if (argc == 2 && ft_strcmp(argv[1], "--version") == 0)
	{
		print_version();
		return (0);
	}
	return (-1);
}

void	print_help(void)
{
	ft_dprintf(1, "minishell: a minimal shell implementation\n");
	ft_dprintf(1, "Usage:  ./minishell [option] [script-file]\n");
	ft_dprintf(1, "Options:\n");
	ft_dprintf(1, "        -c command      execute command\n");
	ft_dprintf(1, "        script-file     execute commands from script file\n");
	ft_dprintf(1, "        --help          display this help and exit\n");
	ft_dprintf(1, "        --version       output version information and exit\n");
	ft_dprintf(1, "\n");
	ft_dprintf(1, "If no option or script-file is given, minishell starts in interactive mode.\n");
}

void	print_usage(const char *invalid)
{
	if (invalid)
		ft_dprintf(2, "minishell: %s: invalid option\n", invalid);
	ft_dprintf(2, "Usage:  ./minishell [option] [script-file]\n");
	ft_dprintf(2, "Options:\n");
	ft_dprintf(2, "        -c command      execute command\n");
	ft_dprintf(2, "        script-file     execute commands from script file\n");
	ft_dprintf(2, "        --help          display this help and exit\n");
	ft_dprintf(2, "        --version       output version information and exit\n");
}

void	print_version(void)
{
	ft_dprintf(1, "minishell, version 1.0\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_shell.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 03:25:09 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/27 19:56:47 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "env.h"

int	init_shell_name(t_shell *shell, char **argv)
{
	ft_memset(shell, 0, sizeof(t_shell));
	shell->exit_status = 0;
	shell->program_name = ft_strdup(argv[0]);
	if (!shell->program_name)
	{
		ft_dprintf(2, "minishell: Error fatal: No se pudo asignar el nombre del programa.\n");
		return (1);
	}
	return (0);
}

int init_env(t_shell *shell, char **envp)
{
    shell->env = init_env_list(envp);
    if (!shell->env)
    {
        ft_dprintf(2, "minishell: Error fatal: No se pudo inicializar el entorno.\n");
        return (1);
    }
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_interactive.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 13:09:44 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:41:11 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* helpers de cierre de comillas/backslash (tus versiones) */
static int ft_quotes_closed(const char *line)
{
    int i = 0, state = 0;
    while (line && line[i])
    {
        if (!state && (line[i] == '\'' || line[i] == '"')) state = line[i];
        else if (state == '\'' && line[i] == '\'') state = 0;
        else if (state == '"' && line[i] == '\\' &&
                 (line[i + 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '`')) i++;
        else if (state == '"' && line[i] == '"') state = 0;
        else if (!state && line[i] == '\\' && line[i + 1]) i++;
        i++;
    }
    return (state == 0);
}

static int ft_backslach_closed(char *line)
{
    int i, count;

    if (!line) return (1);
    i = (int)ft_strlen(line) - 1;
    count = 0;
    while (i >= 0 && line[i] == '\\') { count++; i--; }
    return ((count % 2) == 0);
}

char *read_line_interactive(t_shell *shell)
{
    char *next;

    /* aseguramos prompt limpio y TTY sano */
    setup_prompt_signals();
    g_signal = 0;

    shell->line = readline("\001\033[1;35m\002minishell$ \001\033[0m\002");
    if (!shell->line)
        return NULL;

    while (!ft_quotes_closed(shell->line) || !ft_backslach_closed(shell->line))
    {
        setup_prompt_signals();
        next = readline("> ");
        if (!next) { free(shell->line); shell->line = NULL; return NULL; }
        shell->line = ft_strjoin_free_s1(shell->line, "\n");
        if (!shell->line) { free(next); return NULL; }
        shell->line = ft_strjoin_free_s1(shell->line, next);
        free(next);
    }
    return shell->line;
}
void run_interactive(t_shell *shell)
{
    shell->is_interactive = 1;

    while (1)
    {
        setup_prompt_signals();          /* prompt: INT handler + QUIT ignorado */
        if (shell->line) { free(shell->line); shell->line = NULL; }

        shell->line = read_line_interactive(shell); /* usa readline con el prompt */

        if (!shell->line)                 /* Ctrl-D en línea vacía */
            break;

        if (shell->line[0] == '\0') {     /* Enter vacío o Ctrl-C en prompt */
            free(shell->line);
            shell->line = NULL;
            continue;
        }

        add_history(shell->line);

        /* PADRE ignora señales mientras ejecuta (y las restablece el hijo) */
        setup_exec_parent_signals();

        if (shell->tokens) { free_token_list(shell->tokens); shell->tokens = NULL; }
        shell_exec(shell);

        /* Al volver de ejecutar, vuelve al modo prompt */
        setup_prompt_signals();
        cleanup_loop(shell);

        if (shell->should_exit)
            break;
    }
    if (shell->is_interactive)
        write(1, "exit\n", 5);
    rl_clear_history();
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_non_interactive.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/22 20:32:53 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/26 16:46:27 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"
#include "parser.h"
#include "expand.h"
#include "exec.h"

// Quita '\n' final si existe (opcionalmente también '\r' si llegara CRLF).
static void chomp_nl(char *s)
{
    size_t len;

    if (!s)
        return;
    len = ft_strlen(s);
    if (len && s[len - 1] == '\n')
    {
        s[len - 1] = '\0';
        if (len >= 2 && s[len - 2] == '\r') // por si viniera CRLF
            s[len - 2] = '\0';
    }
}

void run_non_interactive(t_shell *shell)
{
    char *line;

    shell->is_interactive = 0;
    // En no-interactivo, el caller debe haber llamado a setup_default_signals()
    // para no redibujar prompt y dejar señales por defecto.
    while (1)
    {
        if (shell->line)
        {
            free(shell->line);
            shell->line = NULL;
        }
        line = get_next_line(STDIN_FILENO);   // <-- usamos tu GNL
        if (!line)
            break;                            // EOF o error -> salir bucle
        chomp_nl(line);                        // quitamos '\n' final
        shell->line = line;
        if (*shell->line)                      // ignorar líneas vacías
        {
            // El padre no debe imprimir nada ni reaccionar a SIGINT/SIGQUIT.
            // Los hijos restaurarán señales por defecto antes de execve().
            setup_exec_parent_signals();
            if (shell->tokens)
            {
                free_token_list(shell->tokens);
                shell->tokens = NULL;
            }
            shell_exec(shell);
        }
        cleanup_loop(shell);
        if (shell->should_exit)
            break;
    }
    // Importante: NO imprimir "exit\n" aquí (solo en modo interactivo).
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell_exec.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/11 14:49:39 by acoronad          #+#    #+#             */
/*   Updated: 2025/07/26 16:07:53 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "lexer.h"
#include "expand.h"
#include "parser.h"
#include "ast.h"

int	shell_exec(t_shell *shell)
{
	shell->tokens = lexer(shell->line);
	if (!shell->tokens)
	{
		shell->exit_status = 2; // Error de sintaxis como Bash
		return (2);
	}
//	prueba_lexer(shell);
	expand_variables(shell);
//	prueba_expansion(shell);
	shell->ast = build_ast(shell->tokens);
	free_token_list(shell->tokens);
	shell->tokens = NULL;
	if (!shell->ast)
	{
		shell->exit_status = 2; // Error de sintaxis como Bash
		return (2);
	}
//	prueba_ast(shell);
	execute_ast(shell->ast, shell);
	return (shell->exit_status);
}

char	*token_type_str(t_token_type type)
{
	if (type == T_WORD)
		return ("WORD");
	if (type == T_PIPE)
		return ("PIPE");
	if (type == T_OR)
		return ("OR");
	if (type == T_AND)
		return ("AND");
	if (type == T_BG)
		return ("BG");
	if (type == T_SEMI)
		return ("SEMI");
	if (type == T_REDIR_IN)
		return ("REDIR_IN");
	if (type == T_REDIR_OUT)
		return ("REDIR_OUT");
	if (type == T_APPEND)
		return ("APPEND");
	if (type == T_HEREDOC)
		return ("HEREDOC");
	if (type == T_REDIR_ERR)
		return ("REDIR_ERR");
	if (type == T_APPEND_ERR)
		return ("APPEND_ERR");
	if (type == T_REDIR_ALL)
		return ("REDIR_ALL");
	if (type == T_APPEND_ALL)
		return ("APPEND_ALL");
	if (type == T_FORCE_OUT)
		return ("FORCE_OUT");
	if (type == T_HEREDOC_STR)
		return ("HEREDOC_STR");
	if (type == T_DUP_IN)
		return ("DUP_IN");
	if (type == T_DUP_OUT)
		return ("DUP_OUT");
	if (type == T_LPAREN)
		return ("LPAREN");
	if (type == T_RPAREN)
		return ("RPAREN");
	if (type == T_LBRACE)
		return ("LBRACE");
	if (type == T_RBRACE)
		return ("RBRACE");
	if (type == T_EQUAL)
		return ("EQUAL");
	if (type == T_UNKNOWN)
		return ("UNKNOWN");
	return ("OTHER");
}

static char	*quote_type_str(t_quote q)
{
	if (q == NO_QUOTE)
		return ("NO_QUOTE");
	if (q == SINGLE_QUOTE)
		return ("SINGLE_QUOTE");
	if (q == DOUBLE_QUOTE)
		return ("DOUBLE_QUOTE");
	return ("OTHER");
}

void	prueba_lexer(t_shell *shell)
{
	t_token	*tok;
	int		i;

	tok = shell->tokens;
	i = 0;
	if (!tok)
	{
		printf("No tokens found.\n");
		return ;
	}
	while (tok)
	{
		printf("Token %d:\n", i);
		printf("  value: \"%s\"\n", tok->value);
		printf("  type: %s\n", token_type_str(tok->type));
		printf("  quote: %s\n", quote_type_str(tok->quoted));
		tok = tok->next;
		i++;
	}
}

void	prueba_env(t_shell *shell)
{
	t_env	*env;
	int		i;

	env = shell->env;
	i = 0;
	if (!env)
	{
		printf("No environment variables found.\n");
		return ;
	}
	printf("Current environment variables:\n");
	while (env)
	{
		printf("🧪 [%d] key = \"%s\" | value = \"%s\" | exported = %d\n",
			i,
			env->key ? env->key : "(null)",
			env->value ? env->value : "(null)",
			env->exported);
		env = env->next;
		i++;
	}
}

void	prueba_expansion(t_shell *shell)
{
	t_token	*tok;
	int		i;

	tok = shell->tokens;
	i = 0;
	if (!tok)
	{
		printf("No tokens found for expansion.\n");
		return ;
	}
	printf("Prueba de expansión:\n");
	while (tok)
	{
		printf("Token %d:\n", i);
		printf("  value: \"%s\"\n", tok->value ? tok->value : "(null)");
		printf("  type: %s\n", token_type_str(tok->type));
		printf("  quote: %s\n", quote_type_str(tok->quoted));
		tok = tok->next;
		i++;
	}
	printf("Prompt simulado: ");
	tok = shell->tokens;
	while (tok)
	{
		if (tok->value)
			printf("%s ", tok->value);
		tok = tok->next;
	}
	printf("\n");
}

#include <stdio.h>

static void print_indent(int level)
{
    while (level--)
        printf("  ");
}

void prueba_ast(t_shell *shell)
{
    if (!shell || !shell->ast)
    {
        printf("No hay AST que mostrar.\n");
        return;
    }
    printf("======= AST DEBUG =======\n");
    print_ast_debug(shell->ast, 0);
    printf("=========================\n");
}
#include <stdio.h>

void print_ast_debug(t_ast *node, int level)
{
    if (!node)
        return;

    print_indent(level);
    printf("Node type: ");

    if (node->type == N_COMMAND)
    {
        printf("N_COMMAND\n");
        print_indent(level);
        printf("  argv:");
        if (node->cmd.argv)
        {
            for (int i = 0; node->cmd.argv[i]; i++)
                printf(" \"%s\"", node->cmd.argv[i]);
        }
        printf("\n");

        if (node->cmd.redirections)
        {
            print_indent(level);
            printf("  redirections:\n");
            t_ast *redir = node->cmd.redirections;
            while (redir)
            {
                print_ast_debug(redir, level + 2);
                redir = redir->bin.right; // asumimos lista ligada con bin.right
            }
        }
    }
    else if (node->type == N_REDIR)
    {
        printf("N_REDIR\n");
        print_indent(level);
        printf("  redir_type: %d\n", node->redir.redir_type);
        print_indent(level);
        printf("  filename: \"%s\"\n", node->redir.filename);
        print_indent(level);
        printf("  delimiter: \"%s\"\n", node->redir.delimiter ? node->redir.delimiter : "NULL");
        print_indent(level);
        printf("  redir_fd: %d\n", node->redir.redir_fd);
    }
    else if (node->type == N_PIPE || node->type == N_AND
             || node->type == N_OR || node->type == N_SEQUENCE
             || node->type == N_BACKGROUND)
    {
        const char *type_str = (node->type == N_PIPE) ? "N_PIPE" :
                              (node->type == N_AND) ? "N_AND" :
                              (node->type == N_OR) ? "N_OR" :
                              (node->type == N_SEQUENCE) ? "N_SEQUENCE" :
                              (node->type == N_BACKGROUND) ? "N_BACKGROUND" : "UNKNOWN";

        printf("%s\n", type_str);
        print_indent(level);
        printf("  left:\n");
        print_ast_debug(node->bin.left, level + 1);
        print_indent(level);
        printf("  right:\n");
        print_ast_debug(node->bin.right, level + 1);
    }
    else if (node->type == N_SUBSHELL)
    {
        printf("N_SUBSHELL\n");
        print_indent(level);
        printf("  child:\n");
        print_ast_debug(node->subshell.child, level + 1);

        if (node->subshell.redirections)
        {
            print_indent(level);
            printf("  redirections:\n");
            t_ast *redir = node->subshell.redirections;
            while (redir)
            {
                print_ast_debug(redir, level + 2);
                redir = redir->bin.right;
            }
        }
    }
    else
    {
        printf("Unknown node type %d\n", node->type);
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell_modes.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 12:52:57 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/22 20:48:01 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "signals.h"
//#include "exec.h"

/*
static int	run_one_command_mode(char **argv, t_shell *shell)
{
	shell->is_one_command = 1;
	shell->is_interactive = 0;
	execute_one_command(argv[2], shell);
	return (shell->exit_status);
}

static int	run_script_mode(char **argv, t_shell *shell)
{
	shell->is_script = 1;
	shell->is_interactive = 0;
	execute_script(argv[1], shell);
	return (shell->exit_status);
}

static int	handle_invalid_args(char *program_name)
{
	print_usage(program_name);
	return (2);
}
*/

int run_shell_modes(int argc, char **argv, char **envp, t_shell *shell)
{
    int ret;

    ret = handle_help_version(argc, argv);
    if (ret != -1)
        return (ret);

    if (init_env(shell, envp) != 0)
        return (1);

    shell->is_interactive = isatty(STDIN_FILENO) && isatty(STDOUT_FILENO);

    if (shell->is_interactive) {
        setup_signals();         // señales base
        run_interactive(shell);  // con prompt
    } else {
        setup_default_signals(); // señales por defecto (no prompt)
        run_non_interactive(shell);
    }
    return shell->exit_status;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 13:26:15 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 12:07:29 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* Única global permitida */
volatile sig_atomic_t g_signal = 0;

/* -------------------------------------------------------------------------- */
/*  ECHOCTL on/off: muestra los controles como ^C/^\\ si está activo.         */
/*  (No guardamos estado global adicional; simplemente forzamos el bit.)      */
/* -------------------------------------------------------------------------- */
void    set_echoctl(int enable)
{
    struct termios t;

    if (tcgetattr(STDIN_FILENO, &t) == -1)
        return;
#ifdef ECHOCTL
    if (enable)
        t.c_lflag |= ECHOCTL;
    else
        t.c_lflag &= ~ECHOCTL;
#endif
    tcsetattr(STDIN_FILENO, TCSANOW, &t);
}

/* Compat con tu código existente */
void    disable_vquit(void)   { set_echoctl(0); }
void    restore_vquit(void)   { set_echoctl(1); }

/* -------------------------------------------------------------------------- */
/*  Handler de SIGINT en el PROMPT:                                           */
/*  - Escribe salto de línea                                                  */
/*  - Limpia la línea de readline y redibuja el prompt                        */
/*  - Marca g_signal para que el bucle principal ponga exit_status=130         */
/* -------------------------------------------------------------------------- */
void    handle_sigint(int sig)
{
    (void)sig;
    g_signal = 1;
    write(STDOUT_FILENO, "\n", 1);
    rl_replace_line("", 0);
    rl_on_new_line();
    rl_redisplay();
}

/* En el prompt, Ctrl-\ no hace nada */
void    handle_sigquit(int sig)
{
    (void)sig;
    /* nada */
}

/* -------------------------------------------------------------------------- */
/*  Prompt interactivo:                                                       */
/*  - Mostrar ^C/^\ (ECHOCTL activado).                                       */
/*  - SIGINT -> handler que aborta línea.                                     */
/*  - SIGQUIT -> ignorado.                                                    */
/* -------------------------------------------------------------------------- */
void    setup_prompt_signals(void)
{
    set_echoctl(1);
    signal(SIGINT,  handle_sigint);
    signal(SIGQUIT, SIG_IGN);
}

/* Padre durante ejecución de comandos: no debe matar al hijo al pulsar ^C/^\ */
void    setup_exec_parent_signals(void)
{
    signal(SIGINT,  SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
}

/* Defaults (modo no-interactivo). También lo puedes usar si quieres resetear. */
void    setup_default_signals(void)
{
    set_echoctl(1); /* ver ^C/^\ en programas */
    signal(SIGINT,  SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
}

/* Compat: muchos sitios llaman a setup_signals() al inicio -> prompt. */
void    setup_signals(void)
{
    setup_prompt_signals();
}
# **************************************************************************** #
#                                MINISHELL MAKEFILE                            #
# **************************************************************************** #

NAME        = minishell

CC          = gcc
CFLAGS      = -Wall -Wextra -Werror -g
INCLUDES    = -Iincludes -Ilibft -Ilibft/ft_dprintf -Ilibft/gnl

LIBFT_DIR   = libft
LIBFT       = $(LIBFT_DIR)/libft.a
DPRINTF     = $(LIBFT_DIR)/ft_dprintf/libftdprintf.a

SRC_DIR     = src
OBJ_DIR     = obj

# Encuentra todos los .c en src y añade minishell.c
SRC         = $(shell find $(SRC_DIR) -name "*.c") minishell.c
OBJ         = $(SRC:%.c=$(OBJ_DIR)/%.o)

# Colores (opcional)
GREEN       := \033[0;32m
RESET       := \033[0m

# Regla para compilar objetos y crear directorios si no existen
$(OBJ_DIR)/%.o: %.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

# Regla principal: compilar y enlazar ejecutable
$(NAME): $(DPRINTF) $(LIBFT) $(OBJ)
	$(CC) $(CFLAGS) $(OBJ) $(DPRINTF) $(LIBFT) -o $(NAME) -lreadline
	@echo "$(GREEN)¡Minishell compilada y lista!$(RESET)"

# Compilar libft y dprintf
$(LIBFT):
	$(MAKE) -C $(LIBFT_DIR)

$(DPRINTF):
	$(MAKE) -C $(LIBFT_DIR)/ft_dprintf

# Limpieza de objetos y librerías
clean:
	rm -rf $(OBJ_DIR)
	$(MAKE) -C $(LIBFT_DIR) clean
	$(MAKE) -C $(LIBFT_DIR)/ft_dprintf clean

fclean: clean
	rm -f $(NAME)
	$(MAKE) -C $(LIBFT_DIR) fclean
	$(MAKE) -C $(LIBFT_DIR)/ft_dprintf fclean

re: fclean all

all: $(NAME)

.PHONY: all clean fclean re/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 12:46:24 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/25 17:17:06 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "signals.h"
//#include "exec.h"

int	main(int argc, char **argv, char **envp)
{
	t_shell	shell;
	int		ret;

//	setup_prompt_signals();
	setup_signals();
	if (init_shell_name(&shell, argv) != 0)
		return (1);
	ret = run_shell_modes(argc, argv, envp, &shell);
	cleanup_shell(&shell);
	return (ret);
}
