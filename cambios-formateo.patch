diff --git a/LucasKuhn-tester/expand_dollar.c b/LucasKuhn-tester/expand_dollar.c
index 812306d..48e3573 100644
--- a/LucasKuhn-tester/expand_dollar.c
+++ b/LucasKuhn-tester/expand_dollar.c
@@ -10,20 +10,20 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
 /* ========= helpers existentes (sin cambios de interfaz) ========= */
 
-static char *dup_program_name(t_shell *shell)
+static char	*dup_program_name(t_shell *shell)
 {
 	if (!shell || !shell->program_name)
 		return (ft_strdup("minishell"));
 	return (ft_strdup(shell->program_name));
 }
 
-static char *expand_specials(const char *s, int *i, t_shell *shell)
+static char	*expand_specials(const char *s, int *i, t_shell *shell)
 {
 	if (s[*i] == '?')
 	{
@@ -40,8 +40,8 @@ static char *expand_specials(const char *s, int *i, t_shell *shell)
 		(*i)++;
 		return (dup_program_name(shell));
 	}
-	if (s[*i] == '*' || s[*i] == '@' || s[*i] == '#'
-		|| s[*i] == '-' || s[*i] == '!')
+	if (s[*i] == '*' || s[*i] == '@' || s[*i] == '#' || s[*i] == '-'
+		|| s[*i] == '!')
 	{
 		(*i)++;
 		return (ft_strdup("")); /* vacíos en tu diseño */
@@ -54,7 +54,7 @@ static char *expand_specials(const char *s, int *i, t_shell *shell)
 	return (NULL);
 }
 
-static char *expand_name(const char *s, int *i, t_shell *shell)
+static char	*expand_name(const char *s, int *i, t_shell *shell)
 {
 	int		start;
 	char	*name;
@@ -79,60 +79,78 @@ static char *expand_name(const char *s, int *i, t_shell *shell)
    - Soporta: ${VAR}, ${?}, ${$}, ${0}, ${DIGITOS} (vacío)
    - Si falta '}', devuelve literal "${" consumiendo solo '{'
 */
-static char *expand_braced(const char *s, int *i, t_shell *shell)
+static char	*expand_braced(const char *s, int *i, t_shell *shell)
 {
-	int   j;
-	char *name;
-	char *val;
+	int		j;
+	char	*name;
+	char	*val;
+	int		start;
 
 	if (s[*i] != '{')
 		return (NULL);
-
 	j = *i + 1; /* apunta al primer char tras '{' */
-
 	/* ${} -> vacío (consumimos todo si hay '}') */
 	if (s[j] == '}')
 	{
 		*i = j + 1;
 		return (ft_strdup(""));
 	}
-
 	/* ${?} / ${$} / ${0} / ${<digits>} */
 	if (s[j] == '?')
 	{
 		j++;
-		if (s[j] == '}') { *i = j + 1; return ft_itoa(shell->exit_status); }
-		(*i)++; return ft_strdup("${"); /* degradado literal */
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (ft_itoa(shell->exit_status));
+		}
+		(*i)++;
+		return (ft_strdup("${")); /* degradado literal */
 	}
 	if (s[j] == '$')
 	{
 		j++;
-		if (s[j] == '}') { *i = j + 1; return ft_itoa(getpid()); }
-		(*i)++; return ft_strdup("${");
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (ft_itoa(getpid()));
+		}
+		(*i)++;
+		return (ft_strdup("${"));
 	}
 	if (s[j] == '0')
 	{
 		j++;
-		if (s[j] == '}') { *i = j + 1; return dup_program_name(shell); }
-		(*i)++; return ft_strdup("${");
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (dup_program_name(shell));
+		}
+		(*i)++;
+		return (ft_strdup("${"));
 	}
 	if (ft_isdigit((unsigned char)s[j]))
 	{
-		while (ft_isdigit((unsigned char)s[j])) j++;
-		if (s[j] == '}') { *i = j + 1; return ft_strdup(""); }
-		(*i)++; return ft_strdup("${");
+		while (ft_isdigit((unsigned char)s[j]))
+			j++;
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (ft_strdup(""));
+		}
+		(*i)++;
+		return (ft_strdup("${"));
 	}
-
 	/* ${VAR_NAME} */
 	if (ft_isalpha((unsigned char)s[j]) || s[j] == '_')
 	{
-		int start = j;
+		start = j;
 		while (ft_isalnum((unsigned char)s[j]) || s[j] == '_')
 			j++;
 		if (s[j] != '}')
 		{
 			(*i)++; /* consumimos solo '{' para emitir "${" y dejar continuar */
-			return ft_strdup("${");
+			return (ft_strdup("${"));
 		}
 		name = ft_substr(s, start, j - start);
 		if (!name)
@@ -144,32 +162,28 @@ static char *expand_braced(const char *s, int *i, t_shell *shell)
 			return (ft_strdup(""));
 		return (ft_strdup(val));
 	}
-
 	/* Cualquier otro patrón: tratamos como literal "${" */
 	(*i)++;
 	return (ft_strdup("${"));
 }
 
-
 /* ========= CORREGIDA: respeta $"..." y $'...' (descarta el '$') =========
    Precondición: expand_value se llama con *i en el primer carácter TRAS '$'.
    Casos:
    - $"...": quitamos el '$' y dejamos que el parser trate las comillas.
    - $'...': idem (sin implementar ANSI-C escapes).
 */
-char *expand_value(const char *s, int *i, t_shell *shell)
+char	*expand_value(const char *s, int *i, t_shell *shell)
 {
-	char *br;
-	char *sp;
-	char *nm;
+	char	*br;
+	char	*sp;
+	char	*nm;
 
 	if (!s)
 		return (ft_strdup(""));
-
 	/* Fin de cadena tras '$' -> literal "$" */
 	if (!s[*i])
 		return (ft_strdup("$"));
-
 	/* ${...} antes que el resto */
 	if (s[*i] == '{')
 	{
@@ -178,21 +192,17 @@ char *expand_value(const char *s, int *i, t_shell *shell)
 			return (br);
 		/* si no devolvió, seguimos con flujo normal */
 	}
-
 	/* Especiales: ?, $$, 0, dígitos y otros que ya defines */
 	sp = expand_specials(s, i, shell);
 	if (sp)
 		return (sp);
-
 	/* NUEVO: si lo siguiente es una comilla, descarta el '$' */
-    if (s[*i] == '"' || s[*i] == '\'')
+	if (s[*i] == '"' || s[*i] == '\'')
 		return (ft_strdup("$"));
-		
 	/* Nombre de variable clásico */
 	nm = expand_name(s, i, shell);
 	if (nm)
 		return (nm);
-
 	/* Por defecto: NO consumir el siguiente char → conserva "$" literal */
 	return (ft_strdup("$"));
 }
diff --git a/MISTEST.sh b/MISTEST.sh
index 5d9ebed..acb80e9 100755
--- a/MISTEST.sh
+++ b/MISTEST.sh
@@ -9,7 +9,6 @@ echo pasando E
 exit
 echo pasando exit
 EOF
-
 foo
 /bin/ls
 /bin/ls -laF
@@ -18,14 +17,10 @@ foo
 /bin/ls -F
 /bin/ls -la
 /bin/ls -lF
-
 /bin/ls/file_does_not_exist
-
 echo "BUILTINS"
-
 bash
 exit
-
 echo "it works"
 echo it works
 echo 'it works'
@@ -59,7 +54,6 @@ echo hola >> file
 ls
 cat file
 rm file
-
 echo $a""a
 echo $a"" a
 echo $""
@@ -78,13 +72,11 @@ echo 1 $2 $3 $4 $5 6
 echo 1 $2 $3"" $4 $5"" 6
 echo a'bc'd
 echo 'foo'bar''
-
 echo -e "\n"
 '/bin/echo hola' # una sola palabra → ruta con espacio (debe fallar)
 "/bin/echo hola" # una sola palabra (ruta+arg) → debe fallar
 /bin/echo ""
 ls -z # opción inválida → mismo error
-
 EMPTYVAR=
 echo $EMPTYVAR
 export EMPTY_VAR
@@ -92,42 +84,30 @@ echo $EMPTY_VAR
 EMPTY_VAR=ahora no estoy vacia
 unset EMPTY_VAR
 echo $EMPTY_VAR
-
 echo $SHLVL
-
-
 bash
 echo $SHLVL
 exit
 echo $?
 bash
 echo $SHLVL
-
 bash
 echo $SHLVL
-
-
 bash
 echo $SHLVL
-
 exit 1
 echo $?
 echo $SHLVL
-
 exit 123
 echo $?
 echo $SHLVL
-
 exit -n
 echo $?
 echo $SHLVL
-
-
 pwd
 VARPWD=$(pwd)
 VARUSER=$(whoami)
 echo $VARPWD
-
 cd ./
 cd .
 cd ..
@@ -137,10 +117,8 @@ pwd
 cd $VARPWD
 pwd
 cd /home/
-
 pwd
 /bin/pwd
-
 cd $VARPWD
 cd home
 cd home/
@@ -159,174 +137,130 @@ cd /home/$VARUSER
 cd ~/home/$VARUSER/
 cd ~/home/$VARUSER
 cd /absulute/path/that/does/not/exist/
-
 pwd
 /bin/pwd
-
 echo "ENV MANAGEMENT"
-
 env
 /bin/env
-
 setenv FOO=bar
 setenv HELLO="hello world"
 setenv EMPTY=""
-
 echo $FOO
 echo $HELLO
 echo $EMPTY
-
 env
 /usr/bin/env
-
 unsetenv FOO
 unsetenv HELLO
 unsetenv EMPTY
-
 echo "PATH MANAGEMENT"
-
 VARPAHTH=$PATH
 unsetenv PATH
 echo $VARPAHTH
 echo $PATH
 env
 /usr/bin/env
-
 setenv PATH=/bin:/usr/bin
 ls
 /bin/ls
-
 emacs
 /bin/emacs
 /usr/bin/emacs
 ./bin/ls
-
 unsetenv PATH
 ls
 emacs
 /bin/ls
 /usr/bin/emacs
-
 setenv PATH=$VARPAHTH
 echo $PATH
 env
 /usr/bin/env
-
 echo "COMMAND LINE MANAGEMENT"
-
 NOTHING=""
 SINGLESPACE=" "
 SPACESANDTAB="    "
 SPACES&TABBF&AFT="   /ls -l -A    "
 SPACES&TABINSIDE="ls     -l    -A"
 SPACES&TABINBDAFT="	ls -l   -A    "
-
 $NOTHING
 $SINGLESPACE
 $SPACESANDTAB
 $SPACES&TABBF&AFT
 $SPACES&TABINSIDE
 $SPACES&TABINBDAFT
-
 # create folder
 mkdir -p /tmp/bin
-
 # create the program that prints "KO"
 cat > /tmp/bin/test_exec_rights <<'EOF'
 #!/usr/bin/env bash
 echo "RIGHTS"
 EOF
-
 # set permissions to 644 (rw-r--r--)
 chmod 644 /tmp/bin/test_exec_rights
-
 # add /tmp/bin to PATH for this session (prepended so it takes precedence)
 export PATH="/tmp/bin:$PATH"
-
 ./test_exec_rights
-
 chmod 755 ./test_exec_rights
-
-echo TOP; ls; echo MIDDLE; ls; echo BOTTOM
-
-;
-
+echo TOP; ls; echo MIDDLE; ls; echo BOTTOM;
 cd $VARPWD
 cat Makefile | grep minishell | wc -l
 cat Makefile | grep noexist | wc -l
 cat noexist | wc -l
-
 asdfsdfgfdgdhghhg
-
 echo $PATH
 echo $HOME
 echo $USER
 echo $SHLVL
 echo $?
 echo $SHLVL + $?
-
 USER=false_user
 echo $USER
 echo "$USER"
-
 USER=acoronad
 echo $USER
 echo "$USER"
-
 /bin/echo hola > file.txt                    # Redirección de salida
 ls
 cat file.txt
 cat < file.txt                          # Redirección de entrada
-
 /bin/echo otra >> file.txt                   # Append
 cat file.txt
-
 cat noexiste 2> err.txt                 # Redirigir stderr
 ls
 cat err.txt
 cat noexiste
-
 ls 1> out.txt 2> err.txt                # stdout y stderr separados
 ls
 cat out.txt
 cat err.txt
-
 ls &> todo.txt                          # stdout y stderr juntos
 ls
 cat todo.txt
-
 /bin/echo hola >| file.txt                   # Redirección forzada
 cat file.txt
-
 /bin/echo hola >&1                           # Duplicar salida
-
 /bin                                   # Ejecutar un directorio → EISDIR
 ./noexistente                          # Comando no encontrado → ENOENT    ¡¡¡¡¡ESTO DEBERÍA DEVOLVER NO SUCH FILE OR DIRECTORY!!!
 ls > /no_perm                         # Sin permisos → EACCES
 /bin/echo hola > /root/test.txt            # EACCES por falta de permisos
-
 /bin/echo uno && /bin/echo dos
 /bin/false || /bin/echo se ejecuta
 false && /bin/echo no se ejecuta
 /bin/echo uno; /bin/echo dos
 (/bin/echo subshell)
 (/bin/echo uno && /bin/echo dos)
-
 /bin/echo hola > out.txt && cat < out.txt
 lh
 cat out.txt
 rm out.txt
-
 /bin/echo err > /tmp/test 2>> /tmp/test						#Como es evidente, hay que comprobar el documento test en la carpeta tmp
 cat /tmp/test
 rm /tmp/test
-
 (/bin/echo hola > hola.txt; cat hola.txt)
 rm hola.txt
-
 /bin/echo exportando; /usr/bin/env | /usr/bin/grep TEST
 /bin/echo exportando; /usr/bin/env | /usr/bin/grep HOME
-
 '/bin/echo hola'               # Comillas simples sin expansión
 /bin/echo hola\ mundo          # Escape
 echo uno\ dos\ tres				# Esperado: uno dos tres
@@ -350,28 +284,22 @@ cat pipe_output.txt
 rm pipe_output.txt
 (/bin/echo uno; /bin/echo dos) && /bin/echo tres || /bin/echo cuatro
 /bin/echo uno; /bin/echo dos | grep dos
-
 #  /bin/echo $HOME "$PATH" hola\ mundo  uno\ dos\ tres signo\? interrogacion barra\|vertical barra\\invertida  comilla\'simple comilla\"doble "comilla\"doble" 'comilla\'simple'' expansion\$USER 
-
 cat << EOF
 linea 1
 linea 2
 EOF
-
 cat << 'EOF'
 $HOME no debe expandirse
 EOF
-
 /bin/echo heredoc >> prueba.txt << EOF     ¡¡¡¡¡¡¡¡¡ TODO TIPO DE PROBLEMAS CON EOF !!!!!!!
 esto
 es
 una
 prueba
 EOF
-
 cat prueba.txt
 rm prueba.txt
-
  /usr/bin/env | /usr/bin/grep TEST'
 /usr/bin/env | /usr/bin/grep HOME'
 
diff --git a/copyminishell b/copyminishell
deleted file mode 100644
index 3f76bec..0000000
--- a/copyminishell
+++ /dev/null
@@ -1,4998 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast.h                                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 15:24:41 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 19:36:13 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef AST_H
-# define AST_H
-
-/* Evitamos ciclos: no necesitamos lexer.h aquí, con una forward declaration basta. */
-typedef struct s_token t_token;   /* <- forward declaration clave */
-typedef struct s_ast   t_ast;
-typedef struct s_shell t_shell;
-
-# include "minishell.h"
-# include "env.h"
-# include "parser.h"
-
-typedef enum e_node_type
-{
-    N_COMMAND,
-    N_PIPE,
-    N_REDIR,
-    N_SUBSHELL,
-    N_SEQUENCE,
-    N_AND,
-    N_OR,
-    N_BACKGROUND
-}   t_node_type;
-
-typedef enum e_redir_type
-{
-        REDIR_IN,
-        REDIR_OUT,
-        REDIR_APPEND,
-        REDIR_HEREDOC,
-        REDIR_ERR,
-        REDIR_APPEND_ERR,
-        REDIR_ALL,
-        REDIR_APPEND_ALL,
-        REDIR_FORCE,
-        REDIR_DUP_IN,
-        REDIR_DUP_OUT,
-        REDIR_INVALID
-}       t_redir_type;
-
-struct s_ast
-{
-    t_node_type type;
-
-    union
-    {
-        struct
-        {
-            char        **argv;
-            struct s_ast *redirections; // lista ligada de N_REDIR
-        } cmd;
-
-        struct
-        {
-            char        *filename;
-            char        *delimiter;
-            t_redir_type redir_type;
-            int         redir_fd;
-        } redir;
-
-        struct
-        {
-            struct s_ast *left;
-            struct s_ast *right;
-        } bin;
-
-        struct
-        {
-            struct s_ast *child;
-            struct s_ast *redirections;
-        } subshell;
-    };
-};
-
-/* Constructores */
-t_ast   *ast_new_command(char **argv, t_ast *redirections);
-t_ast   *ast_new_redir(char *filename, char *delimiter,
-                       t_redir_type redir_type, int redir_fd);
-t_ast   *ast_new_binary(t_node_type type, t_ast *left, t_ast *right);
-t_ast   *ast_new_subshell(t_ast *child, t_ast *redirections);
-t_ast   *create_command_node(char **argv, t_ast *redir_list_head);
-
-/* Otros */
-t_ast   *ast_copy(t_ast *node);
-void    free_ast(t_ast *node);
-void    free_ast_recursive(t_ast *node);
-int     check_syntax(t_ast *node);
-int     is_lparen(t_token *tok);
-t_ast   *build_ast(t_token *tokens);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast.h                                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 15:24:41 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 15:26:54 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef AST_H
-# define AST_H
-
-/* Evitamos ciclos: no necesitamos lexer.h aquí, con una forward declaration basta. */
-typedef struct s_token t_token;   /* <- forward declaration clave */
-typedef struct s_ast   t_ast;
-typedef struct s_shell t_shell;
-
-# include "minishell.h"
-# include "env.h"
-# include "parser.h"
-
-typedef enum e_node_type
-{
-    N_COMMAND,
-    N_PIPE,
-    N_REDIR,
-    N_SUBSHELL,
-    N_SEQUENCE,
-    N_AND,
-    N_OR,
-    N_BACKGROUND
-}   t_node_type;
-
-typedef enum e_redir_type
-{
-        REDIR_IN,
-        REDIR_OUT,
-        REDIR_APPEND,
-        REDIR_HEREDOC,
-        REDIR_ERR,
-        REDIR_APPEND_ERR,
-        REDIR_ALL,
-        REDIR_APPEND_ALL,
-        REDIR_FORCE,
-        REDIR_DUP_IN,
-        REDIR_DUP_OUT,
-        REDIR_INVALID
-}       t_redir_type;
-
-struct s_ast
-{
-    t_node_type type;
-
-    union
-    {
-        struct
-        {
-            char        **argv;
-            struct s_ast *redirections; // lista ligada de N_REDIR
-        } cmd;
-
-        struct
-        {
-            char        *filename;
-            char        *delimiter;
-            t_redir_type redir_type;
-            int         redir_fd;
-        } redir;
-
-        struct
-        {
-            struct s_ast *left;
-            struct s_ast *right;
-        } bin;
-
-        struct
-        {
-            struct s_ast *child;
-            struct s_ast *redirections;
-        } subshell;
-    };
-};
-
-/* Constructores */
-t_ast   *ast_new_command(char **argv, t_ast *redirections);
-t_ast   *ast_new_redir(char *filename, char *delimiter,
-                       t_redir_type redir_type, int redir_fd);
-t_ast   *ast_new_binary(t_node_type type, t_ast *left, t_ast *right);
-t_ast   *ast_new_subshell(t_ast *child, t_ast *redirections);
-t_ast   *create_command_node(char **argv, t_ast *redir_list_head);
-
-/* Otros */
-t_ast   *ast_copy(t_ast *node);
-void    free_ast(t_ast *node);
-void    free_ast_recursive(t_ast *node);
-int     check_syntax(t_ast *node);
-int     is_lparen(t_token *tok);
-t_ast   *build_ast(t_token *tokens);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   builtins.h                                         :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:31:23 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:32:47 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef BUILTINS_H
-#define BUILTINS_H
-
-#include "minishell.h"
-#include "ast.h"
-#include "exec.h"
-
-int	is_builtin(const char *cmd);
-int	run_builtin(t_ast *node, t_shell *shell);
-int	run_echo(char **argv);
-int	run_cd(char **argv, t_shell *shell);
-int	run_pwd(void);
-int	run_export(char **argv, t_shell *shell);
-int	run_unset(char **argv, t_shell *shell);
-int	run_env(t_shell *shell);
-int	run_exit(char **argv, t_shell *shell);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   env.h                                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/27 19:37:31 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/22 13:26:00 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef ENV_H
-# define ENV_H
-
-# include "minishell.h"
-
-typedef struct s_shell t_shell;
-typedef struct s_env t_env;
-
-// --- Prototipos de funciones de init_env_list.c ---
-t_env   *init_env_list(char **envp);
-t_env	*env_create(char *key, char *value, int exported);
-void	env_add_back(t_env **env, t_env *new);
-
-// --- Prototipos de funciones de env_free.c ---
-void    free_env_list(t_env *env);
-
-// --- Prototipos de funciones de manipulación de env ---
-char	*get_env_value(t_shell *shell, const char *key);
-char	**env_to_array(t_env *env);
-
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   exec.h                                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:08:04 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:00:07 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef EXEC_H
-# define EXEC_H
-
-# include "minishell.h"
-# include "ast.h"
-# include <sys/types.h>
-
-/* Ejecución del AST */
-int	execute_ast(t_ast *node, t_shell *shell);
-int	execute_command(t_ast *node, t_shell *shell);
-int	execute_pipe(t_ast *node, t_shell *shell);
-int	execute_and(t_ast *node, t_shell *shell);
-int	execute_or(t_ast *node, t_shell *shell);
-int	execute_subshell(t_ast *node, t_shell *shell);
-int	execute_sequence(t_ast *node, t_shell *shell);
-int	execute_background(t_ast *node, t_shell *shell);
-
-/* Redirecciones */
-int	open_redirection(t_ast *redir);
-int	handle_simple_redir(t_ast *redir);
-int	apply_redirections(t_ast *redir_list);
-
-/* Heredoc */
-int	heredoc_prepare(const char *delimiter);
-
-/* Auxiliares */
-void	restore_std_fds(int original_stdin, int original_stdout, int original_stderr);
-char	*join_path(const char *dir, const char *file);
-int		is_executable(char *path);
-char	*find_executable(char *cmd, t_shell *shell);
-
-/* Errores */
-int		print_exec_error(t_shell *shell, const char *cmd, int err_code);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   expand.h                                           :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/27 20:17:25 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:31:54 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef EXPAND_H
-# define EXPAND_H
-
-# include "minishell.h"
-# include "env.h"
-
-/* expand.c */
-int     expand_variables(t_shell *shell);
-char    *expand_token(const char *str, t_shell *shell);
-
-/* expand_dollar.c */
-char    *expand_value(const char *str, int *i, t_shell *shell);
-int     handle_dollar(const char *str, int *i, char *dst, int j, t_shell *shell);
-
-/* calculate_expand_len.c */
-size_t  calculate_expanded_len(const char *str, t_shell *shell);
-size_t  handle_dollar_len(const char *str, int *i, t_shell *shell);
-
-/* handle_expand_cases.c */
-size_t  handle_pid_len(void);
-size_t  handle_exit_status_len(t_shell *shell);
-char    *get_program_name_str(t_shell *shell);
-
-/* expand_tilde.c */
-char    *expand_tilde_internal(const char *str, t_shell *shell);
-size_t  get_tilde_prefix_len(const char *str);
-
-/* expand_utils.c */
-char    *find_var(t_env *env, char *name);
-
-/* quote_removal.c */
-void    remove_quotes(t_token *tokens);
-
-/* word_splitting.c */
-void    perform_word_splitting(t_shell *shell);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer.h                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 15:24:24 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/31 16:22:50 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef LEXER_H
-# define LEXER_H
-
-/* Importante: NO incluir minishell.h aquí para evitar ciclos. */
-/* Incluye solo lo mínimo estrictamente necesario. */
-# include <stddef.h>
-
-/* ------------------------- Tipos de token ------------------------- */
-typedef enum e_token_type
-{
-        T_WORD,
-        T_PIPE,         // |
-        T_OR,           // ||
-        T_AND,          // &&
-        T_BG,           // &
-        T_SEMI,         // ;
-        T_REDIR_IN,     // <
-        T_REDIR_OUT,    // >
-        T_APPEND,       // >>
-        T_HEREDOC,      // <<
-        T_REDIR_ERR,    // 2>
-        T_APPEND_ERR,   // 2>>
-        T_REDIR_ALL,    // &>
-        T_APPEND_ALL,   // &>>
-        T_FORCE_OUT,    // >|
-        T_HEREDOC_STR,  // <<< (Bash-specific)
-        T_DUP_IN,       // <&
-        T_DUP_OUT,      // >&
-        T_LPAREN,       // (
-        T_RPAREN,       // )
-        T_LBRACE,       // {
-        T_RBRACE,       // }
-        T_EQUAL,        // =
-        T_UNKNOWN
-}       t_token_type;
-
-typedef enum e_quote
-{
-        NO_QUOTE,
-        SINGLE_QUOTE,
-        DOUBLE_QUOTE
-}       t_quote;
-
-typedef struct s_token
-{
-        char            *value;     /* texto literal (incluye comillas si las hay) */
-        t_token_type    type;
-        t_quote         quoted;     /* comillado delimitador del token (si aplica) */
-        struct s_token  *next;
-}       t_token;
-
-/* ------------------------- API del lexer ------------------------- */
-t_token         *lexer(const char *line);
-
-/* Construcción/gestión de lista */
-t_token         *token_new(char *value, t_token_type type, t_quote quote);
-void            token_addback(t_token **lst, t_token *new);
-void            free_token_list(t_token *tok);
-void            next_token(t_token **cur);
-
-/* Funciones de extracción */
-int             get_operator(const char *line, int i, t_token **lst);
-int             get_word(const char *line, int i, t_token **lst);
-
-/* Detección y utilidades */
-int             is_operator(const char *str, t_token_type *type, int *len);
-t_token_type    get_token_type(const char *str, int len);
-t_token_type    get_pipe_and_or(const char *str, int len);
-t_token_type    get_semi_redir_left(const char *str, int len);
-t_token_type    get_redir_right(const char *str, int len);
-t_token_type    get_redir_special(const char *str, int len);
-
-void            free_lexer_list_on_error(t_token **lst);
-int             try_add_token(t_token **lst, char *str, t_token_type type, t_quote quote);
-
-/* Utilidades específicas de bash */
-void            strip_comment_if_applicable(char *line);
-char            *remove_backslashes_for_token(const char *src, t_quote quote);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   minishell.h                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/10 13:10:22 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 03:11:47 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef MINISHELL_H
-# define MINISHELL_H
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <fcntl.h>
-#include <readline/readline.h>
-#include <readline/history.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <signal.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <termios.h>
-#include <errno.h>
-#include <linux/limits.h>
-#include <limits.h>
-#include "libft.h"
-#include "env.h"
-#include "lexer.h"
-#include "parser.h"
-#include "ast.h"
-#include "exec.h"
-#include "builtins.h"
-#include "signals.h"
-
-typedef struct s_ast t_ast;
-typedef struct s_shell t_shell;
-typedef struct s_token t_token;
-
-typedef struct s_env
-{
-    char            *key;
-    char            *value;
-    struct s_env    *next;
-	int             exported;
-}                   t_env;
-
-typedef struct s_shell
-{
-        t_env           *env;
-        char            *line;
-        t_token         *tokens;
-        t_ast           *ast;
-        int             exit_status;
-		int				in_child;  // 0 por defecto; en hijos se pone a 1 antes de ejecutar AST
-        int             is_interactive;
-        int             is_script;
-        int             is_one_command;
-        int             should_exit;
-        char            *program_name;
-        int             pid; // PID del shell actual (¡Correcto! Usado para $$, $BASHPID)
-}       t_shell;
-
-extern volatile sig_atomic_t   g_signal;
-// Shell modes and flags
-int		run_shell_modes(int argc, char **argv, char **envp, t_shell *shell);
-
-// Inicialización y limpieza del shell
-int		init_shell_name(t_shell *shell, char **argv);
-int		init_env(t_shell *shell, char **envp);
-void    cleanup_shell(t_shell *shell);
-void    cleanup_loop(t_shell *shell);
-int		print_exec_error(t_shell *shell, const char *cmd, int err_code);
-
-// Funciones de ayuda/uso/version
-void	print_help(void);
-void	print_usage(const char *invalid);
-void	print_version(void);
-int		handle_help_version(int argc, char **argv);
-
-// Ejecución principal del shell
-void	prueba_lexer(t_shell *shell);
-void	prueba_env(t_shell *shell);
-void	prueba_expansion(t_shell *shell);
-void	prueba_ast(t_shell *shell);
-void	print_ast_debug(t_ast *node, int level);
-
-int		shell_exec(t_shell *shell);
-//void	parse_and_execute(t_shell *shell);
-//int		check_syntax(t_ast *ast);
-
-// --- Modos ---
-int   run_shell_modes(int argc, char **argv, char **envp, t_shell *shell);
-void  run_interactive(t_shell *shell);
-void  run_non_interactive(t_shell *shell);   // NUEVO
-
-// --- Lectura de línea ---
-char *read_line_interactive(t_shell *shell); // RENOMBRE de read_full_line
-// en no-interactivo leeremos con get_next_line o similar (o readline sin prompt)
-
-#endif/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parser.h                                           :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 19:07:19 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 15:27:05 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef PARSER_H
-# define PARSER_H
-
-/* Evitamos ciclos: no necesitamos lexer.h aquí si solo usamos punteros. */
-typedef struct s_token t_token;   /* <- forward declaration */
-typedef struct s_ast   t_ast;
-typedef struct s_shell t_shell;
-
-# include "minishell.h"
-# include "ast.h"
-# include "env.h"
-
-/* Prototipos relacionados con redirecciones y parsing */
-int     is_redirection(t_token *tok);
-int     parse_redirections(t_token **cur, t_ast **head, t_ast **tail);
-t_ast   *make_redir_node(t_token *redir_token, t_token *filename_token);
-t_ast   *parse_sequence(t_token **cur);
-t_ast   *parse_and_or(t_token **cur);
-t_ast   *parser_line(t_shell *shell);
-t_ast   *parse_pipeline(t_token **cur);
-t_ast   *parse_background(t_token **cur);
-t_ast   *parse_command_and_redirections(t_token **cur);
-t_ast   *parse_subshell(t_token **cur);
-char    **parse_arguments(t_token **cur);
-
-/* Comandos simples / subshells */
-t_ast   *parse_simple_command(t_token **cur);
-t_ast   *parse_subshell(t_token **cur);
-char    **parse_arguments(t_token **cur);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   signals.h                                          :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/17 08:56:24 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 12:07:10 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef SIGNALS_H
-# define SIGNALS_H
-
-# include "minishell.h"
-
-/* ÚNICA variable global permitida del proyecto */
-extern volatile sig_atomic_t g_signal;
-
-/* Prompt (interactivo): ^C aborta la línea, ^\ se ignora. */
-void    setup_prompt_signals(void);
-
-/* En el PADRE mientras se ejecutan comandos: ignorar INT/QUIT. */
-void    setup_exec_parent_signals(void);
-
-/* Para modo no-interactivo o para restaurar defaults explícitamente. */
-void    setup_default_signals(void);
-
-/* Alias de compatibilidad: inicializa señales de prompt. */
-void    setup_signals(void);
-
-/* Handlers del prompt */
-void    handle_sigint(int sig);
-void    handle_sigquit(int sig);
-
-/* TTY: controlar si el terminal muestra ^C / ^\ (ECHOCTL). */
-void    set_echoctl(int enable);
-
-/* Compat: usados en tu código existente (simple envoltorio de set_echoctl) */
-void    disable_vquit(void);   /* oculta ^C/^\\ en el prompt si quisieras */
-void    restore_vquit(void);   /* vuelve a mostrar ^C/^\\ */
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast_utils.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 19:53:28 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/28 03:50:45 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-	#include "minishell.h"
-	#include "ast.h"
-
-	t_ast *ast_new_command(char **argv, t_ast *redirections)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = N_COMMAND;
-		node->cmd.argv = argv;
-		node->cmd.redirections = redirections;
-		return (node);
-	}
-
-	t_ast *ast_new_redir(char *filename, char *delimiter,
-						t_redir_type type, int redir_fd)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = N_REDIR;
-		node->redir.filename = filename;
-		node->redir.delimiter = delimiter;
-		node->redir.redir_type = type;
-		node->redir.redir_fd = redir_fd;
-		return (node);
-	}
-
-	t_ast *ast_new_binary(t_node_type type, t_ast *left, t_ast *right)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = type;
-		node->bin.left = left;
-		node->bin.right = right;
-		return (node);
-	}
-
-	t_ast *ast_new_subshell(t_ast *child, t_ast *redirections)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = N_SUBSHELL;
-		node->subshell.child = child;
-		node->subshell.redirections = redirections;
-		return (node);
-	}
-
-	t_ast	*create_command_node(char **argv, t_ast *redir_list_head)
-	{
-		t_ast	*cmd;
-
-		cmd = ast_new_command(argv, redir_list_head);
-		if (!cmd)
-			return (NULL);
-		return (cmd);
-	}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   build_ast.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 18:36:06 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/03 10:42:33 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-
-/*
-** Función principal del parser: construye el AST a partir de la lista de tokens.
-** Devuelve la raíz del AST o NULL en caso de error.
-*/
-t_ast   *build_ast(t_token *tokens)
-{
-    t_token *cur;
-    t_ast   *tree;
-
-    cur = tokens;
-    tree = parse_background(&cur); // Llama a la función de más alta precedencia
-    if (!tree)
-        return (NULL);
-    
-    // Si quedan tokens sin procesar, es un error de sintaxis que las funciones de abajo
-    // no capturaron porque no formaban parte de ninguna regla sintáctica esperada.
-    // Esto es muy importante para detectar cosas como "ls && ;" o "echo hello world extra_stuff"
-    // donde "extra_stuff" no es parte de la sintaxis válida después de un comando simple.
-    if (cur != NULL) // <-- Esta condición es correcta para detectar tokens no consumidos
-    {
-        ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n", cur->value);
-        free_ast(tree);
-        return (NULL);
-    }
-    return (tree);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   free_ast.c                                         :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/28 02:30:28 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/28 03:56:18 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "ast.h"
-#include "parser.h"
-#include "lexer.h"
-
-// Libera solo un nodo, sin liberar hijos ni cadenas externas
-void free_ast(t_ast *node)
-{
-    if (!node)
-        return;
-
-    if (node->type == N_COMMAND)
-    {
-        if (node->cmd.argv)
-            ft_free_strtab(node->cmd.argv); // función para liberar char** argv
-        // redirections NO se liberan aquí, porque pueden ser compartidas o liberadas en free_ast_recursive
-    }
-    else if (node->type == N_REDIR)
-    {
-        if (node->redir.filename)
-            free(node->redir.filename);
-        if (node->redir.delimiter)
-            free(node->redir.delimiter);
-    }
-    // No libera punteros a hijos (bin, subshell), solo el nodo actual
-    free(node);
-}
-
-// Libera el árbol entero recursivamente (incluye hijos y redirecciones)
-void free_ast_recursive(t_ast *node)
-{
-    if (!node)
-        return;
-    if (node->type == N_COMMAND)
-    {
-        free_ast_recursive(node->cmd.redirections);
-        if (node->cmd.argv)
-            ft_free_strtab(node->cmd.argv);
-    }
-    else if (node->type == N_REDIR)
-    {
-        if (node->redir.filename)
-            free(node->redir.filename);
-        if (node->redir.delimiter)
-            free(node->redir.delimiter);
-    }
-    else if (node->type == N_SUBSHELL)
-    {
-        free_ast_recursive(node->subshell.child);
-        free_ast_recursive(node->subshell.redirections);
-    }
-    else // para nodos binarios (PIPE, SEQUENCE, AND, OR, BACKGROUND)
-    {
-        free_ast_recursive(node->bin.left);
-        free_ast_recursive(node->bin.right);
-    }
-    free(node);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   cd_builtin.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:25:12 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:25:37 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-#include "env.h"
-
-// ----------- CD -----------
-int	run_cd(char **argv, t_shell *shell)
-{
-	const char	*path;
-	char		*home;
-
-	path = argv[1];
-	if (!path)
-	{
-		home = get_env_value(shell, "HOME");
-		if (!home)
-		{
-			ft_putstr_fd("minishell: cd: HOME not set\n", 2);
-			return (1);
-		}
-		path = home;
-	}
-	if (chdir(path) == -1)
-	{
-		ft_putstr_fd("minishell: cd: ", 2);
-		ft_putstr_fd((char *)path, 2);
-		ft_putstr_fd(": No such file or directory\n", 2);
-		return (1);
-	}
-	return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   echo_builtin.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:22:50 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 18:32:53 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-
-static int  is_all_n(const char *s)
-{
-    int i;
-
-    if (!s || s[0] != '-')
-        return 0;
-    i = 1;
-    if (s[i] == '\0')
-        return 0;              // solo "-" no cuenta
-    while (s[i])
-    {
-        if (s[i] != 'n')
-            return 0;
-        i++;
-    }
-    return 1;                  // "-n", "-nn", "-nnn", ...
-}
-
-int run_echo(char **argv)
-{
-    int i;
-    int no_newline;
-    int first_arg_printed;
-
-    i = 1;
-    no_newline = 0;
-    while (argv[i] && is_all_n(argv[i]))
-    {
-        no_newline = 1;
-        i++;
-    }
-
-    first_arg_printed = 0;
-    while (argv[i])
-    {
-        if (first_arg_printed)
-            write(1, " ", 1);
-        write(1, argv[i], ft_strlen(argv[i]));
-        first_arg_printed = 1;
-        i++;
-    }
-
-    if (!no_newline)
-        write(1, "\n", 1);
-    return 0;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   env_builtin.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:26:03 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:26:22 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-#include "env.h"
-
-// ----------- ENV -----------
-int	run_env(t_shell *shell)
-{
-	t_env	*env;
-
-	env = shell->env;
-	while (env)
-	{
-		if (env->exported && env->value)
-		{
-			ft_putstr_fd(env->key, 1);
-			ft_putchar_fd('=', 1);
-			ft_putendl_fd(env->value, 1);
-		}
-		env = env->next;
-	}
-	return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   exit_builtin.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:28:12 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:31:54 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-
-// ----------- EXIT -----------
-
-int	run_exit(char **argv, t_shell *shell)
-{
-	long	code;
-
-	ft_putstr_fd("exit\n", 1);
-	if (!argv[1])
-		exit(shell->exit_status);
-	if (!ft_isnumeric(argv[1]))
-	{
-		ft_dprintf(2, "minishell: exit: %s: numeric argument required\n", argv[1]);
-		exit(255);
-	}
-	if (argv[2])
-	{
-		ft_dprintf(2, "minishell: exit: too many arguments\n");
-		shell->exit_status = 1;
-		return (1);
-	}
-	code = ft_atol(argv[1]);
-	code = code & 255;
-	exit((int)code);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   export_builtin.c                                   :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:26:37 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:27:03 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-#include "env.h"
-
-// ----------- EXPORT -----------
-static int	valid_export_key(const char *key)
-{
-	int	i;
-
-	i = 0;
-	if (!key || !ft_isalpha(key[0]))
-		return (0);
-	while (key[i])
-	{
-		if (!ft_isalnum(key[i]) && key[i] != '_')
-			return (0);
-		i++;
-	}
-	return (1);
-}
-
-int	run_export(char **argv, t_shell *shell)
-{
-	int		i;
-	char	*sep;
-	char	*key;
-	char	*value;
-	t_env	*envv;
-
-	i = 1;
-	while (argv[i])
-	{
-		sep = ft_strchr(argv[i], '=');
-		if (sep)
-		{
-			key = ft_substr(argv[i], 0, sep - argv[i]);
-			value = ft_strdup(sep + 1);
-			if (valid_export_key(key))
-			{
-				envv = shell->env;
-				while (envv)
-				{
-					if (ft_strcmp(envv->key, key) == 0)
-					{
-						free(envv->value);
-						envv->value = ft_strdup(value);
-						envv->exported = 1;
-						break ;
-					}
-					envv = envv->next;
-				}
-				if (!envv)
-					env_add_back(&shell->env, env_create(key, value, 1));
-			}
-			else
-				ft_dprintf(2, "minishell: export: `%s': not a valid identifier\n", key);
-			free(key);
-			free(value);
-		}
-		else if (valid_export_key(argv[i]))
-		{
-			envv = shell->env;
-			while (envv)
-			{
-				if (ft_strcmp(envv->key, argv[i]) == 0)
-				{
-					envv->exported = 1;
-					break ;
-				}
-				envv = envv->next;
-			}
-			if (!envv)
-				env_add_back(&shell->env, env_create(argv[i], "", 1));
-		}
-		else
-			ft_dprintf(2, "minishell: export: `%s': not a valid identifier\n", argv[i]);
-		i++;
-	}
-	return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   is_builtin.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:38:44 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/29 15:51:53 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "builtins.h"
-
-int	is_builtin(const char *cmd)
-{
-	if (!cmd)
-		return (0);
-	if (ft_strcmp(cmd, "echo") == 0
-		|| ft_strcmp(cmd, "cd") == 0
-		|| ft_strcmp(cmd, "pwd") == 0
-		|| ft_strcmp(cmd, "export") == 0
-		|| ft_strcmp(cmd, "unset") == 0
-		|| ft_strcmp(cmd, "env") == 0
-		|| ft_strcmp(cmd, "exit") == 0)
-		return (1);
-	return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   pwd_builtin.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:24:17 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:30:00 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-
-// ----------- PWD -----------
-int	run_pwd(void)
-{
-	char	buf[PATH_MAX];
-
-	if (getcwd(buf, PATH_MAX))
-	{
-		ft_putendl_fd(buf, 1);
-		return (0);
-	}
-	ft_putstr_fd("minishell: pwd: error retrieving current directory\n", 2);
-	return (1);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   run_builtin.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:44:03 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:35:45 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "ast.h"
-#include "exec.h"
-#include "builtins.h"
-
-int run_builtin(t_ast *node, t_shell *shell)
-{
-	char **argv;
-
-	if (!node || !node->cmd.argv || !node->cmd.argv[0])
-		return (1);
-	argv = node->cmd.argv;
-	if (ft_strcmp(argv[0], "echo") == 0)
-		return (run_echo(argv));
-	if (ft_strcmp(argv[0], "cd") == 0)
-		return (run_cd(argv, shell));
-	if (ft_strcmp(argv[0], "pwd") == 0)
-		return (run_pwd());
-	if (ft_strcmp(argv[0], "export") == 0)
-		return (run_export(argv, shell));
-	if (ft_strcmp(argv[0], "unset") == 0)
-		return (run_unset(argv, shell));
-	if (ft_strcmp(argv[0], "env") == 0)
-		return (run_env(shell));
-	if (ft_strcmp(argv[0], "exit") == 0)
-		return (run_exit(argv, shell));
-	return (1);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   unset_builtin.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/04 12:27:13 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/04 12:27:44 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "builtins.h"
-
-// ----------- UNSET -----------
-int	run_unset(char **argv, t_shell *shell)
-{
-	int		i;
-	t_env	*prev;
-	t_env	*cur;
-
-	i = 1;
-	while (argv[i])
-	{
-		prev = NULL;
-		cur = shell->env;
-		while (cur)
-		{
-			if (ft_strcmp(cur->key, argv[i]) == 0)
-			{
-				if (prev)
-					prev->next = cur->next;
-				else
-					shell->env = cur->next;
-				free(cur->key);
-				free(cur->value);
-				free(cur);
-				break ;
-			}
-			prev = cur;
-			cur = cur->next;
-		}
-		i++;
-	}
-	return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   env_get_value.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:53:52 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/29 14:58:09 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "env.h"
-
-char	*get_env_value(t_shell *shell, const char *key)
-{
-	t_env	*env;
-
-	if (!shell || !key)
-		return (NULL);
-	env = shell->env;
-	while (env)
-	{
-		if (env->key && !ft_strcmp(env->key, key))
-			return (env->value);
-		env = env->next;
-	}
-	return (NULL);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   free_env_list.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 15:32:52 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/27 19:51:04 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "env.h"
-
-/*
-** free_env_list
-** Libera toda la memoria de la lista enlazada de variables de entorno (t_env).
-** - Recorre la lista nodo por nodo, liberando 'key', 'value' y el propio nodo.
-** - Al finalizar, todos los elementos de la lista quedan correctamente liberados.
-**
-** Parámetros:
-**   env: puntero al inicio de la lista enlazada de entorno (t_env*)
-**
-** Uso:
-**   Llama a esta función al salir de la shell o cuando debas liberar todo el entorno.
-*/
-void	free_env_list(t_env *env)
-{
-	t_env	*tmp;
-
-	while (env)
-	{
-		tmp = env->next;
-		if (env->key)
-			free(env->key);
-		if (env->value)
-			free(env->value);
-		free(env);
-		env = tmp;
-	}
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   get_env_array.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 15:35:01 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/29 15:55:08 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "env.h"
-
-static int	env_count(t_env *env)
-{
-	int	count;
-
-	count = 0;
-	while (env)
-	{
-		if (env->exported)
-			count++;
-		env = env->next;
-	}
-	return (count);
-}
-
-static char	*join_key_value(const char *key, const char *value)
-{
-	char	*tmp;
-	char	*res;
-
-	tmp = ft_strjoin(key, "=");
-	if (!tmp)
-		return (NULL);
-	res = ft_strjoin(tmp, value);
-	free(tmp);
-	return (res);
-}
-
-char	**env_to_array(t_env *env)
-{
-	char	**env_array;
-	int		size;
-	int		i;
-
-	size = env_count(env);
-	env_array = (char **)ft_calloc(size + 1, sizeof(char *));
-	if (!env_array)
-		return (NULL);
-	i = 0;
-	while (env && i < size)
-	{
-		if (env->exported)
-		{
-			env_array[i] = join_key_value(env->key, env->value);
-			if (!env_array[i])
-			{
-				ft_free_strtab(env_array);
-				return (NULL);
-			}
-			i++;
-		}
-		env = env->next;
-	}
-	env_array[i] = NULL;
-	return (env_array);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   init_env_list.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/27 14:42:10 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/27 20:01:59 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   init_env_list.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 15:28:27 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/26 06:18:34 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "env.h"
-
-/*
-** Crea un nuevo nodo de variable de entorno (t_env).
-** - key: nombre de la variable (ej: "USER")
-** - value: valor de la variable (ej: "acoronadx")
-** - exported: 1 si la variable está exportada, 0 si es local/interna
-** Devuelve un puntero al nuevo nodo, o NULL si falla el malloc.
-** El campo .next se inicializa a NULL.
-*/
-t_env	*env_create(char *key, char *value, int exported)
-{
-	t_env	*new;
-
-	new = (t_env *)malloc(sizeof(t_env));
-	if (!new)
-		return (NULL);
-	new->key = ft_strdup(key);
-	if (value)
-		new->value = ft_strdup(value);
-	else
-		new->value = NULL;
-	new->exported = exported;
-	new->next = NULL;
-	return (new);
-}
-
-/*
-** Añade un nodo t_env al final de la lista de entorno.
-** - *env: puntero al inicio de la lista (puede ser NULL si está vacía)
-** - new: nuevo nodo a añadir
-** Si la lista está vacía, pone el nuevo como primer elemento.
-** Si no, recorre la lista y lo añade al final.
-** No hace nada si alguno de los punteros es NULL.
-*/
-
-void	env_add_back(t_env **env, t_env *new)
-{
-	t_env	*tmp;
-
-	if (!env || !new)
-		return ;
-	if (!*env)
-		*env = new;
-	else
-	{
-		tmp = *env;
-		while (tmp->next)
-			tmp = tmp->next;
-		tmp->next = new;
-	}
-}
-
-/*
-** Inicializa la lista enlazada de entorno (t_env) a partir del array envp.
-** - envp: array de strings "KEY=VALUE" que viene de main().
-** Por cada string, separa la clave y el valor, crea un nodo y lo añade a la lista.
-** Marca todas las variables como exportadas (exported = 1).
-** Devuelve el inicio de la lista, o NULL si falla algún malloc.
-** Ejemplo de uso: shell->env = init_env_list(envp);
-*/
-static t_env	*create_exported_env_var(char *str, t_env **env)
-{
-	char	*sep;
-	char	*key;
-	t_env	*new;
-
-	sep = ft_strchr(str, '=');
-	key = ft_substr(str, 0, sep - str);
-	if (!key)
-	{
-		free_env_list(*env);
-		return (NULL);
-	}
-	new = env_create(key, sep + 1, 1);
-	free(key);
-	if (!new)
-	{
-		free_env_list(*env);
-		return (NULL);
-	}
-	env_add_back(env, new);
-	return (*env);
-}
-
-t_env	*init_env_list(char **envp)
-{
-	t_env	*env;
-	int		i;
-
-	env = NULL;
-	i = 0;
-	while (envp[i])
-	{
-		if (ft_strchr(envp[i], '='))
-		{
-			if (!create_exported_env_var(envp[i], &env))
-				return (NULL);
-		}
-		i++;
-	}
-	return (env);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_and_or.c                                   :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:49:04 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-int execute_and(t_ast *node, t_shell *shell)
-{
-    int ret;
-
-    ret = execute_ast(node->bin.left, shell);
-    if (ret == 0)
-        ret = execute_ast(node->bin.right, shell);
-    else
-        shell->exit_status = ret;
-    return (ret);
-}
-
-int execute_or(t_ast *node, t_shell *shell)
-{
-    int ret;
-
-    ret = execute_ast(node->bin.left, shell);
-    if (ret != 0)
-        ret = execute_ast(node->bin.right, shell);
-    else
-        shell->exit_status = ret;
-    return (ret);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_ast.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:48:43 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-int execute_ast(t_ast *node, t_shell *shell)
-{
-    int ret;
-
-    if (!node)
-        return (0);
-    if (node->type == N_COMMAND)
-        ret = execute_command(node, shell);
-    else if (node->type == N_PIPE)
-        ret = execute_pipe(node, shell);
-    else if (node->type == N_AND)
-        ret = execute_and(node, shell);
-    else if (node->type == N_OR)
-        ret = execute_or(node, shell);
-    else if (node->type == N_SUBSHELL)
-        ret = execute_subshell(node, shell);
-    else if (node->type == N_SEQUENCE)
-        ret = execute_sequence(node, shell);
-    else if (node->type == N_BACKGROUND)
-        ret = execute_background(node, shell);
-    else if (node->type == N_REDIR)
-    {
-        ft_dprintf(2, "minishell: syntax error near unexpected token `newline'\n");
-        shell->exit_status = 2;
-        ret = 1;
-    }
-    else
-    {
-        ft_dprintf(2, "minishell: command not found\n");
-        shell->exit_status = 127;
-        ret = 127;
-    }
-    return (ret);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_background.c                               :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:49:41 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-int execute_background(t_ast *node, t_shell *shell)
-{
-    pid_t pid;
-
-    pid = fork();
-    if (pid < 0)
-    {
-        ft_dprintf(2, "minishell: fork error\n");
-        shell->exit_status = 1;
-        return (1);
-    }
-    if (pid == 0)
-    {
-        /* Hijo: señales por defecto para comportamiento bash-like */
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        _exit(execute_ast(node->bin.left, shell) & 0xFF);
-    }
-    /* Padre: no espera al hijo en background */
-    shell->exit_status = 0;
-    ft_dprintf(1, "[1] %d\n", pid);
-    return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_command.c                                  :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:50:03 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-void restore_std_fds(int saved_in, int saved_out, int saved_err)
-{
-    if (saved_in  != -1) { dup2(saved_in,  STDIN_FILENO);  close(saved_in);  }
-    if (saved_out != -1) { dup2(saved_out, STDOUT_FILENO); close(saved_out); }
-    if (saved_err != -1) { dup2(saved_err, STDERR_FILENO); close(saved_err); }
-}
-
-int execute_command(t_ast *node, t_shell *shell)
-{
-    pid_t   pid;
-    char    **env;
-    char    *exec_path;
-    int     status;
-
-    if (!node || !node->cmd.argv || !node->cmd.argv[0])
-        return (0);
-
-    if (node->cmd.argv[0][0] == '\0')
-    {
-        ft_dprintf(2, "minishell: : command not found\n");
-        shell->exit_status = 127;
-        return (127);
-    }
-
-    /* -------- BUILTIN en el PADRE (con redirecciones) -------- */
-    if (is_builtin(node->cmd.argv[0]))
-    {
-        int saved_in  = dup(STDIN_FILENO);
-        int saved_out = dup(STDOUT_FILENO);
-        int saved_err = dup(STDERR_FILENO);
-
-        if (saved_in == -1 || saved_out == -1 || saved_err == -1)
-        {
-            perror("minishell: dup");
-            if (saved_in  != -1) close(saved_in);
-            if (saved_out != -1) close(saved_out);
-            if (saved_err != -1) close(saved_err);
-            shell->exit_status = 1;
-            return (1);
-        }
-        if (apply_redirections(node->cmd.redirections) != 0)
-        {
-            restore_std_fds(saved_in, saved_out, saved_err);
-            shell->exit_status = 1;
-            return (1);
-        }
-        shell->exit_status = run_builtin(node, shell);
-        restore_std_fds(saved_in, saved_out, saved_err);
-        return (shell->exit_status);
-    }
-
-    /* -------- EXTERNOS -------- */
-    exec_path = find_executable(node->cmd.argv[0], shell);
-    if (!exec_path)
-        return (print_exec_error(shell, node->cmd.argv[0], errno));
-
-    env = env_to_array(shell->env);
-    if (!env)
-    {
-        free(exec_path);
-        shell->exit_status = 1;
-        return (1);
-    }
-
-    pid = fork();
-    if (pid < 0)
-    {
-        int ret = print_exec_error(shell, node->cmd.argv[0], errno);
-        free(exec_path);
-        ft_free_strtab(env);
-        return (ret);
-    }
-    if (pid == 0)
-    {
-        /* --- HIJO --- */
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-
-        if (apply_redirections(node->cmd.redirections) != 0)
-            _exit(1);
-
-        execve(exec_path, node->cmd.argv, env);
-        print_exec_error(shell, node->cmd.argv[0], errno);
-        _exit(127);
-    }
-
-    /* --- PADRE --- */
-    if (waitpid(pid, &status, 0) == -1)
-        shell->exit_status = 1;
-    else if (WIFEXITED(status))
-        shell->exit_status = WEXITSTATUS(status);
-    else if (WIFSIGNALED(status))
-    {
-        int sig = WTERMSIG(status);
-        shell->exit_status = 128 + sig;
-        if (sig == SIGINT)
-            write(STDOUT_FILENO, "\n", 1);
-        else if (sig == SIGQUIT)
-            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
-    }
-    else
-        shell->exit_status = 1;
-
-    free(exec_path);
-    ft_free_strtab(env);
-    return (shell->exit_status);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_heredocs.c                                 :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:01:40 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "exec.h"
-
-/*
-** Heredoc: lee hasta 'delimiter', escribe en un pipe y devuelve fd de lectura.
-** Se usa en tiempo de ejecución de la redirección.
-*/
-int	heredoc_prepare(const char *delimiter)
-{
-	int		pipefd[2];
-	char	*line;
-	size_t	dlen;
-
-	if (!delimiter) return (-1);
-	dlen = ft_strlen(delimiter);
-	if (pipe(pipefd) == -1)
-		return (-1);
-
-	/* Mientras se lee el heredoc, ^C aborta lectura; ^\ se ignora */
-	signal(SIGQUIT, SIG_IGN);
-	signal(SIGINT, SIG_DFL);
-
-	while (1)
-	{
-		line = readline("> ");
-		if (!line)
-			break;
-		if (ft_strncmp(line, delimiter, dlen) == 0 && line[dlen] == '\0')
-		{
-			free(line);
-			break;
-		}
-		write(pipefd[1], line, ft_strlen(line));
-		write(pipefd[1], "\n", 1);
-		free(line);
-	}
-	close(pipefd[1]);
-
-	/* Restauramos defaults típicos del hijo al salir del heredoc */
-	signal(SIGQUIT, SIG_DFL);
-	signal(SIGINT, SIG_DFL);
-	return (pipefd[0]);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_pipe.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:50:18 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-int execute_pipe(t_ast *node, t_shell *shell)
-{
-    int     pipefd[2];
-    pid_t   pid_l, pid_r;
-    int     st_l = 0, st_r = 0;
-
-    if (pipe(pipefd) == -1)
-    {
-        ft_dprintf(2, "minishell: pipe error\n");
-        shell->exit_status = 1;
-        return (1);
-    }
-
-    pid_l = fork();
-    if (pid_l == 0)
-    {
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        close(pipefd[0]);
-        if (dup2(pipefd[1], STDOUT_FILENO) < 0)
-            _exit(1);
-        close(pipefd[1]);
-        _exit(execute_ast(node->bin.left, shell) & 0xFF);
-    }
-
-    pid_r = fork();
-    if (pid_r == 0)
-    {
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        close(pipefd[1]);
-        if (dup2(pipefd[0], STDIN_FILENO) < 0)
-            _exit(1);
-        close(pipefd[0]);
-        _exit(execute_ast(node->bin.right, shell) & 0xFF);
-    }
-
-    close(pipefd[0]);
-    close(pipefd[1]);
-
-    if (waitpid(pid_l, &st_l, 0) < 0)
-        st_l = 0;
-    if (waitpid(pid_r, &st_r, 0) < 0)
-        st_r = 0;
-
-    if (WIFEXITED(st_r))
-        shell->exit_status = WEXITSTATUS(st_r);
-    else if (WIFSIGNALED(st_r))
-    {
-        int sig = WTERMSIG(st_r);
-        if (sig == SIGINT)
-            write(STDOUT_FILENO, "\n", 1);
-        else if (sig == SIGQUIT)
-            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
-        shell->exit_status = 128 + sig;
-    }
-    else
-        shell->exit_status = 1;
-
-    return (shell->exit_status);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_redirections.c                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 15:12:04 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:01:30 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "exec.h"
-
-static int	redirect_to(int fd, int std_fd)
-{
-	int	ret = 0;
-	if (dup2(fd, std_fd) < 0)
-	{
-		perror("minishell: dup2");
-		close(fd);
-		ret = 1;
-	}
-	close(fd);
-	return (ret);
-}
-
-static int	handle_heredoc(t_ast *redir)
-{
-	int	fd = heredoc_prepare(redir->redir.delimiter);
-	if (fd < 0)
-		return (1);
-	return (redirect_to(fd, STDIN_FILENO));
-}
-
-int	open_redirection(t_ast *redir)
-{
-	int	fd = -1;
-
-	if (!redir || redir->type != N_REDIR) return (-1);
-	if (redir->redir.redir_type == REDIR_IN)
-		fd = open(redir->redir.filename, O_RDONLY);
-	else if (redir->redir.redir_type == REDIR_OUT
-		|| redir->redir.redir_type == REDIR_FORCE)
-		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-	else if (redir->redir.redir_type == REDIR_APPEND)
-		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
-	else if (redir->redir.redir_type == REDIR_ERR)
-		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-	else if (redir->redir.redir_type == REDIR_APPEND_ERR)
-		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
-	else if (redir->redir.redir_type == REDIR_ALL)
-		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-	else if (redir->redir.redir_type == REDIR_APPEND_ALL)
-		fd = open(redir->redir.filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
-	return (fd);
-}
-
-static int	handle_dup_redir(t_ast *redir)
-{
-	int	target = redir->redir.redir_fd;
-	int	std_fd = (redir->redir.redir_type == REDIR_DUP_OUT) ? STDOUT_FILENO : STDIN_FILENO;
-
-	if (target == std_fd) return (0);
-	if (dup2(target, std_fd) < 0)
-	{
-		perror("minishell: dup2");
-		return (1);
-	}
-	return (0);
-}
-
-int	handle_simple_redir(t_ast *redir)
-{
-	int	fd = open_redirection(redir);
-	int	ret = 0;
-
-	if (fd < 0)
-	{
-		perror(redir->redir.filename);
-		return (1);
-	}
-	if (redir->redir.redir_type == REDIR_IN)
-		ret = redirect_to(fd, STDIN_FILENO);
-	else if (redir->redir.redir_type == REDIR_OUT
-		|| redir->redir.redir_type == REDIR_FORCE
-		|| redir->redir.redir_type == REDIR_APPEND)
-		ret = redirect_to(fd, STDOUT_FILENO);
-	else if (redir->redir.redir_type == REDIR_ERR
-		|| redir->redir.redir_type == REDIR_APPEND_ERR)
-		ret = redirect_to(fd, STDERR_FILENO);
-	else if (redir->redir.redir_type == REDIR_ALL
-		|| redir->redir.redir_type == REDIR_APPEND_ALL)
-	{
-		if (dup2(fd, STDOUT_FILENO) < 0) ret = 1;
-		else if (dup2(fd, STDERR_FILENO) < 0) ret = 1;
-		close(fd);
-	}
-	return (ret);
-}
-
-int	apply_redirections(t_ast *redir_list)
-{
-	t_ast	*curr = redir_list;
-	int		fail = 0;
-
-	while (curr)
-	{
-		if (curr->type != N_REDIR)
-			return (1);
-
-		if (curr->redir.redir_type == REDIR_HEREDOC)
-		{
-			if (handle_heredoc(curr))
-				fail = 1;
-		}
-		else if (curr->redir.redir_type == REDIR_DUP_IN
-			|| curr->redir.redir_type == REDIR_DUP_OUT)
-		{
-			if (handle_dup_redir(curr))
-				fail = 1;
-		}
-		else
-		{
-			if (handle_simple_redir(curr))
-				fail = 1;
-		}
-		curr = curr->bin.right;
-	}
-	return (fail ? 1 : 0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_sequence.c                                 :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "exec.h"
-#include "ast.h"
-
-int execute_sequence(t_ast *node, t_shell *shell)
-{
-	execute_ast(node->bin.left, shell);
-	return (execute_ast(node->bin.right, shell));
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_subshell.c                                 :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:50:32 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-int execute_subshell(t_ast *node, t_shell *shell)
-{
-    pid_t pid;
-    int   st = 0;
-
-    pid = fork();
-    if (pid < 0)
-    {
-        ft_dprintf(2, "minishell: fork error\n");
-        shell->exit_status = 1;
-        return (1);
-    }
-    if (pid == 0)
-    {
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        _exit(execute_ast(node->subshell.child, shell) & 0xFF);
-    }
-    if (waitpid(pid, &st, 0) < 0)
-        shell->exit_status = 1;
-    else if (WIFEXITED(st))
-        shell->exit_status = WEXITSTATUS(st);
-    else if (WIFSIGNALED(st))
-    {
-        int sig = WTERMSIG(st);
-        if (sig == SIGINT)
-            write(STDOUT_FILENO, "\n", 1);
-        else if (sig == SIGQUIT)
-            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
-        shell->exit_status = 128 + sig;
-    }
-    else
-        shell->exit_status = 1;
-
-    return (shell->exit_status);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   execute_utils.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/30 15:27:01 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "env.h"
-#include "exec.h"
-#include "ast.h"
-#include <errno.h>
-#include <sys/stat.h>
-
-int	is_executable(char *path)
-{
-	struct stat	st;
-
-	if (stat(path, &st) != 0)
-		return (0);
-	if (S_ISDIR(st.st_mode))
-	{
-		errno = EISDIR;
-		return (0);
-	}
-	return (access(path, X_OK) == 0);
-}
-
-char	*join_path(const char *dir, const char *file)
-{
-	char	*tmp;
-	size_t	len_dir;
-	size_t	len_file;
-	size_t	i;
-
-	len_dir = ft_strlen(dir);
-	len_file = ft_strlen(file);
-	tmp = malloc(len_dir + 1 + len_file + 1);
-	if (!tmp)
-		return (NULL);
-	ft_memcpy(tmp, dir, len_dir);
-	tmp[len_dir] = '/';
-	i = 0;
-	while (i < len_file)
-	{
-		tmp[len_dir + 1 + i] = file[i];
-		i++;
-	}
-	tmp[len_dir + 1 + len_file] = '\0';
-	return (tmp);
-}
-
-static int	has_slash(char *cmd)
-{
-	int	i;
-
-	if (!cmd)
-		return (0);
-	i = 0;
-	while (cmd[i])
-	{
-		if (cmd[i] == '/')
-			return (1);
-		i++;
-	}
-	return (0);
-}
-
-static char	*find_path_executable(char *cmd, char **paths)
-{
-	int		i;
-	char	*full_path;
-
-	i = 0;
-	while (paths[i])
-	{
-		full_path = join_path(paths[i], cmd);
-		if (!full_path)
-			return (NULL);
-		if (is_executable(full_path))
-			return (full_path); // No liberar, lo devolvemos
-		free(full_path);
-		i++;
-	}
-	return (NULL);
-}
-
-char	*find_executable(char *cmd, t_shell *shell)
-{
-	char	**paths;
-	char	*res;
-	char	*path_value;
-
-	if (!cmd)
-		return (NULL);
-	if (has_slash(cmd))
-	{
-		if (is_executable(cmd))
-			return (ft_strdup(cmd));
-		return (NULL);
-	}
-	path_value = get_env_value(shell, "PATH");
-	if (!path_value || path_value[0] == '\0')
-		return (NULL);
-	paths = ft_split(path_value, ':');
-	if (!paths)
-		return (NULL);
-	res = find_path_executable(cmd, paths);
-	ft_free_strtab(paths);
-	return (res);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   calculate_expand_len.c                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/28 00:16:36 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:32:58 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-#include "env.h"
-
-size_t  handle_dollar_len(const char *str, int *i, t_shell *shell)
-{
-    char    *expanded;
-    size_t  len;
-
-    (*i)++; /* saltar '$' */
-    expanded = expand_value(str, i, shell); /* avanza *i tras el nombre */
-    if (!expanded)
-        return (size_t)-1;
-    len = ft_strlen(expanded);
-    free(expanded);
-    return len;
-}
-
-size_t  calculate_expanded_len(const char *str, t_shell *shell)
-{
-    size_t  total = 0;
-    int     i = 0;
-    t_quote q = NO_QUOTE;
-
-    while (str[i])
-    {
-        if (str[i] == '\'')
-        {
-            if (q == NO_QUOTE) q = SINGLE_QUOTE;
-            else if (q == SINGLE_QUOTE) q = NO_QUOTE;
-            total += 1; i++; continue;
-        }
-        if (str[i] == '"')
-        {
-            if (q == NO_QUOTE) q = DOUBLE_QUOTE;
-            else if (q == DOUBLE_QUOTE) q = NO_QUOTE;
-            total += 1; i++; continue;
-        }
-
-        if (str[i] == '\\')
-        {
-            if (q == SINGLE_QUOTE) { total += 1; i += 1; continue; }
-            if (q == DOUBLE_QUOTE)
-            {
-                if (str[i+1] == '\n') { i += 2; continue; }
-                if (str[i+1]) { total += 2; i += 2; continue; } /* '\'+char */
-                total += 1; i += 1; continue; /* '\' final */
-            }
-            /* NO_QUOTE */
-            if (str[i+1] == '\n') { i += 2; continue; }
-            if (str[i+1] == '$') { total += 1; i += 2; continue; } /* \$ -> '$' */
-            total += 1; i += 1; continue; /* preservamos '\' */
-        }
-
-        if (q != SINGLE_QUOTE && str[i] == '$')
-        {
-            size_t add = handle_dollar_len(str, &i, shell);
-            if (add == (size_t)-1) return (size_t)-1;
-            total += add;
-            continue;
-        }
-
-        if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i-1]) || str[i-1] == '='))
-        {
-            char *t = expand_tilde_internal(str + i, shell);
-            if (!t) return (size_t)-1;
-            total += ft_strlen(t);
-            i += get_tilde_prefix_len(str + i);
-            free(t);
-            continue;
-        }
-
-        total += 1; i++;
-    }
-    return total;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   expand.c                                           :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 02:45:20 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:34:38 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-#include "env.h"
-
-char *expand_token(const char *str, t_shell *shell)
-{
-    if (!str) return NULL;
-
-    /* Pre-calcular tamaño para evitar overflows (p.ej. $PATH muy largo) */
-    size_t need = calculate_expanded_len(str, shell);
-    if (need == (size_t)-1)
-        return NULL;
-
-    char *res = (char *)malloc(need + 1);
-    if (!res) return NULL;
-
-    int i = 0, j = 0;
-    t_quote q = NO_QUOTE;
-
-    while (str[i])
-    {
-        if (str[i] == '\'')
-        {
-            if (q == NO_QUOTE) q = SINGLE_QUOTE;
-            else if (q == SINGLE_QUOTE) q = NO_QUOTE;
-            res[j++] = str[i++];                 /* se quitará en remove_quotes */
-            continue;
-        }
-        if (str[i] == '"')
-        {
-            if (q == NO_QUOTE) q = DOUBLE_QUOTE;
-            else if (q == DOUBLE_QUOTE) q = NO_QUOTE;
-            res[j++] = str[i++];
-            continue;
-        }
-
-        if (str[i] == '\\')
-        {
-            if (q == SINGLE_QUOTE)
-            {
-                /* en '...' la barra es literal */
-                res[j++] = '\\'; i++; continue;
-            }
-            if (q == DOUBLE_QUOTE)
-            {
-                if (str[i+1] == '\n') { i += 2; continue; } /* "\<nl>" desaparece */
-                if (str[i+1])
-                {
-                    /* conservamos '\' + char; quote_removal decidirá si quitar '\' */
-                    res[j++] = '\\';
-                    res[j++] = str[i+1];
-                    i += 2;
-                    continue;
-                }
-                res[j++] = '\\'; i++; continue;            /* '\' final */
-            }
-            /* NO_QUOTE */
-            if (str[i+1] == '\n') { i += 2; continue; }    /* continuación de línea */
-            if (str[i+1] == '$') { i++; res[j++] = '$'; i++; continue; } /* \$ -> '$' literal */
-            res[j++] = '\\'; i++; continue;                /* preservamos '\' */
-        }
-
-        if (q != SINGLE_QUOTE && str[i] == '$')
-        {
-            int added = handle_dollar(str, &i, res, j, shell); /* avanza i internamente */
-            if (added < 0) { free(res); return NULL; }
-            j += added;
-            continue;
-        }
-
-        if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i-1]) || str[i-1] == '='))
-        {
-            char *t = expand_tilde_internal(str + i, shell);
-            if (!t) { free(res); return NULL; }
-            ft_strcpy(res + j, t);
-            j += ft_strlen(t);
-            i += get_tilde_prefix_len(str + i);
-            free(t);
-            continue;
-        }
-
-        res[j++] = str[i++];
-    }
-    res[j] = '\0';
-    return res;
-}
-
-int expand_variables(t_shell *shell)
-{
-    t_token *t = shell->tokens;
-
-    while (t)
-    {
-        char *expanded = expand_token(t->value, shell);
-        if (!expanded)
-            return -1;
-        free(t->value);
-        t->value = expanded;
-        t = t->next;
-    }
-    /* Orden Bash: expansiones -> word splitting -> quote removal */
-    perform_word_splitting(shell);
-    remove_quotes(shell->tokens);
-    return 0;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   expand_dollar.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/28 00:15:35 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:33:11 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-#include "env.h"
-
-char *expand_value(const char *s, int *i, t_shell *shell)
-{
-    /* s[*i] es el carácter justo DESPUÉS del '$' */
-    if (!s || !s[*i])
-        return ft_strdup("");
-
-    /* especiales */
-    if (s[*i] == '?') { (*i)++; return ft_itoa(shell->exit_status); } /* $? */
-    if (s[*i] == '$') { (*i)++; return ft_itoa(getpid()); }           /* $$ */
-    if (s[*i] == '0') { (*i)++; return get_program_name_str(shell); } /* $0 */
-
-    /* posicionales $1..$9 -> vacías si no existen */
-    if (ft_isdigit((unsigned char)s[*i])) { (*i)++; return ft_strdup(""); }
-
-    /* "$" seguido de comilla o fin -> "" (coincide con tus tests) */
-    if (s[*i] == '"' || s[*i] == '\'' || s[*i] == '\0')
-        return ft_strdup("");
-
-    /* nombre de variable */
-    if (ft_isalpha((unsigned char)s[*i]) || s[*i] == '_')
-    {
-        int start = *i;
-        while (ft_isalnum((unsigned char)s[*i]) || s[*i] == '_') (*i)++;
-        char *name = ft_substr(s, start, *i - start);
-        if (!name) return NULL;
-        char *val = find_var(shell->env, name);
-        free(name);
-        return ft_strdup(val ? val : "");
-    }
-
-    /* por defecto: trata el '$' como literal */
-    (*i)++;
-    return ft_strdup("$");
-}
-
-int handle_dollar(const char *s, int *i, char *dst, int j, t_shell *shell)
-{
-    char *expanded;
-    int   len;
-
-    (*i)++; /* saltar '$' en el input */
-    expanded = expand_value(s, i, shell);
-    if (!expanded) return -1;
-    len = (int)ft_strlen(expanded);
-    ft_memcpy(dst + j, expanded, len);
-    free(expanded);
-    return len;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   expand_tilde.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 02:46:11 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:33:46 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-#include "env.h"
-
-char *expand_tilde_internal(const char *str, t_shell *shell)
-{
-    char *home;
-    char *out;
-
-    if (!str || *str != '~')
-        return ft_strdup(str);
-
-    if (ft_strlen(str) == 1 || str[1] == '/')
-    {
-        home = find_var(shell->env, "HOME");
-        if (!home || *home == '\0')
-            return ft_strdup(str);
-        if (ft_strlen(str) == 1)
-            return ft_strdup(home);
-        out = ft_strjoin(home, str + 1); /* "~" + "/..." */
-        return out;
-    }
-    /* ~user -> no implementado: copia tal cual */
-    return ft_strdup(str);
-}
-
-size_t get_tilde_prefix_len(const char *str)
-{
-    if (!str || *str != '~') return 0;
-    if (ft_strlen(str) == 1 || str[1] == '/') return 1 + (str[1] == '/');
-    return 1;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   expand_utils.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/28 00:52:34 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:33:25 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-#include "env.h"
-
-char *find_var(t_env *env, char *name)
-{
-    while (env)
-    {
-        if (ft_strcmp(env->key, name) == 0)
-            return (env->value ? env->value : "");
-        env = env->next;
-    }
-    return "";
-}
-
-char *get_program_name_str(t_shell *shell)
-{
-    if (!shell->program_name)
-        return ft_strdup("minishell");
-    return ft_strdup(shell->program_name);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   handle_expand_cases.c                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/28 00:08:05 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:33:35 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-#include "env.h"
-
-size_t handle_exit_status_len(t_shell *shell)
-{
-    char   *s = ft_itoa(shell->exit_status);
-    size_t  n;
-
-    if (!s) return (size_t)-1;
-    n = ft_strlen(s);
-    free(s);
-    return n;
-}
-
-size_t handle_pid_len(void)
-{
-    char   *s = ft_itoa(getpid());
-    size_t  n;
-
-    if (!s) return (size_t)-1;
-    n = ft_strlen(s);
-    free(s);
-    return n;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   quote_removal.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/21 13:49:35 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 14:33:59 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "expand.h"
-
-static char *quote_remove_like_bash(const char *s)
-{
-    size_t n = ft_strlen(s);
-    char  *out = (char *)malloc(n + 1);
-    int    i = 0, j = 0;
-    t_quote q = NO_QUOTE;
-
-    if (!out) return NULL;
-
-    while ( s[i] )
-    {
-        if (q == NO_QUOTE)
-        {
-            if (s[i] == '\\')
-            {
-                if (s[i+1] == '\n') { i += 2; continue; }
-                if (s[i+1]) { i++; out[j++] = s[i++]; continue; }
-                out[j++] = s[i++]; continue; /* '\' final literal */
-            }
-            if (s[i] == '\'') { q = SINGLE_QUOTE; i++; continue; }
-            if (s[i] == '"')  { q = DOUBLE_QUOTE; i++; continue; }
-            out[j++] = s[i++]; continue;
-        }
-        if (q == SINGLE_QUOTE)
-        {
-            if (s[i] == '\'') { q = NO_QUOTE; i++; continue; }
-            out[j++] = s[i++]; continue;
-        }
-        /* q == DOUBLE_QUOTE */
-        if (s[i] == '\\')
-        {
-            if (s[i+1] == '\n') { i += 2; continue; }
-            if (s[i+1] && (s[i+1] == '$' || s[i+1] == '`' || s[i+1] == '"' || s[i+1] == '\\'))
-            { i++; out[j++] = s[i++]; continue; }
-            out[j++] = s[i++]; continue; /* '\' literal si no escapa especial */
-        }
-        if (s[i] == '"') { q = NO_QUOTE; i++; continue; }
-        out[j++] = s[i++];
-    }
-    out[j] = '\0';
-    return out;
-}
-
-void    remove_quotes(t_token *tokens)
-{
-    for (t_token *t = tokens; t; t = t->next)
-    {
-        char *clean = quote_remove_like_bash(t->value);
-        if (!clean) return; /* Manejo básico de error */
-        free(t->value);
-        t->value = clean;
-        t->quoted = NO_QUOTE;
-    }
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   word_splitting.c                                   :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/07/21 15:11:12 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:00:49 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"   // try_add_token, t_token, types
-#include "expand.h"  // t_quote
-
-/* IFS por defecto: espacio, tab y newline */
-static int is_ifs_space(unsigned char c)
-{
-    return (c == ' ' || c == '\t' || c == '\n');
-}
-
-/* Divide SOLO palabras (T_WORD) respetando comillas y backslashes */
-static t_token *split_word_respecting_quotes(const char *s)
-{
-    t_token *head = NULL;
-    size_t   n = ft_strlen(s);
-    char    *buf = malloc(n + 1);
-    size_t   i = 0, j;
-    t_quote  q;
-
-    if (!buf)
-        return NULL;
-
-    /* saltar IFS inicial (no escapado) */
-    while (s[i] && is_ifs_space((unsigned char)s[i]))
-        i++;
-
-    while (s[i])
-    {
-        j = 0; q = NO_QUOTE;
-        while (s[i])
-        {
-            char c = s[i];
-            if (q == NO_QUOTE)
-            {
-                if (c == '\\')
-                {
-                    if (s[i+1] == '\n') { i += 2; continue; }
-                    if (s[i+1]) { buf[j++] = '\\'; buf[j++] = s[i+1]; i += 2; continue; }
-                    buf[j++] = '\\'; i++; continue;
-                }
-                if (c == '\'') { q = SINGLE_QUOTE; buf[j++] = c; i++; continue; }
-                if (c == '"')  { q = DOUBLE_QUOTE; buf[j++] = c; i++; continue; }
-                if (is_ifs_space((unsigned char)c)) break;
-                buf[j++] = c; i++; continue;
-            }
-            else if (q == SINGLE_QUOTE)
-            { buf[j++] = c; i++; if (c == '\'') q = NO_QUOTE; continue; }
-            else /* DOUBLE_QUOTE */
-            {
-                if (c == '"') { buf[j++] = c; i++; q = NO_QUOTE; continue; }
-                if (c == '\\')
-                {
-                    if (s[i+1] == '\n') { i += 2; continue; }
-                    if (s[i+1]) { buf[j++] = '\\'; buf[j++] = s[i+1]; i += 2; continue; }
-                }
-                buf[j++] = c; i++; continue;
-            }
-        }
-        if (j > 0)
-        {
-            char *field = malloc(j + 1);
-            if (!field) { free_token_list(head); free(buf); return NULL; }
-            ft_memcpy(field, buf, j); field[j] = '\0';
-            if (!try_add_token(&head, field, T_WORD, NO_QUOTE))
-            { free(field); free_token_list(head); free(buf); return NULL; }
-        }
-        while (s[i] && is_ifs_space((unsigned char)s[i]))
-            i++;
-    }
-    free(buf);
-    return head;
-}
-
-void    perform_word_splitting(t_shell *shell)
-{
-    t_token *current = shell->tokens;
-    t_token *prev = NULL;
-
-    while (current)
-    {
-        t_token *next_original = current->next;
-
-        /* IMPORTANTÍSIMO:
-           - SOLO dividimos si es una PALABRA (T_WORD)
-           - y si no venía completamente entrecomillada */
-        if (current->type == T_WORD && current->quoted == NO_QUOTE)
-        {
-            t_token *split = split_word_respecting_quotes(current->value);
-            if (split == NULL)
-            {
-                /* Expansión → vacío sin comillas: elimina el token */
-                if (prev) prev->next = next_original;
-                else shell->tokens = next_original;
-                free(current->value);
-                free(current);
-                current = next_original;
-                continue;
-            }
-            /* Inserta lista nueva en lugar del token original */
-            if (prev) prev->next = split;
-            else shell->tokens = split;
-
-            t_token *last = split;
-            while (last->next) last = last->next;
-            last->next = next_original;
-
-            free(current->value);
-            free(current);
-
-            prev = last;
-            current = next_original;
-        }
-        else
-        {
-            prev = current;
-            current = next_original;
-        }
-    }
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer.c                                            :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 16:07:05 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:40:49 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-
-/*
-** Reglas principales que seguimos (resumen):
-** - Comentarios: un '#' que comienza una palabra (inicio de línea, tras espacio
-**   no comillado o tras un operador) e *imprimible* y *no comillado* inicia un
-**   comentario hasta fin de línea. (Bash: en modo interactivo depende de
-**   shopt interactive_comments; aquí lo activamos siempre en no-interactivo).
-**   Ref: Bash manual, "Comments". :contentReference[oaicite:0]{index=0}
-**
-** - Comillas:
-**   * '...': literal, sin escapes, hasta la próxima ' (no se puede anidar). :contentReference[oaicite:1]{index=1}
-**   * "...": backslash sólo escapa: $, `, ", \ y newline para continuación de
-**            línea. (El resto de backslashes se preservan). :contentReference[oaicite:2]{index=2}
-**   * fuera de comillas: '\' escapa el siguiente carácter; '\<newline>'
-**     elimina ambos (continuación de línea POSIX). :contentReference[oaicite:3]{index=3}
-**
-** - Operadores reconocidos: ||, &&, |, ;, &, <, >, >>, <<, <<<, >|, <&, >&,
-**   2>, 2>>, &>, &>>, paréntesis y llaves. (Algunos son Bash-specific, p.ej. &>, <<<). :contentReference[oaicite:4]{index=4}
-**
-** Nota: la *expansión* ($VAR, ~, etc.) no es parte del lexer; aquí sólo
-** tokenizamos y marcamos si el token estaba comillado.
-*/
-
-static t_token *free_null_token_list(t_token **lst)
-{
-    free_token_list(*lst);
-    *lst = NULL;
-    return (NULL);
-}
-
-/* Detecta prefijos de fd redundantes: "1>", "0<", "2>&1"...;
- * aquí solo los saltamos para simplificar equivalencias de bash.
- * (No altera el AST, sólo evita tokens numéricos sueltos). */
-static int  skip_default_fd_prefix(const char *s)
-{
-    if (s[0] == '1' && (s[1] == '>' || (s[1] == '<' && s[2] == '<')))
-        return 1; /* 1>, 1<< */
-    if (s[0] == '0' && (s[1] == '<' || (s[1] == '<' && s[2] == '<')))
-        return 1; /* 0<, 0<< */
-    if (s[0] == '2' && s[1] == '>' && s[2] == '&' && s[3] == '1')
-        return 1; /* 2>&1 */
-    return 0;
-}
-
-/* Sufijos fd redundantes tras un operador (>1, >>1, <&0, >&1...) */
-static int  skip_default_fd_suffix(const char *s)
-{
-    if (s[0] == '>' && s[1] == '1' && s[2] != '>')
-        return 1; /* >1 */
-    if (s[0] == '>' && s[1] == '>' && s[2] == '1')
-        return 1; /* >>1 */
-    if (s[0] == '<' && s[1] == '&' && s[2] == '0')
-        return 1; /* <&0 */
-    if (s[0] == '>' && s[1] == '&' && s[2] == '1')
-        return 1; /* >&1 */
-    if (s[0] == '<' && s[1] == '<' && s[2] == '<' && s[3] == '1')
-        return 1; /* <<<1 */
-    return 0;
-}
-
-t_token *lexer(const char *raw_line)
-{
-    t_token *lst = NULL;
-    int     i = 0, next_i = 0;
-
-    if (!raw_line)
-        return NULL;
-
-    /* Hacemos una copia mutable para poder cortar comentarios de forma segura */
-    char *line = ft_strdup(raw_line);
-    if (!line)
-        return NULL;
-
-    /* Comentarios estilo bash: si # comienza palabra descomillada -> corta línea. */
-    strip_comment_if_applicable(line); /* :contentReference[oaicite:5]{index=5} */
-
-    while (line[i])
-    {
-        /* Saltar espacios fuera de comillas */
-        while (line[i] && ft_isspace(line[i]))
-            i++;
-        if (!line[i])
-            break;
-
-        /* Normaliza casos 1>, 0<, 2>&1 (los fd explícitos por defecto) */
-        i += skip_default_fd_prefix(line + i);
-
-        if (is_operator(line + i, NULL, NULL))
-        {
-            next_i = get_operator(line, i, &lst);
-            if (next_i < 0)
-                return free_null_token_list(&lst);
-            /* Saltar sufijos redundantes tras el operador */
-            next_i += skip_default_fd_suffix(line + next_i);
-        }
-        else
-        {
-            next_i = get_word(line, i, &lst);
-            if (next_i < 0)
-                return free_null_token_list(&lst);
-        }
-        i = next_i;
-    }
-
-    free(line);
-    return lst;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer_get_opertator.c                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 14:55:24 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:41:35 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-
-int     get_operator(const char *line, int i, t_token **lst)
-{
-        t_token_type    type;
-        int             len;
-        char            *op_str;
-
-        if (!is_operator(line + i, &type, &len))
-                return (i);
-        op_str = ft_substr(line, i, len);
-        if (!op_str)
-        {
-                free_lexer_list_on_error(lst);
-                return (-1);
-        }
-        if (!try_add_token(lst, op_str, type, NO_QUOTE))
-                return (-1);
-        return (i + len);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer_get_word.c                                   :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 14:25:33 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:41:46 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-
-/*
-** Avanza hasta el fin de una "palabra" al estilo bash:
-** - Respeta comillas (simples/dobles) y sus reglas de escapes.
-** - Fuera de comillas, '\' escapa siguiente char; '\\n' se elimina (continuación).
-** - Un operador reconocido TERMINA la palabra si no estamos dentro de comillas.
-** - Espacios no comillados también terminan palabra.
-*/
-
-static int word_end(const char *s, int i)
-{
-    t_quote q = NO_QUOTE;
-
-    while (s[i])
-    {
-        char c = s[i];
-
-        if (q == NO_QUOTE)
-        {
-            /* backslash fuera de comillas: escapa un char; "\<nl>" continúa línea. :contentReference[oaicite:8]{index=8} */
-            if (c == '\\')
-            {
-                if (s[i + 1] == '\n') { i += 2; continue; }
-                i += (s[i + 1] ? 2 : 1);
-                continue;
-            }
-            /* comillas */
-            if (c == '\'') { q = SINGLE_QUOTE; i++; continue; }
-            if (c == '"')  { q = DOUBLE_QUOTE; i++; continue; }
-
-            if (ft_isspace(c))
-                break;
-
-            /* operador -> fin de palabra */
-            if (is_operator(s + i, NULL, NULL))
-                break;
-
-            i++;
-        }
-        else if (q == SINGLE_QUOTE)
-        {
-            /* dentro de '...': todo literal hasta siguiente ' (sin escapes). :contentReference[oaicite:9]{index=9} */
-            if (c == '\'') q = NO_QUOTE;
-            i++;
-        }
-        else /* DOUBLE_QUOTE */
-        {
-            /* dentro de "...": \ sólo escapa $, `, ", \ y newline. :contentReference[oaicite:10]{index=10} */
-            if (c == '\\' && (s[i + 1] == '$' || s[i + 1] == '`'
-                || s[i + 1] == '"' || s[i + 1] == '\\' || s[i + 1] == '\n'))
-            {
-                i += (s[i + 1] ? 2 : 1);
-                continue;
-            }
-            if (c == '"') q = NO_QUOTE;
-            i++;
-        }
-    }
-    if (q != NO_QUOTE)
-        return -1; /* comillas sin cerrar -> error sintaxis */
-    return i;
-}
-
-int get_word(const char *line, int i, t_token **lst)
-{
-    int     start = i;
-    int     end = word_end(line, i);
-    char    *word;
-    t_quote qtype = NO_QUOTE;
-
-    if (end < 0)
-    {
-        fprintf(stderr, "minishell: syntax error: unclosed quote\n");
-        free_lexer_list_on_error(lst);
-        return -1;
-    }
-    if (end == start)
-        return end;
-
-    word = ft_substr(line, start, end - start);
-    if (!word)
-        return (free_lexer_list_on_error(lst), -1);
-
-    /* Determina el comillado principal del token (si empieza por comilla) */
-    if (word[0] == '\'') qtype = SINGLE_QUOTE;
-    else if (word[0] == '"') qtype = DOUBLE_QUOTE;
-
-    if (!try_add_token(lst, word, T_WORD, qtype))
-    {
-        free(word);
-        return -1;
-    }
-    return end;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer_strip_comments.c                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/10/24 13:45:00 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 13:45:00 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-
-/*
-** Bash: un comentario inicia si un '#' **comienza una palabra** no comillada:
-** - inicio de línea
-** - tras espacio no comillado
-** - tras un operador
-** Desde ahí hasta fin de línea se ignora. :contentReference[oaicite:6]{index=6}
-**
-** Aquí lo aplicamos siempre (en modo no interactivo de minishell).
-*/
-void    strip_comment_if_applicable(char *line)
-{
-    int i = 0;
-    t_quote q = NO_QUOTE;
-    int at_word_start = 1; /* al principio de la línea estamos al inicio de palabra */
-
-    if (!line)
-        return ;
-
-    while (line[i])
-    {
-        char c = line[i];
-
-        /* Gestión de escapes fuera/dentro de comillas según bash */
-        if (q == NO_QUOTE)
-        {
-            if (c == '\\')
-            {
-                if (line[i + 1] == '\n')
-                {
-                    /* continuación de línea: elimina ambos */
-                    /* desplazamos resto hacia atrás */
-                    int j = i; 
-                    while (line[j + 2]) { line[j] = line[j + 2]; j++; }
-                    line[j] = '\0';
-                    continue;
-                }
-                /* salta el próximo carácter como literal */
-                if (line[i + 1]) i += 2; else i++;
-                at_word_start = 0;
-                continue;
-            }
-            if (c == '\'') { q = SINGLE_QUOTE; i++; at_word_start = 0; continue; }
-            if (c == '"')  { q = DOUBLE_QUOTE; i++; at_word_start = 0; continue; }
-
-            /* Si # comienza palabra y estamos fuera de comillas -> cortar */
-            if (c == '#' && at_word_start)
-            {
-                line[i] = '\0';
-                return ;
-            }
-
-            /* espacios reinician inicio-de-palabra */
-            if (ft_isspace(c))
-                at_word_start = 1;
-            else
-            {
-                /* si el carácter actual inicia un operador, el siguiente es inicio-de-palabra */
-                t_token_type t; int len;
-                if (is_operator(line + i, &t, &len))
-                {
-                    i += len;
-                    at_word_start = 1;
-                    continue;
-                }
-                at_word_start = 0;
-            }
-            i++;
-        }
-        else if (q == SINGLE_QUOTE)
-        {
-            /* dentro de comillas simples: todo literal hasta la siguiente ' */
-            if (c == '\'') q = NO_QUOTE;
-            i++;
-            at_word_start = 0;
-        }
-        else /* DOUBLE_QUOTE */
-        {
-            /* Dentro de dobles comillas, \ sólo escapa $, `, ", \ y newline. :contentReference[oaicite:7]{index=7} */
-            if (c == '\\' && (line[i + 1] == '$' || line[i + 1] == '`'
-                || line[i + 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '\n'))
-            {
-                if (line[i + 1] == '\n')
-                {
-                    /* quita la continuación de línea */
-                    int j = i;
-                    while (line[j + 2]) { line[j] = line[j + 2]; j++; }
-                    line[j] = '\0';
-                    continue;
-                }
-                i += (line[i + 1] ? 2 : 1);
-                at_word_start = 0;
-                continue;
-            }
-            if (c == '"') q = NO_QUOTE;
-            i++;
-            at_word_start = 0;
-        }
-    }
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer_types.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 16:42:46 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:42:23 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-
-t_token_type    get_pipe_and_or(const char *str, int len)
-{
-    if (len == 2 && str[0] == '|' && str[1] == '|') return (T_OR);
-    if (len == 2 && str[0] == '&' && str[1] == '&') return (T_AND);
-    if (len == 1 && str[0] == '|') return (T_PIPE);
-    if (len == 1 && str[0] == '&') return (T_BG);
-    if (len == 1 && str[0] == ';') return (T_SEMI);
-    if (len == 1 && str[0] == '(') return (T_LPAREN);
-    if (len == 1 && str[0] == ')') return (T_RPAREN);
-    if (len == 1 && str[0] == '{') return (T_LBRACE);
-    if (len == 1 && str[0] == '}') return (T_RBRACE);
-    return (T_UNKNOWN);
-}
-
-t_token_type    get_semi_redir_left(const char *str, int len)
-{
-    if (len == 1 && str[0] == '<') return (T_REDIR_IN);
-    if (len == 2 && str[0] == '<' && str[1] == '<') return (T_HEREDOC);
-    if (len == 3 && str[0] == '<' && str[1] == '<' && str[2] == '<') return (T_HEREDOC_STR);
-    if (len == 2 && str[0] == '<' && str[1] == '&') return (T_DUP_IN);
-    if (len == 1 && str[0] == '=') return (T_EQUAL);
-    return (T_UNKNOWN);
-}
-
-t_token_type    get_redir_right(const char *str, int len)
-{
-    if (len == 2 && str[0] == '>' && str[1] == '>') return (T_APPEND);
-    if (len == 2 && str[0] == '>' && str[1] == '|') return (T_FORCE_OUT);
-    if (len == 2 && str[0] == '>' && str[1] == '&') return (T_DUP_OUT);
-    if (len == 1 && str[0] == '>') return (T_REDIR_OUT);
-    return (T_UNKNOWN);
-}
-
-t_token_type    get_redir_special(const char *str, int len)
-{
-    if (len == 3 && str[0] == '&' && str[1] == '>' && str[2] == '>') return (T_APPEND_ALL);
-    if (len == 2 && str[0] == '&' && str[1] == '>') return (T_REDIR_ALL);
-    if (len == 3 && str[0] == '2' && str[1] == '>' && str[2] == '>') return (T_APPEND_ERR);
-    if (len == 2 && str[0] == '2' && str[1] == '>') return (T_REDIR_ERR);
-    return (T_UNKNOWN);
-}
-
-t_token_type    get_token_type(const char *str, int len)
-{
-    t_token_type type;
-
-    type = get_redir_special(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    type = get_redir_right(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    type = get_semi_redir_left(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    type = get_pipe_and_or(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    return T_WORD;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   lexer_utils.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 16:36:48 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:50:38 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-
-t_token *token_new(char *value, t_token_type type, t_quote quote)
-{
-        t_token *tok;
-
-        tok = (t_token *)malloc(sizeof(t_token));
-        if (!tok)
-                return (NULL);
-        tok->value = value;
-        tok->type = type;
-        tok->quoted = quote;
-        tok->next = NULL;
-        return (tok);
-}
-
-void    token_addback(t_token **lst, t_token *new)
-{
-        t_token *tmp;
-
-        if (!lst || !new)
-                return ;
-        if (!*lst)
-        {
-                *lst = new;
-                return ;
-        }
-        tmp = *lst;
-        while (tmp->next)
-                tmp = tmp->next;
-        tmp->next = new;
-}
-
-void free_token_list(t_token *tok)
-{
-    t_token *next;
-
-    while (tok)
-    {
-        next = tok->next;
-        free(tok->value);
-        free(tok);
-        tok = next;
-    }
-}
-
-void next_token(t_token **cur)
-{
-    if (cur && *cur)
-        *cur = (*cur)->next;
-}
-
-
-
-int     is_operator(const char *str, t_token_type *type, int *len)
-{
-        static const char *ops[] = {
-                "<<<", ">>", "<<", "||", "&&", "&>>", "&>", ">|", "<&", ">&",
-                "2>>", "2>", "|",  "&",  ";",  "<",  ">",  "(",  ")",  "{", "}", "="
-        };
-        static const int  lens[] = {
-                3,     2,    2,    2,    2,    3,     2,    2,    2,    2,
-                3,     2,    1,    1,    1,    1,    1,    1,    1,    1,  1,  1
-        };
-        static const t_token_type types[] = {
-                T_HEREDOC_STR, T_APPEND, T_HEREDOC, T_OR, T_AND, T_APPEND_ALL,
-                T_REDIR_ALL,   T_FORCE_OUT, T_DUP_IN, T_DUP_OUT, T_APPEND_ERR,
-                T_REDIR_ERR,   T_PIPE,  T_BG,  T_SEMI, T_REDIR_IN, T_REDIR_OUT,
-                T_LPAREN, T_RPAREN, T_LBRACE, T_RBRACE, T_EQUAL
-        };
-        int i = 0;
-
-        while (i < (int)(sizeof(lens)/sizeof(lens[0])))
-        {
-                if (ft_strncmp(str, ops[i], lens[i]) == 0)
-                {
-                        if (type) *type = types[i];
-                        if (len)  *len  = lens[i];
-                        return 1;
-                }
-                i++;
-        }
-        return 0;
-}
-
-void    free_lexer_list_on_error(t_token **lst)
-{
-        if (lst && *lst)
-        {
-                free_token_list(*lst);
-                *lst = NULL;
-        }
-}
-
-int     try_add_token(t_token **lst, char *str, t_token_type type, t_quote quote)
-{
-        t_token *tok = token_new(str, type, quote);
-        if (!tok)
-        {
-                ft_strdel(&str);
-                return 0;
-        }
-        token_addback(lst, tok);
-        return 1;
-}
-
-/* Opcional: utilidad de eliminación de backslashes por tipo de comilla.
- * Útil si quieres “limpiar” el literal tras el lexer y antes de expandir. */
-char    *remove_backslashes_for_token(const char *src, t_quote quote)
-{
-        char    *out;
-        size_t  i = 0, j = 0;
-        size_t  n = ft_strlen(src);
-
-        out = malloc(n + 1);
-        if (!out) return NULL;
-
-        if (quote == SINGLE_QUOTE)
-        {
-                /* en '...' no hay escapes; copiamos tal cual */
-                while (i < n) out[j++] = src[i++];
-        }
-        else if (quote == DOUBLE_QUOTE)
-        {
-                while (i < n)
-                {
-                        if (src[i] == '\\' && i + 1 < n &&
-                           (src[i+1] == '$' || src[i+1] == '`' ||
-                            src[i+1] == '"' || src[i+1] == '\\'))
-                        { i++; out[j++] = src[i++]; }
-                        else if (src[i] == '\\' && i + 1 < n && src[i+1] == '\n')
-                        { i += 2; /* elimina continuación de línea */ }
-                        else out[j++] = src[i++];
-                }
-        }
-        else /* NO_QUOTE */
-        {
-                while (i < n)
-                {
-                        if (src[i] == '\\' && i + 1 < n && src[i+1] == '\n')
-                        { i += 2; } /* elimina continuación de línea */
-                        else if (src[i] == '\\' && i + 1 < n)
-                        { i++; out[j++] = src[i++]; } /* escapa siguiente */
-                        else out[j++] = src[i++];
-                }
-        }
-        out[j] = '\0';
-        return out;
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   heredoc_read.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/30 01:06:08 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 04:29:30 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "signal.h"
-
-/*
-** heredoc_read:
-** Lee un heredoc hasta el delimitador o interrupción por Ctrl+C (SIGINT).
-** - Devuelve un fd de solo lectura si todo va bien.
-** - Devuelve -1 si hubo interrupción o error.
-*/
-
-/* here-doc: lee hasta 'delimiter' (sin expansión aquí; eso se decide al parsear) */
-
-int heredoc_read(char *delimiter)
-{
-    int   pipefd[2];
-    char *line;
-
-    if (!delimiter)
-        return (-1);
-    if (pipe(pipefd) < 0)
-    {
-        perror("minishell: pipe");
-        return (-1);
-    }
-
-    /* Comportamiento típico: en heredoc el shell hijo maneja SIGINT/SIGQUIT por defecto */
-    signal(SIGQUIT, SIG_DFL);
-    signal(SIGINT, SIG_DFL);
-
-    while (1)
-    {
-        line = readline("> ");
-        if (!line)  /* EOF (Ctrl-D) */
-            break;
-        if (strcmp(line, delimiter) == 0)
-        {
-            free(line);
-            break;
-        }
-        /* Sin expansión: se escribe tal cual con salto de línea */
-        write(pipefd[1], line, strlen(line));
-        write(pipefd[1], "\n", 1);
-        free(line);
-    }
-    close(pipefd[1]);          /* Muy importante: cerrar escritura para que el lector vea EOF */
-    return (pipefd[0]);        /* Devuelve fd de lectura */
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parser_and_or.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 18:38:03 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/28 03:02:13 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-
-t_ast	*parse_and_or(t_token **cur)
-{
-	t_ast		*left;
-	t_ast		*right;
-	t_ast		*node;
-	t_node_type	node_type;
-
-	left = parse_pipeline(cur);
-	if (!left)
-		return (NULL);
-
-	while (*cur && ((*cur)->type == T_AND || (*cur)->type == T_OR))
-	{
-		if ((*cur)->type == T_AND)
-			node_type = N_AND;
-		else
-			node_type = N_OR;
-
-		next_token(cur);
-		if (!*cur)
-		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
-			free_ast(left);
-			return (NULL);
-		}
-		right = parse_pipeline(cur);
-		if (!right)
-		{
-			free_ast(left);
-			return (NULL);
-		}
-		node = ast_new_binary(node_type, left, right);
-		if (!node)
-		{
-			free_ast(left);
-			free_ast(right);
-			return (NULL);
-		}
-		left = node;
-	}
-	return (left);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_arguments.c                                  :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/28 03:14:32 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/30 16:35:57 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "parser.h"
-#include "lexer.h"
-
-char	**add_argument(char **argv, int *argc, int *size, const char *value)
-{
-	char	**new_argv;
-	size_t	old_bytes;
-	size_t	new_bytes;
-
-	if (*argc >= *size)
-	{
-		old_bytes = (size_t)(*size) * sizeof(char *);
-		*size *= 2;
-		new_bytes = (size_t)(*size + 1) * sizeof(char *);
-		new_argv = (char **)ft_realloc(argv, old_bytes, new_bytes);
-		if (!new_argv)
-		{
-			ft_free_strtab(argv);
-			return (NULL);
-		}
-		argv = new_argv;
-	}
-	argv[*argc] = ft_strdup(value);
-	if (!argv[*argc])
-	{
-		ft_free_strtab(argv);
-		return (NULL);
-	}
-	(*argc)++;
-	argv[*argc] = NULL;
-	return (argv);
-}
-
-char	**parse_arguments(t_token **cur)
-{
-	int		size;
-	int		argc;
-	char	**argv;
-
-	size = 4;
-	argc = 0;
-	argv = malloc(sizeof(char *) * (size + 1));
-	if (!argv)
-		return (NULL);
-	argv[0] = NULL;
-	while (*cur && (*cur)->type == T_WORD)
-	{
-		argv = add_argument(argv, &argc, &size, (*cur)->value);
-		if (!argv)
-			return (NULL);
-		next_token(cur);
-	}
-	if (argc == 0)
-	{
-		free(argv);
-		return (NULL);
-	}
-	return (argv);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_background.c                                 :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 18:36:56 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 16:14:42 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-#include "lexer.h"
-
-t_ast	*parse_background(t_token **cur)
-{
-	t_ast	*left;
-	t_ast	*right;
-	t_ast	*node;
-
-	left = parse_sequence(cur);
-	if (!left)
-		return (NULL);
-
-	while (*cur && (*cur)->type == T_BG)
-	{
-		next_token(cur);
-		if (!*cur || (*cur)->type == T_SEMI || (*cur)->type == T_PIPE
-			|| (*cur)->type == T_AND || (*cur)->type == T_OR
-			|| (*cur)->type == T_RPAREN)
-		{
-			// No hay más comandos, se permite background sin "right"
-			node = ast_new_binary(N_BACKGROUND, left, NULL);
-			if (!node)
-			{
-				free_ast(left);
-				return (NULL);
-			}
-			left = node;
-			break ;
-		}
-		right = parse_sequence(cur);
-		if (!right)
-		{
-			free_ast(left);
-			return (NULL);
-		}
-		node = ast_new_binary(N_BACKGROUND, left, right);
-		if (!node)
-		{
-			free_ast(left);
-			free_ast(right);
-			return (NULL);
-		}
-		left = node;
-	}
-	return (left);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_command_and_redirection.c                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 06:56:48 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 16:15:45 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-#include "lexer.h"
-
-t_ast	*parse_command_and_redirections(t_token **cur)
-{
-	t_ast	*cmd_node;
-	t_ast	*redir_head;
-	t_ast	*redir_tail;
-
-	cmd_node = NULL;
-	redir_head = NULL;
-	redir_tail = NULL;
-	if (!parse_redirections(cur, &redir_head, &redir_tail))
-		return (NULL);
-	if (*cur && (*cur)->type == T_LPAREN)
-		cmd_node = parse_subshell(cur);
-	else if (*cur && (*cur)->type == T_WORD)
-		cmd_node = parse_simple_command(cur);
-	else
-	{
-		if (!redir_head)
-		{
-			ft_dprintf(2,
-				"minishell: syntax error near unexpected token '%s'\n",
-				*cur ? (*cur)->value : "newline");
-			return (NULL);
-		}
-		ft_dprintf(2,
-			"minishell: syntax error: command expected after redirections\n");
-		free_ast(redir_head);
-		return (NULL);
-	}
-	if (!cmd_node)
-	{
-		free_ast(redir_head);
-		return (NULL);
-	}
-	if (!parse_redirections(cur, &redir_head, &redir_tail))
-	{
-		free_ast(cmd_node);
-		free_ast(redir_head);
-		return (NULL);
-	}
-	if (redir_head)
-		cmd_node->cmd.redirections = redir_head;
-	return (cmd_node);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parser_pipeline.c                                  :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 18:38:38 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/28 03:02:40 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-#include "lexer.h"
-
-t_ast	*parse_pipeline(t_token **cur)
-{
-	t_ast	*left;
-	t_ast	*right;
-	t_ast	*node;
-
-	left = parse_command_and_redirections(cur);
-	if (!left)
-		return (NULL);
-
-	while (*cur && (*cur)->type == T_PIPE)
-	{
-		next_token(cur);
-		if (!*cur)
-		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
-			free_ast(left);
-			return (NULL);
-		}
-		right = parse_command_and_redirections(cur);
-		if (!right)
-		{
-			free_ast(left);
-			return (NULL);
-		}
-		node = ast_new_binary(N_PIPE, left, right);
-		if (!node)
-		{
-			free_ast(left);
-			free_ast(right);
-			return (NULL);
-		}
-		left = node;
-	}
-	return (left);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_redirections.c                               :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 01:03:45 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:01:15 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-#include "parser.h"
-#include "ast.h"
-
-static t_redir_type	token_type_to_redir_type(t_token_type type)
-{
-	if (type == T_REDIR_IN)      return REDIR_IN;
-	if (type == T_REDIR_OUT)     return REDIR_OUT;
-	if (type == T_APPEND)        return REDIR_APPEND;
-	if (type == T_HEREDOC)       return REDIR_HEREDOC;
-	if (type == T_REDIR_ERR)     return REDIR_ERR;
-	if (type == T_APPEND_ERR)    return REDIR_APPEND_ERR;
-	if (type == T_REDIR_ALL)     return REDIR_ALL;
-	if (type == T_APPEND_ALL)    return REDIR_APPEND_ALL;
-	if (type == T_FORCE_OUT)     return REDIR_FORCE;
-	if (type == T_DUP_IN)        return REDIR_DUP_IN;
-	if (type == T_DUP_OUT)       return REDIR_DUP_OUT;
-	return REDIR_INVALID;
-}
-
-int	is_redirection(t_token *tok)
-{
-	if (!tok) return 0;
-	return (tok->type == T_REDIR_IN || tok->type == T_REDIR_OUT
-		|| tok->type == T_APPEND || tok->type == T_HEREDOC
-		|| tok->type == T_REDIR_ERR || tok->type == T_APPEND_ERR
-		|| tok->type == T_REDIR_ALL || tok->type == T_APPEND_ALL
-		|| tok->type == T_FORCE_OUT || tok->type == T_DUP_IN
-		|| tok->type == T_DUP_OUT);
-}
-
-int	parse_redirections(t_token **cur, t_ast **head, t_ast **tail)
-{
-	while (*cur && is_redirection(*cur))
-	{
-		t_token      *redir_tok = *cur;
-		t_redir_type  rtype     = token_type_to_redir_type(redir_tok->type);
-		t_token      *file_tok;
-		t_ast        *new_redir;
-		int           fd;
-
-		next_token(cur);
-		file_tok = *cur;
-		if (!file_tok || file_tok->type != T_WORD || rtype == REDIR_INVALID)
-		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n",
-				file_tok ? file_tok->value : "newline");
-			return (0);
-		}
-
-		if (rtype == REDIR_DUP_OUT || rtype == REDIR_DUP_IN)
-		{
-			if (!ft_isposfdstr(file_tok->value))
-			{
-				ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n", file_tok->value);
-				return (0);
-			}
-			fd = ft_atoi(file_tok->value);
-			new_redir = ast_new_redir(NULL, NULL, rtype, fd);
-		}
-		else if (rtype == REDIR_HEREDOC)
-		{
-			/* Guardamos SOLO el delimitador; se leerá en ejecución */
-			new_redir = ast_new_redir(NULL, ft_strdup(file_tok->value), rtype, -1);
-		}
-		else
-		{
-			new_redir = ast_new_redir(ft_strdup(file_tok->value), NULL, rtype, -1);
-		}
-
-		if (!new_redir)
-			return (0);
-
-		next_token(cur);
-		if (!*head) { *head = new_redir; *tail = new_redir; }
-		else { (*tail)->bin.right = new_redir; *tail = new_redir; }
-	}
-	return (1);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_sequence.c                                   :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/25 22:23:59 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 16:14:59 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-
-t_ast	*parse_sequence(t_token **cur)
-{
-	t_ast	*left;
-	t_ast	*right;
-	t_ast	*node;
-
-	left = parse_and_or(cur);
-	if (!left)
-		return (NULL);
-
-	while (*cur && (*cur)->type == T_SEMI)
-	{
-		next_token(cur);
-		if (!*cur)
-		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
-			free_ast(left);
-			return (NULL);
-		}
-		right = parse_and_or(cur);
-		if (!right)
-		{
-			free_ast(left);
-			return (NULL);
-		}
-		node = ast_new_binary(N_SEQUENCE, left, right);
-		if (!node)
-		{
-			free_ast(left);
-			free_ast(right);
-			return (NULL);
-		}
-		left = node;
-	}
-	return (left);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_simple_command.c                             :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 18:39:45 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/29 14:14:36 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-#include "lexer.h"
-
-t_ast	*parse_simple_command(t_token **cur)
-{
-	t_ast	*redir_head = NULL;
-	t_ast	*redir_tail = NULL;
-	t_ast	*cmd_node;
-	char	**argv;
-
-	if (is_lparen(*cur))
-	{
-		cmd_node = parse_subshell(cur);
-		if (!cmd_node)
-			return (NULL);
-		if (!parse_redirections(cur, &redir_head, &redir_tail))
-		{
-			free_ast(cmd_node);
-			return (NULL);
-		}
-		cmd_node->subshell.redirections = redir_head;
-		return (cmd_node);
-	}
-
-	if (!parse_redirections(cur, &redir_head, &redir_tail))
-		return (NULL);
-
-	argv = parse_arguments(cur);
-	if (!argv)
-	{
-		if (redir_head)
-		{
-			free_ast(redir_head);
-			ft_dprintf(2, "minishell: syntax error: empty command before redirection\n");
-			return (NULL);
-		}
-		ft_dprintf(2, "minishell: syntax error: empty command or unexpected token\n");
-		return (NULL);
-	}
-
-	if (!parse_redirections(cur, &redir_head, &redir_tail))
-	{
-		ft_free_strtab(argv);
-		free_ast(redir_head);
-		return (NULL);
-	}
-
-	cmd_node = ast_new_command(argv, redir_head);
-	if (!cmd_node)
-	{
-		ft_free_strtab(argv);
-		free_ast(redir_head);
-		return (NULL);
-	}
-	return (cmd_node);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_simple_utils.c                               :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/13 19:05:39 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:52:11 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"   
-#include "lexer.h"
-
-int	is_lparen(t_token *tok)
-{
-	if (!tok)
-		return (0);
-	return (tok->type == T_LPAREN);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   parse_subshell.c                                   :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 00:59:14 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/29 14:14:29 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "parser.h"
-#include "ast.h"
-#include "lexer.h"
-
-t_ast	*parse_subshell(t_token **cur)
-{
-	t_ast	*sub_ast;
-	t_ast	*node;
-
-	next_token(cur);
-	if (!*cur)
-	{
-		ft_dprintf(2,
-			"minishell: syntax error: unexpected end of input after '('\n");
-		return (NULL);
-	}
-	sub_ast = parse_background(cur);
-	if (!sub_ast)
-		return (NULL);
-	if (!(*cur) || (*cur)->type != T_RPAREN)
-	{
-		ft_dprintf(2, "minishell: syntax error: missing ')'\n");
-		free_ast(sub_ast);
-		return (NULL);
-	}
-	next_token(cur);
-	node = ast_new_subshell(sub_ast, NULL);
-	if (!node)
-	{
-		free_ast(sub_ast);
-		return (NULL);
-	}
-	return (node);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   cleanup_shell.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/17 03:25:37 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:52:36 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-#include "env.h"
-
-// --- NUEVO: helper para imprimir errores con mapeo 126/127 ---
-static int has_slash_local(const char *s)
-{
-        for (; s && *s; s++) if (*s == '/') return 1;
-        return 0;
-}
-
-int print_exec_error(t_shell *shell, const char *cmd, int err_code)
-{
-        int ret;
-
-        if (!cmd || !*cmd)
-        {
-                ft_dprintf(2, "minishell: : command not found\n");
-                shell->exit_status = 127;
-                return 127;
-        }
-
-        if (!has_slash_local(cmd) && err_code == ENOENT)
-        {
-                // No hay '/', no encontrado en PATH → 127
-                ft_dprintf(2, "minishell: %s: command not found\n", cmd);
-                ret = 127;
-        }
-        else
-        {
-                // Ruta con '/', o encontrado pero no ejecutable u otros errores
-                ft_dprintf(2, "minishell: %s: %s\n", cmd, strerror(err_code));
-                if (err_code == EACCES || err_code == ENOEXEC || err_code == EISDIR || err_code == EPERM)
-                        ret = 126;   // encontrado pero no se puede ejecutar → 126
-                else if (err_code == ENOENT || err_code == ENOTDIR || err_code == ENAMETOOLONG || err_code == ELOOP)
-                        ret = 127;   // no encontrado → 127
-                else
-                        ret = 126;   // por defecto, fallo de ejecución ≈ 126
-        }
-        shell->exit_status = ret;
-        return ret;
-}
-
-// Limpia los recursos utilizados en cada iteración del bucle interactivo
-// Esto se llama al final de cada iteración del bucle interactivo
-// para evitar fugas de memoria y asegurar que cada comando se ejecute con un estado limpio
-// y sin residuos de la iteración anterior.
-void    cleanup_loop(t_shell *shell)
-{
-    if (shell->line)
-    {
-        free(shell->line);
-        shell->line = NULL;
-    }
-    if (shell->tokens)
-    {
-        free_token_list(shell->tokens);
-        shell->tokens = NULL;
-    }
-}
-
-// Limpia todos los recursos del shell al finalizar
-// Se asume que se llama al final de la ejecución del shell, ya sea al salir
-// del bucle interactivo o al ejecutar un script o comando único.
-// Libera la memoria utilizada por las estructuras del shell y restaura la configuración del terminal.
-// También libera el nombre del programa (argv[0]) que se duplicó al inicio.
-// Se debe llamar a esta función antes de que el programa termine
-// para evitar fugas de memoria y asegurar que todos los recursos se liberen adecuadamente.
-void    cleanup_shell(t_shell *shell)
-{
-    // Libera los recursos dinámicos
-    if (shell->env)
-    {
-        free_env_list(shell->env); // Asumido que libera la lista enlazada del entorno
-        shell->env = NULL;
-    }
-    if (shell->line)
-    {
-        free(shell->line);
-        shell->line = NULL;
-    }
-    if (shell->tokens)
-    {
-        free_token_list(shell->tokens);
-        shell->tokens = NULL;
-    }
-    if (shell->program_name)
-    {
-        free(shell->program_name);
-        shell->program_name = NULL;
-    }
-
-    // Restaura la configuración del terminal (si aplica)
-    restore_vquit(); // Asumido que restaura los manejadores de señales o modos del terminal
-}
-
-/*
-int	print_exec_error(t_shell *shell, const char *cmd, int err_code)
-{
-	int	status;
-
-	if (err_code == ENOENT)
-	{
-		ft_dprintf(2, "minishell: %s: command not found\n", cmd);
-		status = 127;
-	}
-	else if (err_code == EACCES)
-	{
-		if (ft_strchr(cmd, '/'))
-			ft_dprintf(2, "%s: Permission denied\n", cmd);
-		else
-			ft_dprintf(2, "minishell: %s: permission denied\n", cmd);
-		status = 126;
-	}
-	else if (err_code == EISDIR)
-	{
-		ft_dprintf(2, "minishell: %s: is a directory\n", cmd);
-		status = 126;
-	}
-	else
-	{
-		ft_dprintf(2, "minishell: %s: execution error\n", cmd);
-		status = 1;
-	}
-	shell->exit_status = status;
-	return (status);
-}
-*//* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   handle_help_version.c                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/16 22:44:20 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/26 15:20:48 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-int	handle_help_version(int argc, char **argv)
-{
-	if (argc == 2 && ft_strcmp(argv[1], "--help") == 0)
-	{
-		print_help();
-		return (0);
-	}
-	if (argc == 2 && ft_strcmp(argv[1], "--version") == 0)
-	{
-		print_version();
-		return (0);
-	}
-	return (-1);
-}
-
-void	print_help(void)
-{
-	ft_dprintf(1, "minishell: a minimal shell implementation\n");
-	ft_dprintf(1, "Usage:  ./minishell [option] [script-file]\n");
-	ft_dprintf(1, "Options:\n");
-	ft_dprintf(1, "        -c command      execute command\n");
-	ft_dprintf(1, "        script-file     execute commands from script file\n");
-	ft_dprintf(1, "        --help          display this help and exit\n");
-	ft_dprintf(1, "        --version       output version information and exit\n");
-	ft_dprintf(1, "\n");
-	ft_dprintf(1, "If no option or script-file is given, minishell starts in interactive mode.\n");
-}
-
-void	print_usage(const char *invalid)
-{
-	if (invalid)
-		ft_dprintf(2, "minishell: %s: invalid option\n", invalid);
-	ft_dprintf(2, "Usage:  ./minishell [option] [script-file]\n");
-	ft_dprintf(2, "Options:\n");
-	ft_dprintf(2, "        -c command      execute command\n");
-	ft_dprintf(2, "        script-file     execute commands from script file\n");
-	ft_dprintf(2, "        --help          display this help and exit\n");
-	ft_dprintf(2, "        --version       output version information and exit\n");
-}
-
-void	print_version(void)
-{
-	ft_dprintf(1, "minishell, version 1.0\n");
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   init_shell.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/17 03:25:09 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/27 19:56:47 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "env.h"
-
-int	init_shell_name(t_shell *shell, char **argv)
-{
-	ft_memset(shell, 0, sizeof(t_shell));
-	shell->exit_status = 0;
-	shell->program_name = ft_strdup(argv[0]);
-	if (!shell->program_name)
-	{
-		ft_dprintf(2, "minishell: Error fatal: No se pudo asignar el nombre del programa.\n");
-		return (1);
-	}
-	return (0);
-}
-
-int init_env(t_shell *shell, char **envp)
-{
-    shell->env = init_env_list(envp);
-    if (!shell->env)
-    {
-        ft_dprintf(2, "minishell: Error fatal: No se pudo inicializar el entorno.\n");
-        return (1);
-    }
-    return (0);
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   run_interactive.c                                  :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/10 13:09:44 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:41:11 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-/* helpers de cierre de comillas/backslash (tus versiones) */
-static int ft_quotes_closed(const char *line)
-{
-    int i = 0, state = 0;
-    while (line && line[i])
-    {
-        if (!state && (line[i] == '\'' || line[i] == '"')) state = line[i];
-        else if (state == '\'' && line[i] == '\'') state = 0;
-        else if (state == '"' && line[i] == '\\' &&
-                 (line[i + 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '`')) i++;
-        else if (state == '"' && line[i] == '"') state = 0;
-        else if (!state && line[i] == '\\' && line[i + 1]) i++;
-        i++;
-    }
-    return (state == 0);
-}
-
-static int ft_backslach_closed(char *line)
-{
-    int i, count;
-
-    if (!line) return (1);
-    i = (int)ft_strlen(line) - 1;
-    count = 0;
-    while (i >= 0 && line[i] == '\\') { count++; i--; }
-    return ((count % 2) == 0);
-}
-
-char *read_line_interactive(t_shell *shell)
-{
-    char *next;
-
-    /* aseguramos prompt limpio y TTY sano */
-    setup_prompt_signals();
-    g_signal = 0;
-
-    shell->line = readline("\001\033[1;35m\002minishell$ \001\033[0m\002");
-    if (!shell->line)
-        return NULL;
-
-    while (!ft_quotes_closed(shell->line) || !ft_backslach_closed(shell->line))
-    {
-        setup_prompt_signals();
-        next = readline("> ");
-        if (!next) { free(shell->line); shell->line = NULL; return NULL; }
-        shell->line = ft_strjoin_free_s1(shell->line, "\n");
-        if (!shell->line) { free(next); return NULL; }
-        shell->line = ft_strjoin_free_s1(shell->line, next);
-        free(next);
-    }
-    return shell->line;
-}
-void run_interactive(t_shell *shell)
-{
-    shell->is_interactive = 1;
-
-    while (1)
-    {
-        setup_prompt_signals();          /* prompt: INT handler + QUIT ignorado */
-        if (shell->line) { free(shell->line); shell->line = NULL; }
-
-        shell->line = read_line_interactive(shell); /* usa readline con el prompt */
-
-        if (!shell->line)                 /* Ctrl-D en línea vacía */
-            break;
-
-        if (shell->line[0] == '\0') {     /* Enter vacío o Ctrl-C en prompt */
-            free(shell->line);
-            shell->line = NULL;
-            continue;
-        }
-
-        add_history(shell->line);
-
-        /* PADRE ignora señales mientras ejecuta (y las restablece el hijo) */
-        setup_exec_parent_signals();
-
-        if (shell->tokens) { free_token_list(shell->tokens); shell->tokens = NULL; }
-        shell_exec(shell);
-
-        /* Al volver de ejecutar, vuelve al modo prompt */
-        setup_prompt_signals();
-        cleanup_loop(shell);
-
-        if (shell->should_exit)
-            break;
-    }
-    if (shell->is_interactive)
-        write(1, "exit\n", 5);
-    rl_clear_history();
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   run_non_interactive.c                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/10/22 20:32:53 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 16:46:27 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-#include "parser.h"
-#include "expand.h"
-#include "exec.h"
-
-// Quita '\n' final si existe (opcionalmente también '\r' si llegara CRLF).
-static void chomp_nl(char *s)
-{
-    size_t len;
-
-    if (!s)
-        return;
-    len = ft_strlen(s);
-    if (len && s[len - 1] == '\n')
-    {
-        s[len - 1] = '\0';
-        if (len >= 2 && s[len - 2] == '\r') // por si viniera CRLF
-            s[len - 2] = '\0';
-    }
-}
-
-void run_non_interactive(t_shell *shell)
-{
-    char *line;
-
-    shell->is_interactive = 0;
-    // En no-interactivo, el caller debe haber llamado a setup_default_signals()
-    // para no redibujar prompt y dejar señales por defecto.
-    while (1)
-    {
-        if (shell->line)
-        {
-            free(shell->line);
-            shell->line = NULL;
-        }
-        line = get_next_line(STDIN_FILENO);   // <-- usamos tu GNL
-        if (!line)
-            break;                            // EOF o error -> salir bucle
-        chomp_nl(line);                        // quitamos '\n' final
-        shell->line = line;
-        if (*shell->line)                      // ignorar líneas vacías
-        {
-            // El padre no debe imprimir nada ni reaccionar a SIGINT/SIGQUIT.
-            // Los hijos restaurarán señales por defecto antes de execve().
-            setup_exec_parent_signals();
-            if (shell->tokens)
-            {
-                free_token_list(shell->tokens);
-                shell->tokens = NULL;
-            }
-            shell_exec(shell);
-        }
-        cleanup_loop(shell);
-        if (shell->should_exit)
-            break;
-    }
-    // Importante: NO imprimir "exit\n" aquí (solo en modo interactivo).
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   shell_exec.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 14:49:39 by acoronad          #+#    #+#             */
-/*   Updated: 2025/07/26 16:07:53 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "lexer.h"
-#include "expand.h"
-#include "parser.h"
-#include "ast.h"
-
-int	shell_exec(t_shell *shell)
-{
-	shell->tokens = lexer(shell->line);
-	if (!shell->tokens)
-	{
-		shell->exit_status = 2; // Error de sintaxis como Bash
-		return (2);
-	}
-//	prueba_lexer(shell);
-	expand_variables(shell);
-//	prueba_expansion(shell);
-	shell->ast = build_ast(shell->tokens);
-	free_token_list(shell->tokens);
-	shell->tokens = NULL;
-	if (!shell->ast)
-	{
-		shell->exit_status = 2; // Error de sintaxis como Bash
-		return (2);
-	}
-//	prueba_ast(shell);
-	execute_ast(shell->ast, shell);
-	return (shell->exit_status);
-}
-
-char	*token_type_str(t_token_type type)
-{
-	if (type == T_WORD)
-		return ("WORD");
-	if (type == T_PIPE)
-		return ("PIPE");
-	if (type == T_OR)
-		return ("OR");
-	if (type == T_AND)
-		return ("AND");
-	if (type == T_BG)
-		return ("BG");
-	if (type == T_SEMI)
-		return ("SEMI");
-	if (type == T_REDIR_IN)
-		return ("REDIR_IN");
-	if (type == T_REDIR_OUT)
-		return ("REDIR_OUT");
-	if (type == T_APPEND)
-		return ("APPEND");
-	if (type == T_HEREDOC)
-		return ("HEREDOC");
-	if (type == T_REDIR_ERR)
-		return ("REDIR_ERR");
-	if (type == T_APPEND_ERR)
-		return ("APPEND_ERR");
-	if (type == T_REDIR_ALL)
-		return ("REDIR_ALL");
-	if (type == T_APPEND_ALL)
-		return ("APPEND_ALL");
-	if (type == T_FORCE_OUT)
-		return ("FORCE_OUT");
-	if (type == T_HEREDOC_STR)
-		return ("HEREDOC_STR");
-	if (type == T_DUP_IN)
-		return ("DUP_IN");
-	if (type == T_DUP_OUT)
-		return ("DUP_OUT");
-	if (type == T_LPAREN)
-		return ("LPAREN");
-	if (type == T_RPAREN)
-		return ("RPAREN");
-	if (type == T_LBRACE)
-		return ("LBRACE");
-	if (type == T_RBRACE)
-		return ("RBRACE");
-	if (type == T_EQUAL)
-		return ("EQUAL");
-	if (type == T_UNKNOWN)
-		return ("UNKNOWN");
-	return ("OTHER");
-}
-
-static char	*quote_type_str(t_quote q)
-{
-	if (q == NO_QUOTE)
-		return ("NO_QUOTE");
-	if (q == SINGLE_QUOTE)
-		return ("SINGLE_QUOTE");
-	if (q == DOUBLE_QUOTE)
-		return ("DOUBLE_QUOTE");
-	return ("OTHER");
-}
-
-void	prueba_lexer(t_shell *shell)
-{
-	t_token	*tok;
-	int		i;
-
-	tok = shell->tokens;
-	i = 0;
-	if (!tok)
-	{
-		printf("No tokens found.\n");
-		return ;
-	}
-	while (tok)
-	{
-		printf("Token %d:\n", i);
-		printf("  value: \"%s\"\n", tok->value);
-		printf("  type: %s\n", token_type_str(tok->type));
-		printf("  quote: %s\n", quote_type_str(tok->quoted));
-		tok = tok->next;
-		i++;
-	}
-}
-
-void	prueba_env(t_shell *shell)
-{
-	t_env	*env;
-	int		i;
-
-	env = shell->env;
-	i = 0;
-	if (!env)
-	{
-		printf("No environment variables found.\n");
-		return ;
-	}
-	printf("Current environment variables:\n");
-	while (env)
-	{
-		printf("🧪 [%d] key = \"%s\" | value = \"%s\" | exported = %d\n",
-			i,
-			env->key ? env->key : "(null)",
-			env->value ? env->value : "(null)",
-			env->exported);
-		env = env->next;
-		i++;
-	}
-}
-
-void	prueba_expansion(t_shell *shell)
-{
-	t_token	*tok;
-	int		i;
-
-	tok = shell->tokens;
-	i = 0;
-	if (!tok)
-	{
-		printf("No tokens found for expansion.\n");
-		return ;
-	}
-	printf("Prueba de expansión:\n");
-	while (tok)
-	{
-		printf("Token %d:\n", i);
-		printf("  value: \"%s\"\n", tok->value ? tok->value : "(null)");
-		printf("  type: %s\n", token_type_str(tok->type));
-		printf("  quote: %s\n", quote_type_str(tok->quoted));
-		tok = tok->next;
-		i++;
-	}
-	printf("Prompt simulado: ");
-	tok = shell->tokens;
-	while (tok)
-	{
-		if (tok->value)
-			printf("%s ", tok->value);
-		tok = tok->next;
-	}
-	printf("\n");
-}
-
-#include <stdio.h>
-
-static void print_indent(int level)
-{
-    while (level--)
-        printf("  ");
-}
-
-void prueba_ast(t_shell *shell)
-{
-    if (!shell || !shell->ast)
-    {
-        printf("No hay AST que mostrar.\n");
-        return;
-    }
-    printf("======= AST DEBUG =======\n");
-    print_ast_debug(shell->ast, 0);
-    printf("=========================\n");
-}
-#include <stdio.h>
-
-void print_ast_debug(t_ast *node, int level)
-{
-    if (!node)
-        return;
-
-    print_indent(level);
-    printf("Node type: ");
-
-    if (node->type == N_COMMAND)
-    {
-        printf("N_COMMAND\n");
-        print_indent(level);
-        printf("  argv:");
-        if (node->cmd.argv)
-        {
-            for (int i = 0; node->cmd.argv[i]; i++)
-                printf(" \"%s\"", node->cmd.argv[i]);
-        }
-        printf("\n");
-
-        if (node->cmd.redirections)
-        {
-            print_indent(level);
-            printf("  redirections:\n");
-            t_ast *redir = node->cmd.redirections;
-            while (redir)
-            {
-                print_ast_debug(redir, level + 2);
-                redir = redir->bin.right; // asumimos lista ligada con bin.right
-            }
-        }
-    }
-    else if (node->type == N_REDIR)
-    {
-        printf("N_REDIR\n");
-        print_indent(level);
-        printf("  redir_type: %d\n", node->redir.redir_type);
-        print_indent(level);
-        printf("  filename: \"%s\"\n", node->redir.filename);
-        print_indent(level);
-        printf("  delimiter: \"%s\"\n", node->redir.delimiter ? node->redir.delimiter : "NULL");
-        print_indent(level);
-        printf("  redir_fd: %d\n", node->redir.redir_fd);
-    }
-    else if (node->type == N_PIPE || node->type == N_AND
-             || node->type == N_OR || node->type == N_SEQUENCE
-             || node->type == N_BACKGROUND)
-    {
-        const char *type_str = (node->type == N_PIPE) ? "N_PIPE" :
-                              (node->type == N_AND) ? "N_AND" :
-                              (node->type == N_OR) ? "N_OR" :
-                              (node->type == N_SEQUENCE) ? "N_SEQUENCE" :
-                              (node->type == N_BACKGROUND) ? "N_BACKGROUND" : "UNKNOWN";
-
-        printf("%s\n", type_str);
-        print_indent(level);
-        printf("  left:\n");
-        print_ast_debug(node->bin.left, level + 1);
-        print_indent(level);
-        printf("  right:\n");
-        print_ast_debug(node->bin.right, level + 1);
-    }
-    else if (node->type == N_SUBSHELL)
-    {
-        printf("N_SUBSHELL\n");
-        print_indent(level);
-        printf("  child:\n");
-        print_ast_debug(node->subshell.child, level + 1);
-
-        if (node->subshell.redirections)
-        {
-            print_indent(level);
-            printf("  redirections:\n");
-            t_ast *redir = node->subshell.redirections;
-            while (redir)
-            {
-                print_ast_debug(redir, level + 2);
-                redir = redir->bin.right;
-            }
-        }
-    }
-    else
-    {
-        printf("Unknown node type %d\n", node->type);
-    }
-}
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   shell_modes.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/26 12:52:57 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/22 20:48:01 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "signals.h"
-//#include "exec.h"
-
-/*
-static int	run_one_command_mode(char **argv, t_shell *shell)
-{
-	shell->is_one_command = 1;
-	shell->is_interactive = 0;
-	execute_one_command(argv[2], shell);
-	return (shell->exit_status);
-}
-
-static int	run_script_mode(char **argv, t_shell *shell)
-{
-	shell->is_script = 1;
-	shell->is_interactive = 0;
-	execute_script(argv[1], shell);
-	return (shell->exit_status);
-}
-
-static int	handle_invalid_args(char *program_name)
-{
-	print_usage(program_name);
-	return (2);
-}
-*/
-
-int run_shell_modes(int argc, char **argv, char **envp, t_shell *shell)
-{
-    int ret;
-
-    ret = handle_help_version(argc, argv);
-    if (ret != -1)
-        return (ret);
-
-    if (init_env(shell, envp) != 0)
-        return (1);
-
-    shell->is_interactive = isatty(STDIN_FILENO) && isatty(STDOUT_FILENO);
-
-    if (shell->is_interactive) {
-        setup_signals();         // señales base
-        run_interactive(shell);  // con prompt
-    } else {
-        setup_default_signals(); // señales por defecto (no prompt)
-        run_non_interactive(shell);
-    }
-    return shell->exit_status;
-}
-
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   signals.c                                          :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/10 13:26:15 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 12:07:29 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-
-/* Única global permitida */
-volatile sig_atomic_t g_signal = 0;
-
-/* -------------------------------------------------------------------------- */
-/*  ECHOCTL on/off: muestra los controles como ^C/^\\ si está activo.         */
-/*  (No guardamos estado global adicional; simplemente forzamos el bit.)      */
-/* -------------------------------------------------------------------------- */
-void    set_echoctl(int enable)
-{
-    struct termios t;
-
-    if (tcgetattr(STDIN_FILENO, &t) == -1)
-        return;
-#ifdef ECHOCTL
-    if (enable)
-        t.c_lflag |= ECHOCTL;
-    else
-        t.c_lflag &= ~ECHOCTL;
-#endif
-    tcsetattr(STDIN_FILENO, TCSANOW, &t);
-}
-
-/* Compat con tu código existente */
-void    disable_vquit(void)   { set_echoctl(0); }
-void    restore_vquit(void)   { set_echoctl(1); }
-
-/* -------------------------------------------------------------------------- */
-/*  Handler de SIGINT en el PROMPT:                                           */
-/*  - Escribe salto de línea                                                  */
-/*  - Limpia la línea de readline y redibuja el prompt                        */
-/*  - Marca g_signal para que el bucle principal ponga exit_status=130         */
-/* -------------------------------------------------------------------------- */
-void    handle_sigint(int sig)
-{
-    (void)sig;
-    g_signal = 1;
-    write(STDOUT_FILENO, "\n", 1);
-    rl_replace_line("", 0);
-    rl_on_new_line();
-    rl_redisplay();
-}
-
-/* En el prompt, Ctrl-\ no hace nada */
-void    handle_sigquit(int sig)
-{
-    (void)sig;
-    /* nada */
-}
-
-/* -------------------------------------------------------------------------- */
-/*  Prompt interactivo:                                                       */
-/*  - Mostrar ^C/^\ (ECHOCTL activado).                                       */
-/*  - SIGINT -> handler que aborta línea.                                     */
-/*  - SIGQUIT -> ignorado.                                                    */
-/* -------------------------------------------------------------------------- */
-void    setup_prompt_signals(void)
-{
-    set_echoctl(1);
-    signal(SIGINT,  handle_sigint);
-    signal(SIGQUIT, SIG_IGN);
-}
-
-/* Padre durante ejecución de comandos: no debe matar al hijo al pulsar ^C/^\ */
-void    setup_exec_parent_signals(void)
-{
-    signal(SIGINT,  SIG_IGN);
-    signal(SIGQUIT, SIG_IGN);
-}
-
-/* Defaults (modo no-interactivo). También lo puedes usar si quieres resetear. */
-void    setup_default_signals(void)
-{
-    set_echoctl(1); /* ver ^C/^\ en programas */
-    signal(SIGINT,  SIG_DFL);
-    signal(SIGQUIT, SIG_DFL);
-}
-
-/* Compat: muchos sitios llaman a setup_signals() al inicio -> prompt. */
-void    setup_signals(void)
-{
-    setup_prompt_signals();
-}
-# **************************************************************************** #
-#                                MINISHELL MAKEFILE                            #
-# **************************************************************************** #
-
-NAME        = minishell
-
-CC          = gcc
-CFLAGS      = -Wall -Wextra -Werror -g
-INCLUDES    = -Iincludes -Ilibft -Ilibft/ft_dprintf -Ilibft/gnl
-
-LIBFT_DIR   = libft
-LIBFT       = $(LIBFT_DIR)/libft.a
-DPRINTF     = $(LIBFT_DIR)/ft_dprintf/libftdprintf.a
-
-SRC_DIR     = src
-OBJ_DIR     = obj
-
-# Encuentra todos los .c en src y añade minishell.c
-SRC         = $(shell find $(SRC_DIR) -name "*.c") minishell.c
-OBJ         = $(SRC:%.c=$(OBJ_DIR)/%.o)
-
-# Colores (opcional)
-GREEN       := \033[0;32m
-RESET       := \033[0m
-
-# Regla para compilar objetos y crear directorios si no existen
-$(OBJ_DIR)/%.o: %.c
-	@mkdir -p $(dir $@)
-	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@
-
-# Regla principal: compilar y enlazar ejecutable
-$(NAME): $(DPRINTF) $(LIBFT) $(OBJ)
-	$(CC) $(CFLAGS) $(OBJ) $(DPRINTF) $(LIBFT) -o $(NAME) -lreadline
-	@echo "$(GREEN)¡Minishell compilada y lista!$(RESET)"
-
-# Compilar libft y dprintf
-$(LIBFT):
-	$(MAKE) -C $(LIBFT_DIR)
-
-$(DPRINTF):
-	$(MAKE) -C $(LIBFT_DIR)/ft_dprintf
-
-# Limpieza de objetos y librerías
-clean:
-	rm -rf $(OBJ_DIR)
-	$(MAKE) -C $(LIBFT_DIR) clean
-	$(MAKE) -C $(LIBFT_DIR)/ft_dprintf clean
-
-fclean: clean
-	rm -f $(NAME)
-	$(MAKE) -C $(LIBFT_DIR) fclean
-	$(MAKE) -C $(LIBFT_DIR)/ft_dprintf fclean
-
-re: fclean all
-
-all: $(NAME)
-
-.PHONY: all clean fclean re/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   minishell.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/10 12:46:24 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 17:17:06 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "minishell.h"
-#include "signals.h"
-//#include "exec.h"
-
-int	main(int argc, char **argv, char **envp)
-{
-	t_shell	shell;
-	int		ret;
-
-//	setup_prompt_signals();
-	setup_signals();
-	if (init_shell_name(&shell, argv) != 0)
-		return (1);
-	ret = run_shell_modes(argc, argv, envp, &shell);
-	cleanup_shell(&shell);
-	return (ret);
-}
diff --git a/includes/ast.h b/includes/ast.h
index 8092124..7e63ecd 100644
--- a/includes/ast.h
+++ b/includes/ast.h
@@ -6,110 +6,7 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/11 15:24:41 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/26 19:36:13 by acoronad         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef AST_H
-# define AST_H
-
-/* Evitamos ciclos: no necesitamos lexer.h aquí, con una forward declaration basta. */
-typedef struct s_token t_token;   /* <- forward declaration clave */
-typedef struct s_ast   t_ast;
-typedef struct s_shell t_shell;
-
-# include "minishell.h"
-# include "env.h"
-# include "parser.h"
-
-typedef enum e_node_type
-{
-    N_COMMAND,
-    N_PIPE,
-    N_REDIR,
-    N_SUBSHELL,
-    N_SEQUENCE,
-    N_AND,
-    N_OR,
-    N_BACKGROUND
-}   t_node_type;
-
-typedef enum e_redir_type
-{
-        REDIR_IN,
-        REDIR_OUT,
-        REDIR_APPEND,
-        REDIR_HEREDOC,
-        REDIR_ERR,
-        REDIR_APPEND_ERR,
-        REDIR_ALL,
-        REDIR_APPEND_ALL,
-        REDIR_FORCE,
-        REDIR_DUP_IN,
-        REDIR_DUP_OUT,
-        REDIR_INVALID
-}       t_redir_type;
-
-struct s_ast
-{
-    t_node_type type;
-
-    union
-    {
-        struct
-        {
-            char        **argv;
-            struct s_ast *redirections; // lista ligada de N_REDIR
-        } cmd;
-
-        struct
-        {
-            char        *filename;
-            char        *delimiter;
-            t_redir_type redir_type;
-            int         redir_fd;
-        } redir;
-
-        struct
-        {
-            struct s_ast *left;
-            struct s_ast *right;
-        } bin;
-
-        struct
-        {
-            struct s_ast *child;
-            struct s_ast *redirections;
-        } subshell;
-    };
-};
-
-/* Constructores */
-t_ast   *ast_new_command(char **argv, t_ast *redirections);
-t_ast   *ast_new_redir(char *filename, char *delimiter,
-                       t_redir_type redir_type, int redir_fd);
-t_ast   *ast_new_binary(t_node_type type, t_ast *left, t_ast *right);
-t_ast   *ast_new_subshell(t_ast *child, t_ast *redirections);
-t_ast   *create_command_node(char **argv, t_ast *redir_list_head);
-
-/* Otros */
-t_ast   *ast_copy(t_ast *node);
-void    free_ast(t_ast *node);
-void    free_ast_recursive(t_ast *node);
-int     check_syntax(t_ast *node);
-int     is_lparen(t_token *tok);
-t_ast   *build_ast(t_token *tokens);
-
-#endif
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast.h                                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 15:24:41 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/25 15:26:54 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 14:38:02 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
diff --git a/includes/lexer.h b/includes/lexer.h
index 04af799..e95e505 100644
--- a/includes/lexer.h
+++ b/includes/lexer.h
@@ -6,17 +6,13 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/11 15:24:24 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/31 16:22:50 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 15:46:31 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #ifndef LEXER_H
 # define LEXER_H
 
-/* Importante: NO incluir minishell.h aquí para evitar ciclos. */
-/* Incluye solo lo mínimo estrictamente necesario. */
-# include <stddef.h>
-
 /* ------------------------- Tipos de token ------------------------- */
 typedef enum e_token_type
 {
@@ -30,8 +26,6 @@ typedef enum e_token_type
         T_REDIR_OUT,    // >
         T_APPEND,       // >>
         T_HEREDOC,      // <<
-        T_REDIR_ERR,    // 2>
-        T_APPEND_ERR,   // 2>>
         T_REDIR_ALL,    // &>
         T_APPEND_ALL,   // &>>
         T_FORCE_OUT,    // >|
@@ -40,12 +34,10 @@ typedef enum e_token_type
         T_DUP_OUT,      // >&
         T_LPAREN,       // (
         T_RPAREN,       // )
-        T_LBRACE,       // {
-        T_RBRACE,       // }
-        T_EQUAL,        // =
         T_UNKNOWN
 }       t_token_type;
 
+
 typedef enum e_quote
 {
         NO_QUOTE,
@@ -83,6 +75,8 @@ t_token_type    get_redir_right(const char *str, int len);
 t_token_type    get_redir_special(const char *str, int len);
 
 void            free_lexer_list_on_error(t_token **lst);
+void			free_token_list(t_token *tok);
+t_token			*free_null_token_list(t_token **lst);
 int             try_add_token(t_token **lst, char *str, t_token_type type, t_quote quote);
 
 /* Utilidades específicas de bash */
diff --git a/includes/minishell.h b/includes/minishell.h
index 101549a..a95a72f 100644
--- a/includes/minishell.h
+++ b/includes/minishell.h
@@ -6,7 +6,7 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/11/04 14:18:27 by acoronad          #+#    #+#             */
-/*   Updated: 2025/11/04 14:19:32 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 14:35:24 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -33,6 +33,7 @@
 # include "parser.h"
 # include "ast.h"
 # include "exec.h"
+# include "expand.h"
 # include "builtins.h"
 # include "signals.h"
 
@@ -55,9 +56,18 @@ struct s_shell
 	int     is_one_command;
 	int     should_exit;
 	char    *program_name;
+
 	pid_t   pid;              /* <-- usar pid_t */
 };
 
+/* Shell mode options */
+typedef struct s_opts {
+	int   flag_i;
+	int   flag_s;
+	char *cstr;
+	int   first_nonopt;
+} t_opts;
+
 extern volatile sig_atomic_t   g_signal;
 
 /* modos */
@@ -87,8 +97,12 @@ void    print_ast_debug(t_ast *node, int level);
 int     shell_exec(t_shell *shell);
 void    run_interactive(t_shell *shell);
 void    run_non_interactive(t_shell *shell);
+int     run_c_mode(t_shell *sh, const char *cmd);
+int     run_s_mode(t_shell *sh);
+int		parse_args_simple(int argc, char **argv, t_opts *o);
 
 /* lectura */
 char    *read_line_interactive(t_shell *shell);
+int		append_next_line(char **accum, const char *prompt);
 
 #endif
diff --git a/libft/ft_dprintf/ft_dprintf.c b/libft/ft_dprintf/ft_dprintf.c
index a29cfde..98e0429 100644
--- a/libft/ft_dprintf/ft_dprintf.c
+++ b/libft/ft_dprintf/ft_dprintf.c
@@ -14,9 +14,9 @@
 
 void	ft_dprintf(int fd, const char *format, ...)
 {
-	va_list	args;
-	char	*bf;
-	int		i;
+	va_list args;
+	char *bf;
+	int i;
 
 	if (!format)
 		return ;
diff --git a/libft/ft_dprintf/ft_dputstr_bf.c b/libft/ft_dprintf/ft_dputstr_bf.c
index 1fb3eba..9b8d0df 100644
--- a/libft/ft_dprintf/ft_dputstr_bf.c
+++ b/libft/ft_dprintf/ft_dputstr_bf.c
@@ -15,7 +15,7 @@
 
 void	ft_dputstr_bf(char **bf, const char *s)
 {
-	char *new;
+	char	*new;
 
 	if (!s)
 		new = ft_joinandfreestr(*bf, "(null)");
diff --git a/libft/ft_dprintf/ft_joinandfree.c b/libft/ft_dprintf/ft_joinandfree.c
index 0fe837e..d278881 100644
--- a/libft/ft_dprintf/ft_joinandfree.c
+++ b/libft/ft_dprintf/ft_joinandfree.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "ft_dprintf.h"
 #include "../libft.h"
+#include "ft_dprintf.h"
 
 char	*ft_joinandfreestr(char *s1, const char *s2)
 {
@@ -38,8 +38,8 @@ char	*ft_joinandfreestr(char *s1, const char *s2)
 
 char	*ft_joinandfree(char *s1, char s2)
 {
-	char	*str;
-	size_t	len1;
+	char *str;
+	size_t len1;
 
 	if (!s1)
 		return (NULL);
diff --git a/libft/ft_dprintf/ft_putint_base_bf.c b/libft/ft_dprintf/ft_putint_base_bf.c
index 3f52c7b..666cb65 100644
--- a/libft/ft_dprintf/ft_putint_base_bf.c
+++ b/libft/ft_dprintf/ft_putint_base_bf.c
@@ -15,8 +15,8 @@
 
 static int	ft_check_base(const char *base)
 {
-	int		i;
-	int		j;
+	int	i;
+	int	j;
 
 	if (!base || base[0] == '\0' || base[1] == '\0')
 		return (0);
@@ -39,7 +39,7 @@ static int	ft_check_base(const char *base)
 
 void	ft_pint_bs_bf(char **bf, unsigned int nbr, const char *base)
 {
-	int	base_ln;
+	int base_ln;
 	char *new;
 
 	base_ln = ft_check_base(base);
diff --git a/libft/ft_dprintf/ft_putnbr_df.c b/libft/ft_dprintf/ft_putnbr_df.c
index 6cba53e..86e6dbe 100644
--- a/libft/ft_dprintf/ft_putnbr_df.c
+++ b/libft/ft_dprintf/ft_putnbr_df.c
@@ -15,7 +15,7 @@
 
 void	ft_putnbr_bf(char **bf, int n)
 {
-	char *new;
+	char	*new;
 
 	if (n == -2147483648)
 	{
diff --git a/libft/ft_dprintf/ft_putptr_bf.c b/libft/ft_dprintf/ft_putptr_bf.c
index 2c8fca2..8305b97 100644
--- a/libft/ft_dprintf/ft_putptr_bf.c
+++ b/libft/ft_dprintf/ft_putptr_bf.c
@@ -17,7 +17,7 @@
 static void	ft_putnbr_x_bf(char **bf, uintptr_t ptr)
 {
 	const char	*base = "0123456789abcdef";
-	char *new;
+	char		*new;
 
 	if (ptr >= 16)
 		ft_putnbr_x_bf(bf, ptr / 16);
diff --git a/libft/ft_isalnum.c b/libft/ft_isalnum.c
index 987954d..cbdf86c 100644
--- a/libft/ft_isalnum.c
+++ b/libft/ft_isalnum.c
@@ -14,8 +14,8 @@
 
 int	ft_isalnum(int c)
 {
-	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z')
-		|| (c >= 'A' && c <= 'Z'))
+	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A'
+			&& c <= 'Z'))
 		return (1);
 	return (0);
 }
@@ -24,9 +24,13 @@ int	ft_isalnum(int c)
 
 int	main(void)
 {
-	char	c1 = 'A';
-	char	c2 = '5';
-	char	c3 = '@';
+	char	c1;
+	char	c2;
+	char	c3;
+
+	c1 = 'A';
+	c2 = '5';
+	c3 = '@';
 	printf("Is %c alphanumeric? %d\n", c1, ft_isalnum(c1));
 	printf("Is %c alphanumeric? %d\n", c2, ft_isalnum(c2));
 	printf("Is %c alphanumeric? %d\n", c3, ft_isalnum(c3));
diff --git a/libft/ft_isascii.c b/libft/ft_isascii.c
index 0620c82..6613f43 100644
--- a/libft/ft_isascii.c
+++ b/libft/ft_isascii.c
@@ -18,11 +18,16 @@ int	ft_isascii(int c)
 }
 /*
 #include <stdio.h>
+
 int	main(void)
 {
-	char	c1 = 'A';
-	char	c2 = '5';
-	char	c3 = '@';
+	char	c1;
+	char	c2;
+	char	c3;
+
+	c1 = 'A';
+	c2 = '5';
+	c3 = '@';
 	printf("Is %c ascii? %d\n", c1, ft_isascii(c1));
 	printf("Is %c ascii? %d\n", c2, ft_isascii(c2));
 	printf("Is %c ascii? %d\n", c3, ft_isascii(c3));
diff --git a/libft/ft_isdigit.c b/libft/ft_isdigit.c
index f330be6..32dc3f5 100644
--- a/libft/ft_isdigit.c
+++ b/libft/ft_isdigit.c
@@ -23,9 +23,13 @@ int	ft_isdigit(int c)
 
 int	main(void)
 {
-	char	c1 = 'A';
-	char	c2 = '5';
-	char	c3 = '@';
+	char	c1;
+	char	c2;
+	char	c3;
+
+	c1 = 'A';
+	c2 = '5';
+	c3 = '@';
 	printf("Is %c a digit? %d\n", c1, ft_isdigit(c1));
 	printf("Is %c a digit? %d\n", c2, ft_isdigit(c2));
 	printf("Is %c a digit? %d\n", c3, ft_isdigit(c3));
diff --git a/libft/ft_isnumeric.c b/libft/ft_isnumeric.c
index 40b6ab8..7f43c70 100644
--- a/libft/ft_isnumeric.c
+++ b/libft/ft_isnumeric.c
@@ -10,10 +10,9 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-
 #include "libft.h"
 
-int ft_isnumeric(const char *str)
+int	ft_isnumeric(const char *str)
 {
 	if (*str == '-' || *str == '+')
 		str++;
diff --git a/libft/ft_isprint.c b/libft/ft_isprint.c
index 3a8f8fe..622e2e4 100644
--- a/libft/ft_isprint.c
+++ b/libft/ft_isprint.c
@@ -23,9 +23,13 @@ int	ft_isprint(int c)
 
 int	main(void)
 {
-	char	c1 = 'A';
-	char	c2 = '5';
-	char	c3 = '@';
+	char	c1;
+	char	c2;
+	char	c3;
+
+	c1 = 'A';
+	c2 = '5';
+	c3 = '@';
 	printf("Is %c printable? %d\n", c1, ft_isprint(c1));
 	printf("Is %c printable? %d\n", c2, ft_isprint(c2));
 	printf("Is %c printable? %d\n", c3, ft_isprint(c3));
diff --git a/libft/ft_isspace.c b/libft/ft_isspace.c
index 4cb1598..98d1e42 100644
--- a/libft/ft_isspace.c
+++ b/libft/ft_isspace.c
@@ -13,6 +13,6 @@
 
 int	ft_isspace(int c)
 {
-	return (c == ' ' || c == '\t' || c == '\n' ||
-			c == '\v' || c == '\f' || c == '\r');
+	return (c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f'
+		|| c == '\r');
 }
diff --git a/libft/ft_issymbol.c b/libft/ft_issymbol.c
index 18fbf4b..5eec9e1 100644
--- a/libft/ft_issymbol.c
+++ b/libft/ft_issymbol.c
@@ -12,9 +12,8 @@
 
 int	ft_issymbol(char c)
 {
-	if (c == '|' || c == '&' || c == ';' || c == '<' || c == '>'
-		|| c == '(' || c == ')' || c == '\\' || c == '"' || c == '\''
-		|| c == '$')
+	if (c == '|' || c == '&' || c == ';' || c == '<' || c == '>' || c == '('
+		|| c == ')' || c == '\\' || c == '"' || c == '\'' || c == '$')
 		return (1);
 	return (0);
 }
diff --git a/libft/ft_itoa.c b/libft/ft_itoa.c
index 4d99b74..96061b2 100644
--- a/libft/ft_itoa.c
+++ b/libft/ft_itoa.c
@@ -1,84 +1,86 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_itoa.c                                          :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/01/17 12:08:24 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:08:24 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-static	int	ft_count_char(int num)
-{
-	int	count;
-
-	count = 0;
-	if (num != 0)
-	{
-		if (num < 0)
-		{
-			num = num *(-1);
-			count++;
-		}
-		while (num != 0)
-		{
-			num = num / 10;
-			count++;
-		}
-	}
-	else
-		count = 1;
-	return (count);
-}
-
-char	*ft_itoa(int n)
-{
-	int			len;
-	char		*str;
-	long int	nbr;
-
-	len = ft_count_char(n);
-	nbr = n;
-	str = malloc(sizeof(char) * (len + 1));
-	if (!str)
-		return (0);
-	if (nbr < 0)
-	{
-		str[0] = '-';
-		nbr = -nbr;
-	}
-	if (nbr == 0)
-		str[0] = '0';
-	str[len--] = '\0';
-	while (nbr)
-	{
-		str[len] = ((nbr % 10) + '0');
-		nbr /= 10;
-		len--;
-	}
-	return (str);
-}
-/*
-#include <stdio.h>
-
-int	main(void)
-{
-	int	num = -12345;
-	char	*str = ft_itoa(num);
-
-	if (str)
-	{
-		printf("str: %s\n", str);
-		free(str);
-	}
-	else
-	{
-		printf("Memory allocation error.\n");
-	}
-	return (0);
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_itoa.c                                          :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/17 12:08:24 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:08:24 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+static int	ft_count_char(int num)
+{
+	int	count;
+
+	count = 0;
+	if (num != 0)
+	{
+		if (num < 0)
+		{
+			num = num * (-1);
+			count++;
+		}
+		while (num != 0)
+		{
+			num = num / 10;
+			count++;
+		}
+	}
+	else
+		count = 1;
+	return (count);
+}
+
+char	*ft_itoa(int n)
+{
+	int			len;
+	char		*str;
+	long int	nbr;
+
+	len = ft_count_char(n);
+	nbr = n;
+	str = malloc(sizeof(char) * (len + 1));
+	if (!str)
+		return (0);
+	if (nbr < 0)
+	{
+		str[0] = '-';
+		nbr = -nbr;
+	}
+	if (nbr == 0)
+		str[0] = '0';
+	str[len--] = '\0';
+	while (nbr)
+	{
+		str[len] = ((nbr % 10) + '0');
+		nbr /= 10;
+		len--;
+	}
+	return (str);
+}
+/*
+#include <stdio.h>
+
+int	main(void)
+{
+	int		num;
+	char	*str;
+
+	num = -12345;
+	str = ft_itoa(num);
+	if (str)
+	{
+		printf("str: %s\n", str);
+		free(str);
+	}
+	else
+	{
+		printf("Memory allocation error.\n");
+	}
+	return (0);
+}
 */
\ No newline at end of file
diff --git a/libft/ft_lstdelone.c b/libft/ft_lstdelone.c
index 55dc243..0eb130f 100644
--- a/libft/ft_lstdelone.c
+++ b/libft/ft_lstdelone.c
@@ -12,7 +12,7 @@
 
 #include "libft.h"
 
-void	ft_lstdelone(t_list *lst, void (*del)(void*))
+void	ft_lstdelone(t_list *lst, void (*del)(void *))
 {
 	if (!lst || !del)
 		return ;
@@ -20,20 +20,20 @@ void	ft_lstdelone(t_list *lst, void (*del)(void*))
 	free(lst);
 }
 /*
-t_list *ft_lstnew(void *content)
+t_list	*ft_lstnew(void *content)
 {
-    t_list *new_node;
+	t_list	*new_node;
 
-    new_node = (t_list *)malloc(sizeof(t_list));
-    if (!new_node)
-        return (NULL);
-    new_node->content = content;
-    new_node->next = NULL;
-    return (new_node);
+	new_node = (t_list *)malloc(sizeof(t_list));
+	if (!new_node)
+		return (NULL);
+	new_node->content = content;
+	new_node->next = NULL;
+	return (new_node);
 }
-void del(void *content)
+void	del(void *content)
 {
-    free(content);
+	free(content);
 }
 void	ft_lstprint(t_list *lst)
 {
@@ -47,24 +47,21 @@ void	ft_lstprint(t_list *lst)
 
 int	main(void)
 {
-	t_list *head = ft_lstnew(strdup("First"));
+	t_list	*head;
+	t_list	*to_delete;
+
+	head = ft_lstnew(strdup("First"));
 	head->next = ft_lstnew(strdup("Second"));
 	head->next->next = ft_lstnew(strdup("Third"));
-
 	printf("The linked list before deletion: ");
 	ft_lstprint(head);
-
-	t_list *to_delete = head->next;
-    head->next = to_delete->next; 
-
+	to_delete = head->next;
+	head->next = to_delete->next;
 	ft_lstdelone(to_delete, del);
-
 	printf("The linked list after deletion: ");
 	ft_lstprint(head);
-
 	free(head->content);
-    free(head);
-
+	free(head);
 	return (0);
 }
 */
\ No newline at end of file
diff --git a/libft/ft_lstmap.c b/libft/ft_lstmap.c
index 1f05fee..2828d9d 100644
--- a/libft/ft_lstmap.c
+++ b/libft/ft_lstmap.c
@@ -58,42 +58,43 @@ void	ft_lstprint(t_list *lst)
 }
 int	main(void)
 {
-	t_list *list = NULL;
+	t_list	*list;
+	int		*num1;
+	int		*num2;
+	int		*num3;
+	t_list	*new_list;
+	t_list	*tmp;
+	t_list	*tmp;
 
-	int *num1 = (int *)malloc(sizeof(int));
+	list = NULL;
+	num1 = (int *)malloc(sizeof(int));
 	*num1 = 42;
-	int *num2 = (int *)malloc(sizeof(int));
+	num2 = (int *)malloc(sizeof(int));
 	*num2 = 36;
-	int *num3 = (int *)malloc(sizeof(int));
+	num3 = (int *)malloc(sizeof(int));
 	*num3 = 58;
-
 	ft_lstadd_front(&list, ft_lstnew(num1));
 	ft_lstadd_front(&list, ft_lstnew(num2));
 	ft_lstadd_front(&list, ft_lstnew(num3));
-
 	printf("Original list:\n");
-    ft_lstprint(list);
-
-    t_list *new_list = ft_lstmap(list, increment, del);
-
-    printf("\nNew list after incrementing:\n");
-    ft_lstprint(new_list);
-
-    while (list)
-    {
-        t_list *tmp = list->next;
-        del(list->content);
-        free(list);
-        list = tmp;
-    }
-
-    while (new_list)
-    {
-        t_list *tmp = new_list->next;
-        del(new_list->content);
-        free(new_list);
-        new_list = tmp;
-    }
+	ft_lstprint(list);
+	new_list = ft_lstmap(list, increment, del);
+	printf("\nNew list after incrementing:\n");
+	ft_lstprint(new_list);
+	while (list)
+	{
+		tmp = list->next;
+		del(list->content);
+		free(list);
+		list = tmp;
+	}
+	while (new_list)
+	{
+		tmp = new_list->next;
+		del(new_list->content);
+		free(new_list);
+		new_list = tmp;
+	}
 	return (0);
 }
 */
\ No newline at end of file
diff --git a/libft/ft_memchr.c b/libft/ft_memchr.c
index 2c0453f..16c69c9 100644
--- a/libft/ft_memchr.c
+++ b/libft/ft_memchr.c
@@ -35,8 +35,9 @@ void	*ft_memchr(const void *s, int c, size_t n)
 int	main(void)
 {
 	char	str[] = "Hola, mundo!";
-	char	*result = (char *)ft_memchr(str, 'm', strlen(str));
+	char	*result;
 
+	result = (char *)ft_memchr(str, 'm', strlen(str));
 	if (result)
 		printf("Character found: '%c'\n",  *result);
 	else
diff --git a/libft/ft_printf.c b/libft/ft_printf.c
index b121aa9..b2fbdd8 100644
--- a/libft/ft_printf.c
+++ b/libft/ft_printf.c
@@ -1,61 +1,61 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_printf.c                                        :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/02/07 12:32:20 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/02/07 12:32:20 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-int	ft_conversion(char c, va_list list_of_args)
-{
-	if (c == 'c')
-		return (ft_putchar(va_arg(list_of_args, int)));
-	else if (c == 's')
-		return (ft_putstr(va_arg(list_of_args, char *)));
-	else if (c == 'p')
-		return (ft_putptr(va_arg(list_of_args, void *)));
-	else if (c == 'd' || c == 'i')
-		return (ft_putnbr(va_arg(list_of_args, int)));
-	else if (c == 'u')
-		return (ft_putunsigned(va_arg(list_of_args, unsigned int)));
-	else if (c == 'x')
-		return (ft_puthex(va_arg(list_of_args, unsigned int), 0));
-	else if (c == 'X')
-		return (ft_puthex(va_arg(list_of_args, unsigned int), 1));
-	else if (c == '%')
-		return (ft_putchar('%'));
-	return (0);
-}
-
-int	ft_printf(char const *format, ...)
-{
-	va_list	list_of_args;
-	int		len;
-	int		i;
-
-	va_start(list_of_args, format);
-	len = 0;
-	i = 0;
-	while (format[i])
-	{
-		if (format[i] == '%')
-		{
-			len += ft_conversion(format[i + 1], list_of_args);
-			i++;
-		}
-		else
-		{
-			len += ft_putchar(format[i]);
-		}
-		if (format[i])
-			i++;
-	}
-	va_end(list_of_args);
-	return (len);
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_printf.c                                        :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/02/07 12:32:20 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/02/07 12:32:20 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+int	ft_conversion(char c, va_list list_of_args)
+{
+	if (c == 'c')
+		return (ft_putchar(va_arg(list_of_args, int)));
+	else if (c == 's')
+		return (ft_putstr(va_arg(list_of_args, char *)));
+	else if (c == 'p')
+		return (ft_putptr(va_arg(list_of_args, void *)));
+	else if (c == 'd' || c == 'i')
+		return (ft_putnbr(va_arg(list_of_args, int)));
+	else if (c == 'u')
+		return (ft_putunsigned(va_arg(list_of_args, unsigned int)));
+	else if (c == 'x')
+		return (ft_puthex(va_arg(list_of_args, unsigned int), 0));
+	else if (c == 'X')
+		return (ft_puthex(va_arg(list_of_args, unsigned int), 1));
+	else if (c == '%')
+		return (ft_putchar('%'));
+	return (0);
+}
+
+int	ft_printf(char const *format, ...)
+{
+	va_list	list_of_args;
+	int		len;
+	int		i;
+
+	va_start(list_of_args, format);
+	len = 0;
+	i = 0;
+	while (format[i])
+	{
+		if (format[i] == '%')
+		{
+			len += ft_conversion(format[i + 1], list_of_args);
+			i++;
+		}
+		else
+		{
+			len += ft_putchar(format[i]);
+		}
+		if (format[i])
+			i++;
+	}
+	va_end(list_of_args);
+	return (len);
+}
diff --git a/libft/ft_putchar_fd.c b/libft/ft_putchar_fd.c
index 3c58c28..c1bede4 100644
--- a/libft/ft_putchar_fd.c
+++ b/libft/ft_putchar_fd.c
@@ -1,19 +1,19 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/01/17 12:09:51 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:09:51 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-void	ft_putchar_fd(char c, int fd)
-{
-	if (fd >= 0)
-		write (fd, &c, 1);
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/17 12:09:51 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:09:51 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+void	ft_putchar_fd(char c, int fd)
+{
+	if (fd >= 0)
+		write(fd, &c, 1);
+}
diff --git a/libft/ft_putendl_fd.c b/libft/ft_putendl_fd.c
index 8566953..60ac9a2 100644
--- a/libft/ft_putendl_fd.c
+++ b/libft/ft_putendl_fd.c
@@ -1,31 +1,31 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+
-	+:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+
-	+#+        */
-/*                                                +#+#+#+#+#+
-	+#+           */
-/*   Created: 2025/01/17 12:10:19 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:10:19 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-void	ft_putendl_fd(char *s, int fd)
-{
-	int	i;
-
-	if (!s || fd < 0)
-		return ;
-	i = 0;
-	while (s[i])
-	{
-		write(fd, &s[i], 1);
-		i++;
-	}
-	write(fd, "\n", 1);
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
+/*                                                    +:+ +:+
+	+:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+
+	+#+        */
+/*                                                +#+#+#+#+#+
+	+#+           */
+/*   Created: 2025/01/17 12:10:19 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:10:19 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+void	ft_putendl_fd(char *s, int fd)
+{
+	int	i;
+
+	if (!s || fd < 0)
+		return ;
+	i = 0;
+	while (s[i])
+	{
+		write(fd, &s[i], 1);
+		i++;
+	}
+	write(fd, "\n", 1);
+}
diff --git a/libft/ft_putnbr.c b/libft/ft_putnbr.c
index 0f91bf4..6dcecc4 100644
--- a/libft/ft_putnbr.c
+++ b/libft/ft_putnbr.c
@@ -25,7 +25,7 @@ int	ft_putnbr(int nb)
 	}
 	if (nb < 0)
 	{
-		write (1, "-", 1);
+		write(1, "-", 1);
 		nb = -nb;
 		len++;
 	}
diff --git a/libft/ft_putnbr_fd.c b/libft/ft_putnbr_fd.c
index 116f6b3..345af79 100644
--- a/libft/ft_putnbr_fd.c
+++ b/libft/ft_putnbr_fd.c
@@ -1,43 +1,43 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+
-	+:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+
-	+#+        */
-/*                                                +#+#+#+#+#+
-	+#+           */
-/*   Created: 2025/01/17 12:10:32 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:10:32 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-void	ft_putnbr_fd(int n, int fd)
-{
-	char	c;
-
-	if (n == -2147483648)
-	{
-		write(fd, "-", 1);
-		write(fd, "2", 1);
-		ft_putnbr_fd(147483648, fd);
-	}
-	else if (n < 0)
-	{
-		write(fd, "-", 1);
-		ft_putnbr_fd(-n, fd);
-	}
-	else if (n > 9)
-	{
-		ft_putnbr_fd(n / 10, fd);
-		ft_putnbr_fd(n % 10, fd);
-	}
-	else
-	{
-		c = n + '0';
-		write(fd, &c, 1);
-	}
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
+/*                                                    +:+ +:+
+	+:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+
+	+#+        */
+/*                                                +#+#+#+#+#+
+	+#+           */
+/*   Created: 2025/01/17 12:10:32 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:10:32 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+void	ft_putnbr_fd(int n, int fd)
+{
+	char	c;
+
+	if (n == -2147483648)
+	{
+		write(fd, "-", 1);
+		write(fd, "2", 1);
+		ft_putnbr_fd(147483648, fd);
+	}
+	else if (n < 0)
+	{
+		write(fd, "-", 1);
+		ft_putnbr_fd(-n, fd);
+	}
+	else if (n > 9)
+	{
+		ft_putnbr_fd(n / 10, fd);
+		ft_putnbr_fd(n % 10, fd);
+	}
+	else
+	{
+		c = n + '0';
+		write(fd, &c, 1);
+	}
+}
diff --git a/libft/ft_putstr_fd.c b/libft/ft_putstr_fd.c
index fe826ad..952d47f 100644
--- a/libft/ft_putstr_fd.c
+++ b/libft/ft_putstr_fd.c
@@ -1,27 +1,27 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/01/17 12:10:04 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:10:04 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-void	ft_putstr_fd(char *s, int fd)
-{
-	int	i;
-
-	i = 0;
-	if (!s)
-		return ;
-	while (s[i] && fd >= 0)
-	{
-		write(fd, &s[i], 1);
-		i++;
-	}
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/17 12:10:04 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:10:04 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+void	ft_putstr_fd(char *s, int fd)
+{
+	int	i;
+
+	i = 0;
+	if (!s)
+		return ;
+	while (s[i] && fd >= 0)
+	{
+		write(fd, &s[i], 1);
+		i++;
+	}
+}
diff --git a/libft/ft_strdup_array.c b/libft/ft_strdup_array.c
index 597658f..f7b2e16 100644
--- a/libft/ft_strdup_array.c
+++ b/libft/ft_strdup_array.c
@@ -12,31 +12,31 @@
 
 #include "libft.h"
 
-char    **ft_strdup_array(char **array)
+char	**ft_strdup_array(char **array)
 {
-    char    **new_array;
-    int     i;
-    int     count;
+	char	**new_array;
+	int		i;
+	int		count;
 
-    if (!array)
-        return (NULL);
-    count = 0;
-    while (array[count])
-        count++;
-    new_array = (char **)malloc(sizeof(char *) * (count + 1));
-    if (!new_array)
-        return (NULL);
-    i = 0;
-    while (i < count)
-    {
-        new_array[i] = ft_strdup(array[i]);
-        if (!new_array[i])
-        {
-            ft_free_strtab(new_array);
-            return (NULL);
-        }
-        i++;
-    }
-    new_array[i] = NULL;
-    return (new_array);
+	if (!array)
+		return (NULL);
+	count = 0;
+	while (array[count])
+		count++;
+	new_array = (char **)malloc(sizeof(char *) * (count + 1));
+	if (!new_array)
+		return (NULL);
+	i = 0;
+	while (i < count)
+	{
+		new_array[i] = ft_strdup(array[i]);
+		if (!new_array[i])
+		{
+			ft_free_strtab(new_array);
+			return (NULL);
+		}
+		i++;
+	}
+	new_array[i] = NULL;
+	return (new_array);
 }
diff --git a/libft/ft_striteri.c b/libft/ft_striteri.c
index 1d68e96..03f8609 100644
--- a/libft/ft_striteri.c
+++ b/libft/ft_striteri.c
@@ -1,27 +1,27 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_striteri.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/01/17 12:09:38 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:09:38 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-void	ft_striteri(char *s, void (*f)(unsigned int, char *))
-{
-	unsigned int	i;
-
-	if (!s)
-		return ;
-	i = 0;
-	while (s[i] != '\0')
-	{
-		f(i, &s[i]);
-		i++;
-	}
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_striteri.c                                      :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/17 12:09:38 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:09:38 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+void	ft_striteri(char *s, void (*f)(unsigned int, char *))
+{
+	unsigned int	i;
+
+	if (!s)
+		return ;
+	i = 0;
+	while (s[i] != '\0')
+	{
+		f(i, &s[i]);
+		i++;
+	}
+}
diff --git a/libft/ft_strjoin_free.c b/libft/ft_strjoin_free.c
index bb22b1d..2f59bc8 100644
--- a/libft/ft_strjoin_free.c
+++ b/libft/ft_strjoin_free.c
@@ -79,22 +79,25 @@ char	*ft_strjoin_free_both(char *s1, char *s2)
 	return (joined);
 }
 
-char *ft_strjoin_three(const char *s1, const char *s2, const char *s3)
+char	*ft_strjoin_three(const char *s1, const char *s2, const char *s3)
 {
-    char *new_str;
-    size_t len1 = s1 ? ft_strlen(s1) : 0;
-    size_t len2 = s2 ? ft_strlen(s2) : 0;
-    size_t len3 = s3 ? ft_strlen(s3) : 0;
+	char	*new_str;
+	size_t	len1;
+	size_t	len2;
+	size_t	len3;
 
-    new_str = (char *)malloc(sizeof(char) * (len1 + len2 + len3 + 1));
-    if (!new_str)
-        return (NULL);
-    
-    new_str[0] = '\0';
-
-    if (s1) ft_strcat(new_str, s1);
-    if (s2) ft_strcat(new_str, s2);
-    if (s3) ft_strcat(new_str, s3);
-
-    return (new_str);
+	len1 = s1 ? ft_strlen(s1) : 0;
+	len2 = s2 ? ft_strlen(s2) : 0;
+	len3 = s3 ? ft_strlen(s3) : 0;
+	new_str = (char *)malloc(sizeof(char) * (len1 + len2 + len3 + 1));
+	if (!new_str)
+		return (NULL);
+	new_str[0] = '\0';
+	if (s1)
+		ft_strcat(new_str, s1);
+	if (s2)
+		ft_strcat(new_str, s2);
+	if (s3)
+		ft_strcat(new_str, s3);
+	return (new_str);
 }
diff --git a/libft/ft_strmapi.c b/libft/ft_strmapi.c
index f2ef556..4ad790c 100644
--- a/libft/ft_strmapi.c
+++ b/libft/ft_strmapi.c
@@ -1,33 +1,33 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ft_strmapi.c                                       :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/01/17 12:01:42 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/17 12:01:42 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
-{
-	int		i;
-	char	*str;
-
-	if (!s)
-		return (NULL);
-	str = malloc(sizeof(char) * (ft_strlen(s) + 1));
-	if (!str)
-		return (NULL);
-	i = 0;
-	while (s[i] != '\0')
-	{
-		str[i] = f(i, s[i]);
-		i++;
-	}
-	str[i] = '\0';
-	return (str);
-}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_strmapi.c                                       :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/17 12:01:42 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/17 12:01:42 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
+{
+	int		i;
+	char	*str;
+
+	if (!s)
+		return (NULL);
+	str = malloc(sizeof(char) * (ft_strlen(s) + 1));
+	if (!str)
+		return (NULL);
+	i = 0;
+	while (s[i] != '\0')
+	{
+		str[i] = f(i, s[i]);
+		i++;
+	}
+	str[i] = '\0';
+	return (str);
+}
diff --git a/libft/get_next_line.c b/libft/get_next_line.c
index dcb7750..4a0c5f6 100644
--- a/libft/get_next_line.c
+++ b/libft/get_next_line.c
@@ -1,141 +1,141 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   get_next_line.c                                    :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/01/30 13:00:56 by rarodri2          #+#    #+#             */
-/*   Updated: 2025/01/30 13:00:56 by rarodri2         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "libft.h"
-
-static char	*read_from_fd(int fd, char *buffer, int *error)
-{
-	char	*temp;
-	ssize_t	bytes_read;
-	char	*new_buffer;
-
-	temp = (char *)malloc(BUFFER_SIZE + 1);
-	if (!temp)
-		return (NULL);
-	bytes_read = read(fd, temp, BUFFER_SIZE);
-	if (bytes_read <= 0)
-	{
-		if (bytes_read == -1)
-			*error = 1;
-		return (free(temp), NULL);
-	}
-	temp[bytes_read] = '\0';
-	if (!buffer)
-		return (ft_strdup(temp));
-	new_buffer = ft_strjoin(buffer, temp);
-	free(buffer);
-	free(temp);
-	return (new_buffer);
-}
-
-static char	*extract_line(char **buffer)
-{
-	char	*line;
-	char	*newline_pos;
-	char	*new_buffer;
-
-	if (!*buffer || !**buffer)
-	{
-		free(*buffer);
-		*buffer = NULL;
-		return (NULL);
-	}
-	newline_pos = ft_strchr(*buffer, '\n');
-	if (newline_pos)
-	{
-		line = ft_substr(*buffer, 0, newline_pos - *buffer + 1);
-		new_buffer = ft_strdup(newline_pos + 1);
-		free(*buffer);
-		*buffer = new_buffer;
-	}
-	else
-	{
-		line = ft_strdup(*buffer);
-		free(*buffer);
-		*buffer = NULL;
-	}
-	return (line);
-}
-
-char	*get_next_line(int fd)
-{
-	static char	*buffer;
-	char		*line;
-	char		*temp;
-	int			error;
-
-	if (fd < 0 || BUFFER_SIZE <= 0)
-		return (NULL);
-	error = 0;
-	if (!buffer)
-		buffer = ft_strdup("");
-	while (buffer && !ft_strchr(buffer, '\n'))
-	{
-		temp = read_from_fd(fd, buffer, &error);
-		if (!temp)
-			break ;
-		buffer = temp;
-	}
-	if (error == 1 || !buffer || !*buffer)
-	{
-		free(buffer);
-		buffer = NULL;
-		return (NULL);
-	}
-	line = extract_line(&buffer);
-	return (line);
-}
-/* #include <stdio.h>
-
-int	main(void)
-{
-	int		fd;
-	char	*line;
-	int		count;
-
-	count = 0;
-	fd = open("read_error.txt", O_RDONLY);
-	if (fd == -1)
-	{
-		printf("OPENING FILE ERROR\n");
-		return (1);
-	}
-	line = get_next_line(fd);
-	while (line)
-	{
-		count++;
-		printf("%s", line);
-		free(line);
-		line = get_next_line(fd);
-	}
-	close(fd);
-	return (0);
-} */
-/* int	main(void)
-{
-	int		fd_1;
-	int		i;
-	char	*line[4096];
-
-	i = 1;
-	fd_1 = open("J. K. Rowling - Harry Potter 1 - Sorcerer's Stone.txt", \
-					O_RDONLY);
-	while (1)
-	{
-		line[fd_1] = get_next_line(fd_1);
-		printf("Line %d for fd %d: %s\n", i, fd_1, line[fd_1]);
-		if (!line[fd_1])
-			return (0);
-		free(line[fd_1]);
-		i++;
-	}
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   get_next_line.c                                    :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: rarodri2 <rarodri2@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/30 13:00:56 by rarodri2          #+#    #+#             */
+/*   Updated: 2025/01/30 13:00:56 by rarodri2         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+static char	*read_from_fd(int fd, char *buffer, int *error)
+{
+	char	*temp;
+	ssize_t	bytes_read;
+	char	*new_buffer;
+
+	temp = (char *)malloc(BUFFER_SIZE + 1);
+	if (!temp)
+		return (NULL);
+	bytes_read = read(fd, temp, BUFFER_SIZE);
+	if (bytes_read <= 0)
+	{
+		if (bytes_read == -1)
+			*error = 1;
+		return (free(temp), NULL);
+	}
+	temp[bytes_read] = '\0';
+	if (!buffer)
+		return (ft_strdup(temp));
+	new_buffer = ft_strjoin(buffer, temp);
+	free(buffer);
+	free(temp);
+	return (new_buffer);
+}
+
+static char	*extract_line(char **buffer)
+{
+	char	*line;
+	char	*newline_pos;
+	char	*new_buffer;
+
+	if (!*buffer || !**buffer)
+	{
+		free(*buffer);
+		*buffer = NULL;
+		return (NULL);
+	}
+	newline_pos = ft_strchr(*buffer, '\n');
+	if (newline_pos)
+	{
+		line = ft_substr(*buffer, 0, newline_pos - *buffer + 1);
+		new_buffer = ft_strdup(newline_pos + 1);
+		free(*buffer);
+		*buffer = new_buffer;
+	}
+	else
+	{
+		line = ft_strdup(*buffer);
+		free(*buffer);
+		*buffer = NULL;
+	}
+	return (line);
+}
+
+char	*get_next_line(int fd)
+{
+	static char	*buffer;
+	char		*line;
+	char		*temp;
+	int			error;
+
+	if (fd < 0 || BUFFER_SIZE <= 0)
+		return (NULL);
+	error = 0;
+	if (!buffer)
+		buffer = ft_strdup("");
+	while (buffer && !ft_strchr(buffer, '\n'))
+	{
+		temp = read_from_fd(fd, buffer, &error);
+		if (!temp)
+			break ;
+		buffer = temp;
+	}
+	if (error == 1 || !buffer || !*buffer)
+	{
+		free(buffer);
+		buffer = NULL;
+		return (NULL);
+	}
+	line = extract_line(&buffer);
+	return (line);
+}
+/* #include <stdio.h>
+
+int	main(void)
+{
+	int		fd;
+	char	*line;
+	int		count;
+
+	count = 0;
+	fd = open("read_error.txt", O_RDONLY);
+	if (fd == -1)
+	{
+		printf("OPENING FILE ERROR\n");
+		return (1);
+	}
+	line = get_next_line(fd);
+	while (line)
+	{
+		count++;
+		printf("%s", line);
+		free(line);
+		line = get_next_line(fd);
+	}
+	close(fd);
+	return (0);
+} */
+/* int	main(void)
+{
+	int		fd_1;
+	int		i;
+	char	*line[4096];
+
+	i = 1;
+	fd_1 = open("J. K. Rowling - Harry Potter 1 - Sorcerer's Stone.txt", \
+					O_RDONLY);
+	while (1)
+	{
+		line[fd_1] = get_next_line(fd_1);
+		printf("Line %d for fd %d: %s\n", i, fd_1, line[fd_1]);
+		if (!line[fd_1])
+			return (0);
+		free(line[fd_1]);
+		i++;
+	}
 } */
\ No newline at end of file
diff --git a/minishell b/minishell
deleted file mode 100755
index 9927168..0000000
Binary files a/minishell and /dev/null differ
diff --git a/minishell.c b/minishell.c
index 11b3ab6..29ca36f 100644
--- a/minishell.c
+++ b/minishell.c
@@ -12,6 +12,7 @@
 
 #include "minishell.h"
 #include "signals.h"
+
 //#include "exec.h"
 
 int	main(int argc, char **argv, char **envp)
@@ -19,7 +20,7 @@ int	main(int argc, char **argv, char **envp)
 	t_shell	shell;
 	int		ret;
 
-//	setup_prompt_signals();
+	//	setup_prompt_signals();
 	setup_signals();
 	if (init_shell_name(&shell, argv) != 0)
 		return (1);
diff --git a/src/AST/ast_utils.c b/src/AST/ast_utils.c
index e259da6..e6c0521 100644
--- a/src/AST/ast_utils.c
+++ b/src/AST/ast_utils.c
@@ -10,62 +10,70 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-	#include "minishell.h"
-	#include "ast.h"
+#include "minishell.h"
+#include "ast.h"
 
-	t_ast *ast_new_command(char **argv, t_ast *redirections)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = N_COMMAND;
-		node->cmd.argv = argv;
-		node->cmd.redirections = redirections;
-		return (node);
-	}
+t_ast	*ast_new_command(char **argv, t_ast *redirections)
+{
+	t_ast	*node;
 
-	t_ast *ast_new_redir(char *filename, char *delimiter,
-						t_redir_type type, int redir_fd)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = N_REDIR;
-		node->redir.filename = filename;
-		node->redir.delimiter = delimiter;
-		node->redir.redir_type = type;
-		node->redir.redir_fd = redir_fd;
-		return (node);
-	}
+	node = malloc(sizeof(t_ast));
+	if (!node)
+		return (NULL);
+	node->type = N_COMMAND;
+	node->cmd.argv = argv;
+	node->cmd.redirections = redirections;
+	return (node);
+}
 
-	t_ast *ast_new_binary(t_node_type type, t_ast *left, t_ast *right)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = type;
-		node->bin.left = left;
-		node->bin.right = right;
-		return (node);
-	}
+t_ast	*ast_new_redir(char *filename, char *delimiter, t_redir_type type,
+		int redir_fd)
+{
+	t_ast	*node;
 
-	t_ast *ast_new_subshell(t_ast *child, t_ast *redirections)
-	{
-		t_ast *node = malloc(sizeof(t_ast));
-		if (!node)
-			return NULL;
-		node->type = N_SUBSHELL;
-		node->subshell.child = child;
-		node->subshell.redirections = redirections;
-		return (node);
-	}
+	node = malloc(sizeof(t_ast));
+	if (!node)
+		return (NULL);
+	node->type = N_REDIR;
+	node->redir.filename = filename;
+	node->redir.delimiter = delimiter;
+	node->redir.redir_type = type;
+	node->redir.redir_fd = redir_fd;
+	return (node);
+}
 
-	t_ast	*create_command_node(char **argv, t_ast *redir_list_head)
-	{
-		t_ast	*cmd;
+t_ast	*ast_new_binary(t_node_type type, t_ast *left, t_ast *right)
+{
+	t_ast	*node;
 
-		cmd = ast_new_command(argv, redir_list_head);
-		if (!cmd)
-			return (NULL);
-		return (cmd);
-	}
+	node = malloc(sizeof(t_ast));
+	if (!node)
+		return (NULL);
+	node->type = type;
+	node->bin.left = left;
+	node->bin.right = right;
+	return (node);
+}
+
+t_ast	*ast_new_subshell(t_ast *child, t_ast *redirections)
+{
+	t_ast	*node;
+
+	node = malloc(sizeof(t_ast));
+	if (!node)
+		return (NULL);
+	node->type = N_SUBSHELL;
+	node->subshell.child = child;
+	node->subshell.redirections = redirections;
+	return (node);
+}
+
+t_ast	*create_command_node(char **argv, t_ast *redir_list_head)
+{
+	t_ast	*cmd;
+
+	cmd = ast_new_command(argv, redir_list_head);
+	if (!cmd)
+		return (NULL);
+	return (cmd);
+}
diff --git a/src/AST/build_ast.c b/src/AST/build_ast.c
index beb2076..b592bb4 100644
--- a/src/AST/build_ast.c
+++ b/src/AST/build_ast.c
@@ -10,33 +10,36 @@
 /*                                                                            */
 /* ************************************************************************** */
 
+#include "ast.h"
 #include "minishell.h"
 #include "parser.h"
-#include "ast.h"
 
 /*
 ** Función principal del parser: construye el AST a partir de la lista de tokens.
 ** Devuelve la raíz del AST o NULL en caso de error.
 */
-t_ast   *build_ast(t_token *tokens)
+t_ast	*build_ast(t_token *tokens)
 {
-    t_token *cur;
-    t_ast   *tree;
+	t_token	*cur;
+	t_ast	*tree;
 
-    cur = tokens;
-    tree = parse_background(&cur); // Llama a la función de más alta precedencia
-    if (!tree)
-        return (NULL);
-    
-    // Si quedan tokens sin procesar, es un error de sintaxis que las funciones de abajo
-    // no capturaron porque no formaban parte de ninguna regla sintáctica esperada.
-    // Esto es muy importante para detectar cosas como "ls && ;" o "echo hello world extra_stuff"
-    // donde "extra_stuff" no es parte de la sintaxis válida después de un comando simple.
-    if (cur != NULL) // <-- Esta condición es correcta para detectar tokens no consumidos
-    {
-        ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n", cur->value);
-        free_ast(tree);
-        return (NULL);
-    }
-    return (tree);
+	cur = tokens;
+	tree = parse_background(&cur); // Llama a la función de más alta precedencia
+	if (!tree)
+		return (NULL);
+	// Si quedan tokens sin procesar,
+		es un error de sintaxis que las funciones de abajo
+	// no capturaron porque no formaban parte de ninguna regla sintáctica esperada.
+	// Esto es muy importante para detectar cosas como "ls
+		&& ;" o "echo hello world extra_stuff"
+	// donde "extra_stuff" no es parte de la sintaxis válida después de un comando simple.
+	if (cur != NULL)
+		// <-- Esta condición es correcta para detectar tokens no consumidos
+	{
+		ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n",
+			cur->value);
+		free_ast(tree);
+		return (NULL);
+	}
+	return (tree);
 }
diff --git a/src/AST/free_ast.c b/src/AST/free_ast.c
index 11ed86f..a4315bb 100644
--- a/src/AST/free_ast.c
+++ b/src/AST/free_ast.c
@@ -10,61 +10,61 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "ast.h"
-#include "parser.h"
 #include "lexer.h"
+#include "minishell.h"
+#include "parser.h"
 
 // Libera solo un nodo, sin liberar hijos ni cadenas externas
-void free_ast(t_ast *node)
+void	free_ast(t_ast *node)
 {
-    if (!node)
-        return;
-
-    if (node->type == N_COMMAND)
-    {
-        if (node->cmd.argv)
-            ft_free_strtab(node->cmd.argv); // función para liberar char** argv
-        // redirections NO se liberan aquí, porque pueden ser compartidas o liberadas en free_ast_recursive
-    }
-    else if (node->type == N_REDIR)
-    {
-        if (node->redir.filename)
-            free(node->redir.filename);
-        if (node->redir.delimiter)
-            free(node->redir.delimiter);
-    }
-    // No libera punteros a hijos (bin, subshell), solo el nodo actual
-    free(node);
+	if (!node)
+		return ;
+	if (node->type == N_COMMAND)
+	{
+		if (node->cmd.argv)
+			ft_free_strtab(node->cmd.argv); // función para liberar char** argv
+		// redirections NO se liberan aquí,
+			porque pueden ser compartidas o liberadas en free_ast_recursive
+	}
+	else if (node->type == N_REDIR)
+	{
+		if (node->redir.filename)
+			free(node->redir.filename);
+		if (node->redir.delimiter)
+			free(node->redir.delimiter);
+	}
+	// No libera punteros a hijos (bin, subshell), solo el nodo actual
+	free(node);
 }
 
 // Libera el árbol entero recursivamente (incluye hijos y redirecciones)
-void free_ast_recursive(t_ast *node)
+void	free_ast_recursive(t_ast *node)
 {
-    if (!node)
-        return;
-    if (node->type == N_COMMAND)
-    {
-        free_ast_recursive(node->cmd.redirections);
-        if (node->cmd.argv)
-            ft_free_strtab(node->cmd.argv);
-    }
-    else if (node->type == N_REDIR)
-    {
-        if (node->redir.filename)
-            free(node->redir.filename);
-        if (node->redir.delimiter)
-            free(node->redir.delimiter);
-    }
-    else if (node->type == N_SUBSHELL)
-    {
-        free_ast_recursive(node->subshell.child);
-        free_ast_recursive(node->subshell.redirections);
-    }
-    else // para nodos binarios (PIPE, SEQUENCE, AND, OR, BACKGROUND)
-    {
-        free_ast_recursive(node->bin.left);
-        free_ast_recursive(node->bin.right);
-    }
-    free(node);
+	if (!node)
+		return ;
+	if (node->type == N_COMMAND)
+	{
+		free_ast_recursive(node->cmd.redirections);
+		if (node->cmd.argv)
+			ft_free_strtab(node->cmd.argv);
+	}
+	else if (node->type == N_REDIR)
+	{
+		if (node->redir.filename)
+			free(node->redir.filename);
+		if (node->redir.delimiter)
+			free(node->redir.delimiter);
+	}
+	else if (node->type == N_SUBSHELL)
+	{
+		free_ast_recursive(node->subshell.child);
+		free_ast_recursive(node->subshell.redirections);
+	}
+	else // para nodos binarios (PIPE, SEQUENCE, AND, OR, BACKGROUND)
+	{
+		free_ast_recursive(node->bin.left);
+		free_ast_recursive(node->bin.right);
+	}
+	free(node);
 }
diff --git a/src/builtins/cd_builtin.c b/src/builtins/cd_builtin.c
index 3d38984..5339c1d 100644
--- a/src/builtins/cd_builtin.c
+++ b/src/builtins/cd_builtin.c
@@ -10,9 +10,9 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "builtins.h"
 #include "env.h"
+#include "minishell.h"
 
 // ----------- CD -----------
 int	run_cd(char **argv, t_shell *shell)
@@ -26,7 +26,6 @@ int	run_cd(char **argv, t_shell *shell)
 		ft_dprintf(2, "minishell: cd: too many arguments\n");
 		return (1);
 	}
-
 	path = argv[1];
 	if (!path)
 	{
diff --git a/src/builtins/echo_builtin.c b/src/builtins/echo_builtin.c
index 222f161..8b2d9ca 100644
--- a/src/builtins/echo_builtin.c
+++ b/src/builtins/echo_builtin.c
@@ -10,52 +10,50 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "builtins.h"
+#include "minishell.h"
 
-static int  is_all_n(const char *s)
+static int	is_all_n(const char *s)
 {
-    int i;
+	int	i;
 
-    if (!s || s[0] != '-')
-        return 0;
-    i = 1;
-    if (s[i] == '\0')
-        return 0;              // solo "-" no cuenta
-    while (s[i])
-    {
-        if (s[i] != 'n')
-            return 0;
-        i++;
-    }
-    return 1;                  // "-n", "-nn", "-nnn", ...
+	if (!s || s[0] != '-')
+		return (0);
+	i = 1;
+	if (s[i] == '\0')
+		return (0); // solo "-" no cuenta
+	while (s[i])
+	{
+		if (s[i] != 'n')
+			return (0);
+		i++;
+	}
+	return (1); // "-n", "-nn", "-nnn", ...
 }
 
-int run_echo(char **argv)
+int	run_echo(char **argv)
 {
-    int i;
-    int no_newline;
-    int first_arg_printed;
-
-    i = 1;
-    no_newline = 0;
-    while (argv[i] && is_all_n(argv[i]))
-    {
-        no_newline = 1;
-        i++;
-    }
-
-    first_arg_printed = 0;
-    while (argv[i])
-    {
-        if (first_arg_printed)
-            write(1, " ", 1);
-        write(1, argv[i], ft_strlen(argv[i]));
-        first_arg_printed = 1;
-        i++;
-    }
+	int	i;
+	int	no_newline;
+	int	first_arg_printed;
 
-    if (!no_newline)
-        write(1, "\n", 1);
-    return 0;
+	i = 1;
+	no_newline = 0;
+	while (argv[i] && is_all_n(argv[i]))
+	{
+		no_newline = 1;
+		i++;
+	}
+	first_arg_printed = 0;
+	while (argv[i])
+	{
+		if (first_arg_printed)
+			write(1, " ", 1);
+		write(1, argv[i], ft_strlen(argv[i]));
+		first_arg_printed = 1;
+		i++;
+	}
+	if (!no_newline)
+		write(1, "\n", 1);
+	return (0);
 }
diff --git a/src/builtins/env_builtin.c b/src/builtins/env_builtin.c
index f500c31..f2266ad 100644
--- a/src/builtins/env_builtin.c
+++ b/src/builtins/env_builtin.c
@@ -10,9 +10,9 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "builtins.h"
 #include "env.h"
+#include "minishell.h"
 
 // ----------- ENV -----------
 int	run_env(t_shell *shell)
diff --git a/src/builtins/exit_builtin.c b/src/builtins/exit_builtin.c
index 677e665..dbf174b 100644
--- a/src/builtins/exit_builtin.c
+++ b/src/builtins/exit_builtin.c
@@ -10,48 +10,61 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "builtins.h"
+#include "minishell.h"
 
 // ----------- EXIT -----------
 
 /* Comprueba si s es un entero con signo en rango int64 */
-static int parse_ll(const char *s, long long *out)
+static int	parse_ll(const char *s, long long *out)
 {
-    char *end = NULL;
-    errno = 0;
-    if (!s || !*s) return 0;
-    long long v = strtoll(s, &end, 10);
-    if (errno == ERANGE) return 0;
-    if (*end != '\0')    return 0;
-    *out = v;
-    return 1;
+	char		*end;
+	long long	v;
+
+	end = NULL;
+	errno = 0;
+	if (!s || !*s)
+		return (0);
+	v = strtoll(s, &end, 10);
+	if (errno == ERANGE)
+		return (0);
+	if (*end != '\0')
+		return (0);
+	*out = v;
+	return (1);
 }
 
-int run_exit(char **argv, t_shell *shell)
+int	run_exit(char **argv, t_shell *shell)
 {
-    /* Bash imprime "exit" en interactivo; tu tester no lo exige. */
-    int argc = 0; while (argv && argv[argc]) argc++;
-
-    if (argc == 1) {
-        int code = shell ? (shell->exit_status & 0xFF) : 0;
-        exit(code);
-    }
-
-    long long val = 0;
-    if (!parse_ll(argv[1], &val)) {
-        fprintf(stderr, "minishell: exit: %s: numeric argument required\n", argv[1]);
-        exit(2); /* POSIX/Bash: sale con 2 si no numérico */
-    }
-
-    if (argc > 2) {
-        fprintf(stderr, "minishell: exit: too many arguments\n");
-        /* NO salir; status 1 y continuar */
-        return 1;
-    }
+	int				argc;
+	int				code;
+	long long		val;
+	unsigned char	ec;
 
-    /* Bash usa el byte menos significativo (módulo 256) */
-    unsigned char ec = (unsigned char)val;
-    exit((int)ec);
-    return (int)ec; /* inalcanzable, pero calma analizadores */
+	/* Bash imprime "exit" en interactivo; tu tester no lo exige. */
+	argc = 0;
+	while (argv && argv[argc])
+		argc++;
+	if (argc == 1)
+	{
+		code = shell ? (shell->exit_status & 0xFF) : 0;
+		exit(code);
+	}
+	val = 0;
+	if (!parse_ll(argv[1], &val))
+	{
+		fprintf(stderr, "minishell: exit: %s: numeric argument required\n",
+			argv[1]);
+		exit(2); /* POSIX/Bash: sale con 2 si no numérico */
+	}
+	if (argc > 2)
+	{
+		fprintf(stderr, "minishell: exit: too many arguments\n");
+		/* NO salir; status 1 y continuar */
+		return (1);
+	}
+	/* Bash usa el byte menos significativo (módulo 256) */
+	ec = (unsigned char)val;
+	exit((int)ec);
+	return ((int)ec); /* inalcanzable, pero calma analizadores */
 }
diff --git a/src/builtins/export_builtin.c b/src/builtins/export_builtin.c
index 3ff0526..412ffe4 100644
--- a/src/builtins/export_builtin.c
+++ b/src/builtins/export_builtin.c
@@ -6,81 +6,130 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/07/04 12:26:37 by acoronad          #+#    #+#             */
-/*   Updated: 2025/11/01 16:52:26 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 16:02:55 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
 
-static int is_valid_name(const char *s)
+/* nombre válido POSIX-like: [_A-Za-z][_A-Za-z0-9]* */
+static int  is_valid_name(const char *s)
 {
-    if (!s || !*s) return 0;
-    if (!(isalpha((unsigned char)*s) || *s == '_')) return 0;
-    for (const char *p = s+1; *p; ++p)
-        if (!(isalnum((unsigned char)*p) || *p == '_')) return 0;
-    return 1;
+    int i;
+
+    if (!s || !*s)
+        return (0);
+    if (!(ft_isalpha((unsigned char)s[0]) || s[0] == '_'))
+        return (0);
+    i = 1;
+    while (s[i])
+    {
+        if (!(ft_isalnum((unsigned char)s[i]) || s[i] == '_'))
+            return (0);
+        i++;
+    }
+    return (1);
 }
 
 static t_env *env_find(t_env *e, const char *key)
 {
-    while (e) { if (e->key && key && strcmp(e->key, key)==0) return e; e = e->next; }
-    return NULL;
+    while (e)
+    {
+        if (e->key && key && ft_strcmp(e->key, key) == 0)
+            return (e);
+        e = e->next;
+    }
+    return (NULL);
 }
 
-/* set/mark exported en tu lista enlazada */
-static void env_set_exported(t_shell *sh, const char *key, const char *val_opt, int mark_only)
+/* crea o marca exportada; si val!=NULL actualiza valor; si crea sin val -> "" */
+static void env_set_exported(t_shell *sh, const char *key, const char *val, int mark_only)
 {
-    t_env *n = env_find(sh->env, key);
-    if (!n) {
-        /* crea nuevo */
-        n = env_create(strdup(key), val_opt ? strdup(val_opt) : NULL, 1);
+    t_env *n;
+
+    n = env_find(sh->env, key);
+    if (!n)
+    {
+        /* env_create duplica internamente key/value */
+        n = env_create((char *)key, (char *)(val ? val : ""));
+        if (!n)
+            return ;
+        n->exported = 1;
         env_add_back(&sh->env, n);
-        return;
+        return ;
     }
     n->exported = 1;
-    if (!mark_only && val_opt) {
-        free(n->value);
-        n->value = strdup(val_opt);
+    if (!mark_only && val)
+    {
+        if (n->value)
+            free(n->value);
+        n->value = ft_strdup(val);
     }
 }
 
-int run_export(char **argv, t_shell *shell)
+/* export NOMBRE (solo marcar exportado / crear vacío si no existe) */
+static int  export_mark_only(t_shell *sh, const char *name)
 {
-    int status = 0;
-
-    /* Sin argumentos: Bash imprime el entorno exportado (declare -x).
-       Aquí devolvemos 0 para tus tests actuales. */
-    if (!argv[1]) return 0;
-
-    for (int i = 1; argv[i]; ++i) {
-        char *arg = argv[i];
-        char *eq  = strchr(arg, '=');
+    if (!is_valid_name(name))
+    {
+        ft_dprintf(2, "minishell: export: `%s': not a valid identifier\n", name);
+        return (1);
+    }
+    env_set_exported(sh, name, NULL, 1);
+    return (0);
+}
 
-        if (!eq) {
-            /* solo marcar como exportada */
-            if (!is_valid_name(arg)) {
-                fprintf(stderr, "minishell: export: `%s': not a valid identifier\n", arg);
-                status = 1;
-                continue;
-            }
-            env_set_exported(shell, arg, NULL, 1);
-            continue;
-        }
+/* export NAME=VALUE (sin espacios) */
+static int  export_with_value(t_shell *sh, const char *arg)
+{
+    const char  *eq;
+    char        *name;
+    char        *value;
+    int         name_len;
+    int         st;
 
-        /* NAME=VALUE (sin espacios) */
-        *eq = '\0';
-        const char *name  = arg;
-        const char *value = eq + 1;
+    eq = ft_strchr(arg, '=');
+    if (!eq)
+        return (export_mark_only(sh, arg));
+    name_len = (int)(eq - arg);
+    name = ft_substr(arg, 0, name_len);
+    if (!name)
+        return (1);
+    if (!is_valid_name(name))
+    {
+        ft_dprintf(2, "minishell: export: `%s=': not a valid identifier\n", name);
+        free(name);
+        return (1);
+    }
+    value = ft_strdup(eq + 1);
+    if (!value)
+    {
+        free(name);
+        return (1);
+    }
+    env_set_exported(sh, name, value, 0);
+    free(name);
+    free(value);
+    st = 0;
+    return (st);
+}
 
-        if (!is_valid_name(name)) {
-            fprintf(stderr, "minishell: export: `%s=': not a valid identifier\n", name);
-            status = 1;
-            *eq = '=';
-            continue;
-        }
+/* builtin export */
+int run_export(char **argv, t_shell *shell)
+{
+    int i;
+    int status;
 
-        env_set_exported(shell, name, value, 0);
-        *eq = '=';
+    if (!argv || !shell)
+        return (1);
+    if (!argv[1])
+        return (0); /* puedes imprimir declare -x aquí si lo deseas */
+    status = 0;
+    i = 1;
+    while (argv[i])
+    {
+        status |= export_with_value(shell, argv[i]);
+        i++;
     }
-    return status;
+    return (status != 0);
 }
diff --git a/src/builtins/is_builtin.c b/src/builtins/is_builtin.c
index 39f6cf9..7d7b177 100644
--- a/src/builtins/is_builtin.c
+++ b/src/builtins/is_builtin.c
@@ -16,12 +16,9 @@ int	is_builtin(const char *cmd)
 {
 	if (!cmd)
 		return (0);
-	if (ft_strcmp(cmd, "echo") == 0
-		|| ft_strcmp(cmd, "cd") == 0
-		|| ft_strcmp(cmd, "pwd") == 0
-		|| ft_strcmp(cmd, "export") == 0
-		|| ft_strcmp(cmd, "unset") == 0
-		|| ft_strcmp(cmd, "env") == 0
+	if (ft_strcmp(cmd, "echo") == 0 || ft_strcmp(cmd, "cd") == 0
+		|| ft_strcmp(cmd, "pwd") == 0 || ft_strcmp(cmd, "export") == 0
+		|| ft_strcmp(cmd, "unset") == 0 || ft_strcmp(cmd, "env") == 0
 		|| ft_strcmp(cmd, "exit") == 0)
 		return (1);
 	return (0);
diff --git a/src/builtins/pwd_builtin.c b/src/builtins/pwd_builtin.c
index f3e3eed..78c3380 100644
--- a/src/builtins/pwd_builtin.c
+++ b/src/builtins/pwd_builtin.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "builtins.h"
+#include "minishell.h"
 
 // ----------- PWD -----------
 int	run_pwd(void)
diff --git a/src/builtins/run_builtin.c b/src/builtins/run_builtin.c
index 7d79bd2..6d58cb2 100644
--- a/src/builtins/run_builtin.c
+++ b/src/builtins/run_builtin.c
@@ -10,14 +10,14 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "ast.h"
-#include "exec.h"
 #include "builtins.h"
+#include "exec.h"
+#include "minishell.h"
 
-int run_builtin(t_ast *node, t_shell *shell)
+int	run_builtin(t_ast *node, t_shell *shell)
 {
-	char **argv;
+	char	**argv;
 
 	if (!node || !node->cmd.argv || !node->cmd.argv[0])
 		return (1);
diff --git a/src/builtins/unset_builtin.c b/src/builtins/unset_builtin.c
index 77e9104..1123e3b 100644
--- a/src/builtins/unset_builtin.c
+++ b/src/builtins/unset_builtin.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "builtins.h"
+#include "minishell.h"
 
 // ----------- UNSET -----------
 int	run_unset(char **argv, t_shell *shell)
diff --git a/src/env/env_get_value.c b/src/env/env_get_value.c
index 09474bb..dec3f65 100644
--- a/src/env/env_get_value.c
+++ b/src/env/env_get_value.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "env.h"
+#include "minishell.h"
 
 char	*get_env_value(t_shell *shell, const char *key)
 {
diff --git a/src/env/free_env_list.c b/src/env/free_env_list.c
index 9d61dd0..6a92234 100644
--- a/src/env/free_env_list.c
+++ b/src/env/free_env_list.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "env.h"
+#include "minishell.h"
 
 void	free_env_list(t_env *env)
 {
diff --git a/src/env/get_env_array.c b/src/env/get_env_array.c
index 8f742b9..6ab1c25 100644
--- a/src/env/get_env_array.c
+++ b/src/env/get_env_array.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "env.h"
+#include "minishell.h"
 
 static int	env_count(t_env *env)
 {
@@ -36,7 +36,7 @@ static char	*join_key_value(const char *key, const char *value)
 	if (!tmp)
 		return (NULL);
 	if (!value)
-		res = ft_strdup(tmp);      /* "KEY=" */
+		res = ft_strdup(tmp); /* "KEY=" */
 	else
 		res = ft_strjoin(tmp, value);
 	free(tmp);
diff --git a/src/env/init_env_list.c b/src/env/init_env_list.c
index 3b336c4..fc2b7ca 100644
--- a/src/env/init_env_list.c
+++ b/src/env/init_env_list.c
@@ -13,7 +13,8 @@
 #include "minishell.h"
 
 // Based on POSIX definition of valid environment variable names
-// “Environment variable names consist solely of uppercase letters, digits, and the underscore (‘_’). The first character shall not be a digit.”
+// “Environment variable names consist solely of uppercase letters, digits,
+	and the underscore (‘_’). The first character shall not be a digit.”
 static int	is_valid_env_name(const char *s)
 {
 	int				i;
@@ -28,8 +29,8 @@ static int	is_valid_env_name(const char *s)
 	while (s[i])
 	{
 		c = (unsigned char)s[i];
-		if (!(c == '_' || (c >= 'A' && c <= 'Z')
-				|| (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')))
+		if (!(c == '_' || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
+				|| (c >= '0' && c <= '9')))
 			return (0);
 		i++;
 	}
diff --git a/src/exec/execute_and_or.c b/src/exec/execute_and_or.c
index bc74674..ac7fcd9 100644
--- a/src/exec/execute_and_or.c
+++ b/src/exec/execute_and_or.c
@@ -12,26 +12,26 @@
 
 #include "minishell.h"
 
-int execute_and(t_ast *node, t_shell *shell)
+int	execute_and(t_ast *node, t_shell *shell)
 {
-    int ret;
+	int	ret;
 
-    ret = execute_ast(node->bin.left, shell);
-    if (ret == 0)
-        ret = execute_ast(node->bin.right, shell);
-    else
-        shell->exit_status = ret;
-    return (ret);
+	ret = execute_ast(node->bin.left, shell);
+	if (ret == 0)
+		ret = execute_ast(node->bin.right, shell);
+	else
+		shell->exit_status = ret;
+	return (ret);
 }
 
-int execute_or(t_ast *node, t_shell *shell)
+int	execute_or(t_ast *node, t_shell *shell)
 {
-    int ret;
+	int	ret;
 
-    ret = execute_ast(node->bin.left, shell);
-    if (ret != 0)
-        ret = execute_ast(node->bin.right, shell);
-    else
-        shell->exit_status = ret;
-    return (ret);
+	ret = execute_ast(node->bin.left, shell);
+	if (ret != 0)
+		ret = execute_ast(node->bin.right, shell);
+	else
+		shell->exit_status = ret;
+	return (ret);
 }
diff --git a/src/exec/execute_ast.c b/src/exec/execute_ast.c
index ef618af..6165eb3 100644
--- a/src/exec/execute_ast.c
+++ b/src/exec/execute_ast.c
@@ -12,37 +12,38 @@
 
 #include "minishell.h"
 
-int execute_ast(t_ast *node, t_shell *shell)
+int	execute_ast(t_ast *node, t_shell *shell)
 {
-    int ret;
+	int	ret;
 
-    if (!node)
-        return (0);
-    if (node->type == N_COMMAND)
-        ret = execute_command(node, shell);
-    else if (node->type == N_PIPE)
-        ret = execute_pipe(node, shell);
-    else if (node->type == N_AND)
-        ret = execute_and(node, shell);
-    else if (node->type == N_OR)
-        ret = execute_or(node, shell);
-    else if (node->type == N_SUBSHELL)
-        ret = execute_subshell(node, shell);
-    else if (node->type == N_SEQUENCE)
-        ret = execute_sequence(node, shell);
-    else if (node->type == N_BACKGROUND)
-        ret = execute_background(node, shell);
-    else if (node->type == N_REDIR)
-    {
-        ft_dprintf(2, "minishell: syntax error near unexpected token `newline'\n");
-        shell->exit_status = 2;
-        ret = 1;
-    }
-    else
-    {
-        ft_dprintf(2, "minishell: command not found\n");
-        shell->exit_status = 127;
-        ret = 127;
-    }
-    return (ret);
+	if (!node)
+		return (0);
+	if (node->type == N_COMMAND)
+		ret = execute_command(node, shell);
+	else if (node->type == N_PIPE)
+		ret = execute_pipe(node, shell);
+	else if (node->type == N_AND)
+		ret = execute_and(node, shell);
+	else if (node->type == N_OR)
+		ret = execute_or(node, shell);
+	else if (node->type == N_SUBSHELL)
+		ret = execute_subshell(node, shell);
+	else if (node->type == N_SEQUENCE)
+		ret = execute_sequence(node, shell);
+	else if (node->type == N_BACKGROUND)
+		ret = execute_background(node, shell);
+	else if (node->type == N_REDIR)
+	{
+		ft_dprintf(2,
+			"minishell: syntax error near unexpected token `newline'\n");
+		shell->exit_status = 2;
+		ret = 1;
+	}
+	else
+	{
+		ft_dprintf(2, "minishell: command not found\n");
+		shell->exit_status = 127;
+		ret = 127;
+	}
+	return (ret);
 }
diff --git a/src/exec/execute_background.c b/src/exec/execute_background.c
index 1c05a8c..58cb087 100644
--- a/src/exec/execute_background.c
+++ b/src/exec/execute_background.c
@@ -12,26 +12,26 @@
 
 #include "minishell.h"
 
-int execute_background(t_ast *node, t_shell *shell)
+int	execute_background(t_ast *node, t_shell *shell)
 {
-    pid_t pid;
+	pid_t	pid;
 
-    pid = fork();
-    if (pid < 0)
-    {
-        ft_dprintf(2, "minishell: fork error\n");
-        shell->exit_status = 1;
-        return (1);
-    }
-    if (pid == 0)
-    {
-        /* Hijo: señales por defecto para comportamiento bash-like */
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        _exit(execute_ast(node->bin.left, shell) & 0xFF);
-    }
-    /* Padre: no espera al hijo en background */
-    shell->exit_status = 0;
-    ft_dprintf(1, "[1] %d\n", pid);
-    return (0);
+	pid = fork();
+	if (pid < 0)
+	{
+		ft_dprintf(2, "minishell: fork error\n");
+		shell->exit_status = 1;
+		return (1);
+	}
+	if (pid == 0)
+	{
+		/* Hijo: señales por defecto para comportamiento bash-like */
+		signal(SIGINT, SIG_DFL);
+		signal(SIGQUIT, SIG_DFL);
+		_exit(execute_ast(node->bin.left, shell) & 0xFF);
+	}
+	/* Padre: no espera al hijo en background */
+	shell->exit_status = 0;
+	ft_dprintf(1, "[1] %d\n", pid);
+	return (0);
 }
diff --git a/src/exec/execute_command.c b/src/exec/execute_command.c
index 1c1a56e..18615f6 100644
--- a/src/exec/execute_command.c
+++ b/src/exec/execute_command.c
@@ -37,110 +37,113 @@ int	execute_command(t_ast *node, t_shell *shell)
 	char	**env;
 	char	*exec_path;
 	int		status;
-	int		saved_in  = -1;
-	int		saved_out = -1;
-	int		saved_err = -1;
+	int		saved_in;
+	int		saved_out;
+	int		saved_err;
+	int		sig;
 
+	saved_in = -1;
+	saved_out = -1;
+	saved_err = -1;
 	if (!node)
 	{
 		shell->exit_status = 0;
-		return 0;
+		return (0);
 	}
-
 	/* === SOLO REDIRECCIONES (sin argv) ===
-	   Bash permite comandos vacíos con redirs; aplicamos redirs y devolvemos 0 si no hay error. */
+		Bash permite comandos vacíos con redirs; aplicamos redirs y devolvemos 0 si no hay error. */
 	if ((!node->cmd.argv || !node->cmd.argv[0]) && node->cmd.redirections)
 	{
-		saved_in  = dup(STDIN_FILENO);
+		saved_in = dup(STDIN_FILENO);
 		saved_out = dup(STDOUT_FILENO);
 		saved_err = dup(STDERR_FILENO);
 		if (saved_in == -1 || saved_out == -1 || saved_err == -1)
 		{
 			perror("minishell: dup");
-			if (saved_in  != -1) close(saved_in);
-			if (saved_out != -1) close(saved_out);
-			if (saved_err != -1) close(saved_err);
+			if (saved_in != -1)
+				close(saved_in);
+			if (saved_out != -1)
+				close(saved_out);
+			if (saved_err != -1)
+				close(saved_err);
 			shell->exit_status = 1;
-			return 1;
+			return (1);
 		}
 		if (apply_redirections(node->cmd.redirections) != 0)
 		{
 			restore_std_fds(saved_in, saved_out, saved_err);
 			shell->exit_status = 1;
-			return 1;
+			return (1);
 		}
 		restore_std_fds(saved_in, saved_out, saved_err);
 		shell->exit_status = 0;
-		return 0;
+		return (0);
 	}
-
 	/* Comando vacío y sin redirecciones → no hace nada, exit 0 */
 	if (!node->cmd.argv || !node->cmd.argv[0])
 	{
 		shell->exit_status = 0;
-		return 0;
+		return (0);
 	}
-
 	/* argv[0] vacío -> "command not found" */
 	if (node->cmd.argv[0][0] == '\0')
 	{
 		ft_dprintf(2, "minishell: : command not found\n");
 		shell->exit_status = 127;
-		return 127;
+		return (127);
 	}
-
 	/* Builtins en el proceso padre con redirecciones aplicadas temporalmente */
 	if (is_builtin(node->cmd.argv[0]))
 	{
-		saved_in  = dup(STDIN_FILENO);
+		saved_in = dup(STDIN_FILENO);
 		saved_out = dup(STDOUT_FILENO);
 		saved_err = dup(STDERR_FILENO);
 		if (saved_in == -1 || saved_out == -1 || saved_err == -1)
 		{
 			perror("minishell: dup");
-			if (saved_in  != -1) close(saved_in);
-			if (saved_out != -1) close(saved_out);
-			if (saved_err != -1) close(saved_err);
+			if (saved_in != -1)
+				close(saved_in);
+			if (saved_out != -1)
+				close(saved_out);
+			if (saved_err != -1)
+				close(saved_err);
 			shell->exit_status = 1;
-			return 1;
+			return (1);
 		}
 		if (apply_redirections(node->cmd.redirections) != 0)
 		{
 			restore_std_fds(saved_in, saved_out, saved_err);
 			shell->exit_status = 1;
-			return 1;
+			return (1);
 		}
 		shell->exit_status = run_builtin(node, shell);
 		restore_std_fds(saved_in, saved_out, saved_err);
-		return shell->exit_status;
+		return (shell->exit_status);
 	}
-
 	/* Búsqueda de ejecutable externo */
 	exec_path = find_executable(node->cmd.argv[0], shell);
 	if (!exec_path)
 	{
 		if (!ft_strchr(node->cmd.argv[0], '/'))
-			return print_exec_error(shell, node->cmd.argv[0], ENOENT);
+			return (print_exec_error(shell, node->cmd.argv[0], ENOENT));
 		if (errno == 0)
-			return print_exec_error(shell, node->cmd.argv[0], ENOENT);
-		return print_exec_error(shell, node->cmd.argv[0], errno);
+			return (print_exec_error(shell, node->cmd.argv[0], ENOENT));
+		return (print_exec_error(shell, node->cmd.argv[0], errno));
 	}
-
 	env = env_to_array(shell->env);
 	if (!env)
 	{
 		free(exec_path);
 		shell->exit_status = 1;
-		return 1;
+		return (1);
 	}
-
 	pid = fork();
 	if (pid < 0)
 	{
 		status = print_exec_error(shell, node->cmd.argv[0], errno);
 		free(exec_path);
 		ft_free_strtab(env);
-		return status;
+		return (status);
 	}
 	if (pid == 0)
 	{
@@ -152,14 +155,13 @@ int	execute_command(t_ast *node, t_shell *shell)
 		print_exec_error(shell, node->cmd.argv[0], errno);
 		_exit(127);
 	}
-
 	if (waitpid(pid, &status, 0) == -1)
 		shell->exit_status = 1;
 	else if (WIFEXITED(status))
 		shell->exit_status = WEXITSTATUS(status);
 	else if (WIFSIGNALED(status))
 	{
-		int sig = WTERMSIG(status);
+		sig = WTERMSIG(status);
 		shell->exit_status = 128 + sig;
 		if (sig == SIGINT)
 			write(STDOUT_FILENO, "\n", 1);
@@ -168,8 +170,7 @@ int	execute_command(t_ast *node, t_shell *shell)
 	}
 	else
 		shell->exit_status = 1;
-
 	free(exec_path);
 	ft_free_strtab(env);
-	return shell->exit_status;
+	return (shell->exit_status);
 }
diff --git a/src/exec/execute_heredocs.c b/src/exec/execute_heredocs.c
index f5f4c1e..b85529e 100644
--- a/src/exec/execute_heredocs.c
+++ b/src/exec/execute_heredocs.c
@@ -6,12 +6,12 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/29 15:27:07 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:01:40 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/04 16:15:48 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "exec.h"
+#include "minishell.h"
 
 /*
 ** Heredoc: lee hasta 'delimiter', escribe en un pipe y devuelve fd de lectura.
@@ -23,31 +23,29 @@ int	heredoc_prepare(const char *delimiter)
 	char	*line;
 	size_t	dlen;
 
-	if (!delimiter) return (-1);
+	if (!delimiter)
+		return (-1);
 	dlen = ft_strlen(delimiter);
 	if (pipe(pipefd) == -1)
 		return (-1);
-
 	/* Mientras se lee el heredoc, ^C aborta lectura; ^\ se ignora */
 	signal(SIGQUIT, SIG_IGN);
 	signal(SIGINT, SIG_DFL);
-
 	while (1)
 	{
 		line = readline("> ");
 		if (!line)
-			break;
+			break ;
 		if (ft_strncmp(line, delimiter, dlen) == 0 && line[dlen] == '\0')
 		{
 			free(line);
-			break;
+			break ;
 		}
 		write(pipefd[1], line, ft_strlen(line));
 		write(pipefd[1], "\n", 1);
 		free(line);
 	}
 	close(pipefd[1]);
-
 	/* Restauramos defaults típicos del hijo al salir del heredoc */
 	signal(SIGQUIT, SIG_DFL);
 	signal(SIGINT, SIG_DFL);
diff --git a/src/exec/execute_pipe.c b/src/exec/execute_pipe.c
index e8be449..dde091e 100644
--- a/src/exec/execute_pipe.c
+++ b/src/exec/execute_pipe.c
@@ -12,64 +12,60 @@
 
 #include "minishell.h"
 
-int execute_pipe(t_ast *node, t_shell *shell)
+int	execute_pipe(t_ast *node, t_shell *shell)
 {
-    int     pipefd[2];
-    pid_t   pid_l, pid_r;
-    int     st_l = 0, st_r = 0;
+	int	pipefd[2];
+	int	st_l = 0, st_r;
+	int	sig;
 
-    if (pipe(pipefd) == -1)
-    {
-        ft_dprintf(2, "minishell: pipe error\n");
-        shell->exit_status = 1;
-        return (1);
-    }
-
-    pid_l = fork();
-    if (pid_l == 0)
-    {
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        close(pipefd[0]);
-        if (dup2(pipefd[1], STDOUT_FILENO) < 0)
-            _exit(1);
-        close(pipefd[1]);
-        _exit(execute_ast(node->bin.left, shell) & 0xFF);
-    }
-
-    pid_r = fork();
-    if (pid_r == 0)
-    {
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        close(pipefd[1]);
-        if (dup2(pipefd[0], STDIN_FILENO) < 0)
-            _exit(1);
-        close(pipefd[0]);
-        _exit(execute_ast(node->bin.right, shell) & 0xFF);
-    }
-
-    close(pipefd[0]);
-    close(pipefd[1]);
-
-    if (waitpid(pid_l, &st_l, 0) < 0)
-        st_l = 0;
-    if (waitpid(pid_r, &st_r, 0) < 0)
-        st_r = 0;
-
-    if (WIFEXITED(st_r))
-        shell->exit_status = WEXITSTATUS(st_r);
-    else if (WIFSIGNALED(st_r))
-    {
-        int sig = WTERMSIG(st_r);
-        if (sig == SIGINT)
-            write(STDOUT_FILENO, "\n", 1);
-        else if (sig == SIGQUIT)
-            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
-        shell->exit_status = 128 + sig;
-    }
-    else
-        shell->exit_status = 1;
-
-    return (shell->exit_status);
+	pid_t pid_l, pid_r;
+	st_l = 0, st_r = 0;
+	if (pipe(pipefd) == -1)
+	{
+		ft_dprintf(2, "minishell: pipe error\n");
+		shell->exit_status = 1;
+		return (1);
+	}
+	pid_l = fork();
+	if (pid_l == 0)
+	{
+		signal(SIGINT, SIG_DFL);
+		signal(SIGQUIT, SIG_DFL);
+		close(pipefd[0]);
+		if (dup2(pipefd[1], STDOUT_FILENO) < 0)
+			_exit(1);
+		close(pipefd[1]);
+		_exit(execute_ast(node->bin.left, shell) & 0xFF);
+	}
+	pid_r = fork();
+	if (pid_r == 0)
+	{
+		signal(SIGINT, SIG_DFL);
+		signal(SIGQUIT, SIG_DFL);
+		close(pipefd[1]);
+		if (dup2(pipefd[0], STDIN_FILENO) < 0)
+			_exit(1);
+		close(pipefd[0]);
+		_exit(execute_ast(node->bin.right, shell) & 0xFF);
+	}
+	close(pipefd[0]);
+	close(pipefd[1]);
+	if (waitpid(pid_l, &st_l, 0) < 0)
+		st_l = 0;
+	if (waitpid(pid_r, &st_r, 0) < 0)
+		st_r = 0;
+	if (WIFEXITED(st_r))
+		shell->exit_status = WEXITSTATUS(st_r);
+	else if (WIFSIGNALED(st_r))
+	{
+		sig = WTERMSIG(st_r);
+		if (sig == SIGINT)
+			write(STDOUT_FILENO, "\n", 1);
+		else if (sig == SIGQUIT)
+			write(STDERR_FILENO, "Quit (core dumped)\n", 19);
+		shell->exit_status = 128 + sig;
+	}
+	else
+		shell->exit_status = 1;
+	return (shell->exit_status);
 }
diff --git a/src/exec/execute_redirections.c b/src/exec/execute_redirections.c
index 64ae68f..d975871 100644
--- a/src/exec/execute_redirections.c
+++ b/src/exec/execute_redirections.c
@@ -10,12 +10,14 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "exec.h"
+#include "minishell.h"
 
 static int	redirect_to(int fd, int std_fd)
 {
-	int	ret = 0;
+	int	ret;
+
+	ret = 0;
 	if (dup2(fd, std_fd) < 0)
 	{
 		perror("minishell: dup2");
@@ -28,7 +30,9 @@ static int	redirect_to(int fd, int std_fd)
 
 int	handle_heredoc(t_ast *redir)
 {
-	int	fd = heredoc_prepare(redir->redir.delimiter);
+	int	fd;
+
+	fd = heredoc_prepare(redir->redir.delimiter);
 	if (fd < 0)
 		return (1);
 	return (redirect_to(fd, STDIN_FILENO));
@@ -36,9 +40,11 @@ int	handle_heredoc(t_ast *redir)
 
 int	open_redirection(t_ast *redir)
 {
-	int	fd = -1;
+	int	fd;
 
-	if (!redir || redir->type != N_REDIR) return (-1);
+	fd = -1;
+	if (!redir || redir->type != N_REDIR)
+		return (-1);
 	if (redir->redir.redir_type == REDIR_IN)
 		fd = open(redir->redir.filename, O_RDONLY);
 	else if (redir->redir.redir_type == REDIR_OUT
@@ -59,10 +65,13 @@ int	open_redirection(t_ast *redir)
 
 static int	handle_dup_redir(t_ast *redir)
 {
-	int	target = redir->redir.redir_fd;
-	int	std_fd = (redir->redir.redir_type == REDIR_DUP_OUT) ? STDOUT_FILENO : STDIN_FILENO;
+	int	target;
+	int	std_fd;
 
-	if (target == std_fd) return (0);
+	target = redir->redir.redir_fd;
+	std_fd = (redir->redir.redir_type == REDIR_DUP_OUT) ? STDOUT_FILENO : STDIN_FILENO;
+	if (target == std_fd)
+		return (0);
 	if (dup2(target, std_fd) < 0)
 	{
 		perror("minishell: dup2");
@@ -73,9 +82,11 @@ static int	handle_dup_redir(t_ast *redir)
 
 int	handle_simple_redir(t_ast *redir)
 {
-	int	fd = open_redirection(redir);
-	int	ret = 0;
+	int	fd;
+	int	ret;
 
+	fd = open_redirection(redir);
+	ret = 0;
 	if (fd < 0)
 	{
 		perror(redir->redir.filename);
@@ -93,58 +104,62 @@ int	handle_simple_redir(t_ast *redir)
 	else if (redir->redir.redir_type == REDIR_ALL
 		|| redir->redir.redir_type == REDIR_APPEND_ALL)
 	{
-		if (dup2(fd, STDOUT_FILENO) < 0) ret = 1;
-		else if (dup2(fd, STDERR_FILENO) < 0) ret = 1;
+		if (dup2(fd, STDOUT_FILENO) < 0)
+			ret = 1;
+		else if (dup2(fd, STDERR_FILENO) < 0)
+			ret = 1;
 		close(fd);
 	}
 	return (ret);
 }
 
-int apply_redirections(t_ast *redir_list)
+int	apply_redirections(t_ast *redir_list)
 {
-    t_ast *curr = redir_list;
-    int    fail = 0;
+	t_ast	*curr;
+	int		fail;
+	int		fd;
 
-    while (curr)
-    {
-        if (curr->type != N_REDIR)
-            return 1;
-
-        if (curr->redir.redir_type == REDIR_HEREDOC)
-        {
-            /* === HEREDOC inline, sin handle_heredoc === */
-            int fd = heredoc_prepare(curr->redir.delimiter);
-            if (fd < 0)
-            {
-                fail = 1;
-            }
-            else
-            {
-                /* reutilizamos tu helper redirect_to() para enganchar a STDIN */
-                if (dup2(fd, STDIN_FILENO) < 0)
-                {
-                    perror("minishell: dup2");
-                    close(fd);
-                    fail = 1;
-                }
-                else
-                {
-                    close(fd);
-                }
-            }
-        }
-        else if (curr->redir.redir_type == REDIR_DUP_IN
-              || curr->redir.redir_type == REDIR_DUP_OUT)
-        {
-            if (handle_dup_redir(curr))
-                fail = 1;
-        }
-        else
-        {
-            if (handle_simple_redir(curr))
-                fail = 1;
-        }
-        curr = curr->bin.right;
-    }
-    return fail ? 1 : 0;
+	curr = redir_list;
+	fail = 0;
+	while (curr)
+	{
+		if (curr->type != N_REDIR)
+			return (1);
+		if (curr->redir.redir_type == REDIR_HEREDOC)
+		{
+			/* === HEREDOC inline, sin handle_heredoc === */
+			fd = heredoc_prepare(curr->redir.delimiter);
+			if (fd < 0)
+			{
+				fail = 1;
+			}
+			else
+			{
+				/* reutilizamos tu helper redirect_to() para enganchar a STDIN */
+				if (dup2(fd, STDIN_FILENO) < 0)
+				{
+					perror("minishell: dup2");
+					close(fd);
+					fail = 1;
+				}
+				else
+				{
+					close(fd);
+				}
+			}
+		}
+		else if (curr->redir.redir_type == REDIR_DUP_IN
+			|| curr->redir.redir_type == REDIR_DUP_OUT)
+		{
+			if (handle_dup_redir(curr))
+				fail = 1;
+		}
+		else
+		{
+			if (handle_simple_redir(curr))
+				fail = 1;
+		}
+		curr = curr->bin.right;
+	}
+	return (fail ? 1 : 0);
 }
diff --git a/src/exec/execute_sequence.c b/src/exec/execute_sequence.c
index c08e5e0..94c93d6 100644
--- a/src/exec/execute_sequence.c
+++ b/src/exec/execute_sequence.c
@@ -10,11 +10,11 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "exec.h"
 #include "ast.h"
+#include "exec.h"
+#include "minishell.h"
 
-int execute_sequence(t_ast *node, t_shell *shell)
+int	execute_sequence(t_ast *node, t_shell *shell)
 {
 	execute_ast(node->bin.left, shell);
 	return (execute_ast(node->bin.right, shell));
diff --git a/src/exec/execute_subshell.c b/src/exec/execute_subshell.c
index 5cb4e89..d3fc4af 100644
--- a/src/exec/execute_subshell.c
+++ b/src/exec/execute_subshell.c
@@ -12,39 +12,40 @@
 
 #include "minishell.h"
 
-int execute_subshell(t_ast *node, t_shell *shell)
+int	execute_subshell(t_ast *node, t_shell *shell)
 {
-    pid_t pid;
-    int   st = 0;
+	pid_t	pid;
+	int		st;
+	int		sig;
 
-    pid = fork();
-    if (pid < 0)
-    {
-        ft_dprintf(2, "minishell: fork error\n");
-        shell->exit_status = 1;
-        return (1);
-    }
-    if (pid == 0)
-    {
-        signal(SIGINT, SIG_DFL);
-        signal(SIGQUIT, SIG_DFL);
-        _exit(execute_ast(node->subshell.child, shell) & 0xFF);
-    }
-    if (waitpid(pid, &st, 0) < 0)
-        shell->exit_status = 1;
-    else if (WIFEXITED(st))
-        shell->exit_status = WEXITSTATUS(st);
-    else if (WIFSIGNALED(st))
-    {
-        int sig = WTERMSIG(st);
-        if (sig == SIGINT)
-            write(STDOUT_FILENO, "\n", 1);
-        else if (sig == SIGQUIT)
-            write(STDERR_FILENO, "Quit (core dumped)\n", 19);
-        shell->exit_status = 128 + sig;
-    }
-    else
-        shell->exit_status = 1;
-
-    return (shell->exit_status);
+	st = 0;
+	pid = fork();
+	if (pid < 0)
+	{
+		ft_dprintf(2, "minishell: fork error\n");
+		shell->exit_status = 1;
+		return (1);
+	}
+	if (pid == 0)
+	{
+		signal(SIGINT, SIG_DFL);
+		signal(SIGQUIT, SIG_DFL);
+		_exit(execute_ast(node->subshell.child, shell) & 0xFF);
+	}
+	if (waitpid(pid, &st, 0) < 0)
+		shell->exit_status = 1;
+	else if (WIFEXITED(st))
+		shell->exit_status = WEXITSTATUS(st);
+	else if (WIFSIGNALED(st))
+	{
+		sig = WTERMSIG(st);
+		if (sig == SIGINT)
+			write(STDOUT_FILENO, "\n", 1);
+		else if (sig == SIGQUIT)
+			write(STDERR_FILENO, "Quit (core dumped)\n", 19);
+		shell->exit_status = 128 + sig;
+	}
+	else
+		shell->exit_status = 1;
+	return (shell->exit_status);
 }
diff --git a/src/exec/execute_utils.c b/src/exec/execute_utils.c
index de80de5..9bedce8 100644
--- a/src/exec/execute_utils.c
+++ b/src/exec/execute_utils.c
@@ -10,10 +10,10 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
+#include "ast.h"
 #include "env.h"
 #include "exec.h"
-#include "ast.h"
+#include "minishell.h"
 #include <errno.h>
 #include <sys/stat.h>
 
diff --git a/src/expand/calculate_expand_len.c b/src/expand/calculate_expand_len.c
index 0b9ee9b..77c1dcd 100644
--- a/src/expand/calculate_expand_len.c
+++ b/src/expand/calculate_expand_len.c
@@ -10,79 +10,119 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
-size_t  handle_dollar_len(const char *str, int *i, t_shell *shell)
+size_t	handle_dollar_len(const char *str, int *i, t_shell *shell)
 {
-    char    *expanded;
-    size_t  len;
+	char	*expanded;
+	size_t	len;
 
-    (*i)++; /* saltar '$' */
-    expanded = expand_value(str, i, shell); /* avanza *i tras el nombre */
-    if (!expanded)
-        return (size_t)-1;
-    len = ft_strlen(expanded);
-    free(expanded);
-    return len;
+	(*i)++;                                 /* saltar '$' */
+	expanded = expand_value(str, i, shell); /* avanza *i tras el nombre */
+	if (!expanded)
+		return ((size_t)-1);
+	len = ft_strlen(expanded);
+	free(expanded);
+	return (len);
 }
 
-size_t  calculate_expanded_len(const char *str, t_shell *shell)
+size_t	calculate_expanded_len(const char *str, t_shell *shell)
 {
-    size_t  total = 0;
-    int     i = 0;
-    t_quote q = NO_QUOTE;
-
-    while (str[i])
-    {
-        if (str[i] == '\'')
-        {
-            if (q == NO_QUOTE) q = SINGLE_QUOTE;
-            else if (q == SINGLE_QUOTE) q = NO_QUOTE;
-            total += 1; i++; continue;
-        }
-        if (str[i] == '"')
-        {
-            if (q == NO_QUOTE) q = DOUBLE_QUOTE;
-            else if (q == DOUBLE_QUOTE) q = NO_QUOTE;
-            total += 1; i++; continue;
-        }
-
-        if (str[i] == '\\')
-        {
-            if (q == SINGLE_QUOTE) { total += 1; i += 1; continue; }
-            if (q == DOUBLE_QUOTE)
-            {
-                if (str[i+1] == '\n') { i += 2; continue; }
-                if (str[i+1]) { total += 2; i += 2; continue; } /* '\'+char */
-                total += 1; i += 1; continue; /* '\' final */
-            }
-            /* NO_QUOTE */
-            if (str[i+1] == '\n') { i += 2; continue; }
-            if (str[i+1] == '$') { total += 1; i += 2; continue; } /* \$ -> '$' */
-            total += 1; i += 1; continue; /* preservamos '\' */
-        }
-
-        if (q != SINGLE_QUOTE && str[i] == '$')
-        {
-            size_t add = handle_dollar_len(str, &i, shell);
-            if (add == (size_t)-1) return (size_t)-1;
-            total += add;
-            continue;
-        }
-
-        if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i-1]) || str[i-1] == '='))
-        {
-            char *t = expand_tilde_internal(str + i, shell);
-            if (!t) return (size_t)-1;
-            total += ft_strlen(t);
-            i += get_tilde_prefix_len(str + i);
-            free(t);
-            continue;
-        }
+	size_t	total;
+	int		i;
+	t_quote	q;
+	size_t	add;
+	char	*t;
 
-        total += 1; i++;
-    }
-    return total;
+	total = 0;
+	i = 0;
+	q = NO_QUOTE;
+	while (str[i])
+	{
+		if (str[i] == '\'')
+		{
+			if (q == NO_QUOTE)
+				q = SINGLE_QUOTE;
+			else if (q == SINGLE_QUOTE)
+				q = NO_QUOTE;
+			total += 1;
+			i++;
+			continue ;
+		}
+		if (str[i] == '"')
+		{
+			if (q == NO_QUOTE)
+				q = DOUBLE_QUOTE;
+			else if (q == DOUBLE_QUOTE)
+				q = NO_QUOTE;
+			total += 1;
+			i++;
+			continue ;
+		}
+		if (str[i] == '\\')
+		{
+			if (q == SINGLE_QUOTE)
+			{
+				total += 1;
+				i += 1;
+				continue ;
+			}
+			if (q == DOUBLE_QUOTE)
+			{
+				if (str[i + 1] == '\n')
+				{
+					i += 2;
+					continue ;
+				}
+				if (str[i + 1])
+				{
+					total += 2;
+					i += 2;
+					continue ;
+				} /* '\'+char */
+				total += 1;
+				i += 1;
+				continue ; /* '\' final */
+			}
+			/* NO_QUOTE */
+			if (str[i + 1] == '\n')
+			{
+				i += 2;
+				continue ;
+			}
+			if (str[i + 1] == '$')
+			{
+				total += 1;
+				i += 2;
+				continue ;
+			} /* \$ -> '$' */
+			total += 1;
+			i += 1;
+			continue ; /* preservamos '\' */
+		}
+		if (q != SINGLE_QUOTE && str[i] == '$')
+		{
+			add = handle_dollar_len(str, &i, shell);
+			if (add == (size_t)-1)
+				return ((size_t)-1);
+			total += add;
+			continue ;
+		}
+		if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i - 1])
+				|| str[i - 1] == '='))
+		{
+			t = expand_tilde_internal(str + i, shell);
+			if (!t)
+				return ((size_t)-1);
+			total += ft_strlen(t);
+			i += get_tilde_prefix_len(str + i);
+			free(t);
+			continue ;
+		}
+		total += 1;
+		i++;
+	}
+	return (total);
 }
diff --git a/src/expand/expand.c b/src/expand/expand.c
index 30f2bd2..50197eb 100644
--- a/src/expand/expand.c
+++ b/src/expand/expand.c
@@ -10,134 +10,157 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
-static int  copy_expanded_dollar(const char *str, int *i,
-                                 t_shell *shell, char *dst, int *j)
+static int	copy_expanded_dollar(const char *str, int *i, t_shell *shell,
+		char *dst, int *j)
 {
-    char    *expanded;
-    int     ii;
-    size_t  n;
+	char	*expanded;
+	int		ii;
+	size_t	n;
 
-    ii = *i + 1;
-    expanded = expand_value(str, &ii, shell);
-    if (!expanded)
-        return (-1);
-    n = ft_strlen(expanded);
-    ft_memcpy(dst + *j, expanded, n);
-    *j += (int)n;
-    free(expanded);
-    *i = ii;
-    return (0);
+	ii = *i + 1;
+	expanded = expand_value(str, &ii, shell);
+	if (!expanded)
+		return (-1);
+	n = ft_strlen(expanded);
+	ft_memcpy(dst + *j, expanded, n);
+	*j += (int)n;
+	free(expanded);
+	*i = ii;
+	return (0);
 }
 
-char    *expand_token(const char *str, t_shell *shell)
+char	*expand_token(const char *str, t_shell *shell)
 {
-    char    *res;
-    size_t  need;
-    int     i;
-    int     j;
-    t_quote q;
+	char	*res;
+	size_t	need;
+	int		i;
+	int		j;
+	t_quote	q;
+	char	*t;
 
-    if (!str)
-        return (NULL);
-    need = calculate_expanded_len(str, shell);
-    if (need == (size_t)-1)
-        return (NULL);
-    res = (char *)malloc(need + 1);
-    if (!res)
-        return (NULL);
-    i = 0;
-    j = 0;
-    q = NO_QUOTE;
-    while (str[i])
-    {
-        if (str[i] == '\'')
-        {
-            if (q == NO_QUOTE) q = SINGLE_QUOTE;
-            else if (q == SINGLE_QUOTE) q = NO_QUOTE;
-            res[j++] = str[i++];
-            continue;
-        }
-        if (str[i] == '"')
-        {
-            if (q == NO_QUOTE) q = DOUBLE_QUOTE;
-            else if (q == DOUBLE_QUOTE) q = NO_QUOTE;
-            res[j++] = str[i++];
-            continue;
-        }
-        if (str[i] == '\\')
-        {
-            if (q == SINGLE_QUOTE)
-            {
-                res[j++] = '\\';
-                i++;
-                continue;
-            }
-            if (q == DOUBLE_QUOTE)
-            {
-                if (str[i + 1] == '\n') { i += 2; continue; }
-                if (str[i + 1])
-                {
-                    res[j++] = '\\';
-                    res[j++] = str[i + 1];
-                    i += 2;
-                    continue;
-                }
-                res[j++] = '\\';
-                i++;
-                continue;
-            }
-            if (str[i + 1] == '\n') { i += 2; continue; }
-            if (str[i + 1] == '$') { i++; res[j++] = '$'; i++; continue; }
-            res[j++] = '\\';
-            i++;
-            continue;
-        }
-        if (q != SINGLE_QUOTE && str[i] == '$')
-        {
-            if (copy_expanded_dollar(str, &i, shell, res, &j) < 0)
-            {
-                free(res);
-                return (NULL);
-            }
-            continue;
-        }
-        if (str[i] == '~'
-            && (i == 0 || ft_isspace((unsigned char)str[i - 1]) || str[i - 1] == '='))
-        {
-            char *t = expand_tilde_internal(str + i, shell);
-            if (!t) { free(res); return (NULL); }
-            ft_strcpy(res + j, t);
-            j += (int)ft_strlen(t);
-            i += (int)get_tilde_prefix_len(str + i);
-            free(t);
-            continue;
-        }
-        res[j++] = str[i++];
-    }
-    res[j] = '\0';
-    return (res);
+	if (!str)
+		return (NULL);
+	need = calculate_expanded_len(str, shell);
+	if (need == (size_t)-1)
+		return (NULL);
+	res = (char *)malloc(need + 1);
+	if (!res)
+		return (NULL);
+	i = 0;
+	j = 0;
+	q = NO_QUOTE;
+	while (str[i])
+	{
+		if (str[i] == '\'')
+		{
+			if (q == NO_QUOTE)
+				q = SINGLE_QUOTE;
+			else if (q == SINGLE_QUOTE)
+				q = NO_QUOTE;
+			res[j++] = str[i++];
+			continue ;
+		}
+		if (str[i] == '"')
+		{
+			if (q == NO_QUOTE)
+				q = DOUBLE_QUOTE;
+			else if (q == DOUBLE_QUOTE)
+				q = NO_QUOTE;
+			res[j++] = str[i++];
+			continue ;
+		}
+		if (str[i] == '\\')
+		{
+			if (q == SINGLE_QUOTE)
+			{
+				res[j++] = '\\';
+				i++;
+				continue ;
+			}
+			if (q == DOUBLE_QUOTE)
+			{
+				if (str[i + 1] == '\n')
+				{
+					i += 2;
+					continue ;
+				}
+				if (str[i + 1])
+				{
+					res[j++] = '\\';
+					res[j++] = str[i + 1];
+					i += 2;
+					continue ;
+				}
+				res[j++] = '\\';
+				i++;
+				continue ;
+			}
+			if (str[i + 1] == '\n')
+			{
+				i += 2;
+				continue ;
+			}
+			if (str[i + 1] == '$')
+			{
+				i++;
+				res[j++] = '$';
+				i++;
+				continue ;
+			}
+			res[j++] = '\\';
+			i++;
+			continue ;
+		}
+		if (q != SINGLE_QUOTE && str[i] == '$')
+		{
+			if (copy_expanded_dollar(str, &i, shell, res, &j) < 0)
+			{
+				free(res);
+				return (NULL);
+			}
+			continue ;
+		}
+		if (str[i] == '~' && (i == 0 || ft_isspace((unsigned char)str[i - 1])
+				|| str[i - 1] == '='))
+		{
+			t = expand_tilde_internal(str + i, shell);
+			if (!t)
+			{
+				free(res);
+				return (NULL);
+			}
+			ft_strcpy(res + j, t);
+			j += (int)ft_strlen(t);
+			i += (int)get_tilde_prefix_len(str + i);
+			free(t);
+			continue ;
+		}
+		res[j++] = str[i++];
+	}
+	res[j] = '\0';
+	return (res);
 }
 
-int     expand_variables(t_shell *shell)
+int	expand_variables(t_shell *shell)
 {
-    t_token *t;
-    char    *expanded;
+	t_token	*t;
+	char	*expanded;
 
-    t = shell->tokens;
-    while (t)
-    {
-        expanded = expand_token(t->value, shell);
-        if (!expanded)
-            return (-1);
-        free(t->value);
-        t->value = expanded;
-        t = t->next;
-    }
-    perform_word_splitting(shell);
-    remove_quotes(shell->tokens);
-    return (0);
+	t = shell->tokens;
+	while (t)
+	{
+		expanded = expand_token(t->value, shell);
+		if (!expanded)
+			return (-1);
+		free(t->value);
+		t->value = expanded;
+		t = t->next;
+	}
+	perform_word_splitting(shell);
+	remove_quotes(shell->tokens);
+	return (0);
 }
diff --git a/src/expand/expand_dollar.c b/src/expand/expand_dollar.c
index b8a80d2..7a93eee 100644
--- a/src/expand/expand_dollar.c
+++ b/src/expand/expand_dollar.c
@@ -10,20 +10,20 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
 /* ========= helpers existentes (sin cambios de interfaz) ========= */
 
-static char *dup_program_name(t_shell *shell)
+static char	*dup_program_name(t_shell *shell)
 {
 	if (!shell || !shell->program_name)
 		return (ft_strdup("minishell"));
 	return (ft_strdup(shell->program_name));
 }
 
-static char *expand_specials(const char *s, int *i, t_shell *shell)
+static char	*expand_specials(const char *s, int *i, t_shell *shell)
 {
 	if (s[*i] == '?')
 	{
@@ -40,8 +40,8 @@ static char *expand_specials(const char *s, int *i, t_shell *shell)
 		(*i)++;
 		return (dup_program_name(shell));
 	}
-	if (s[*i] == '*' || s[*i] == '@' || s[*i] == '#'
-		|| s[*i] == '-' || s[*i] == '!')
+	if (s[*i] == '*' || s[*i] == '@' || s[*i] == '#' || s[*i] == '-'
+		|| s[*i] == '!')
 	{
 		(*i)++;
 		return (ft_strdup("")); /* vacíos en tu diseño */
@@ -54,7 +54,7 @@ static char *expand_specials(const char *s, int *i, t_shell *shell)
 	return (NULL);
 }
 
-static char *expand_name(const char *s, int *i, t_shell *shell)
+static char	*expand_name(const char *s, int *i, t_shell *shell)
 {
 	int		start;
 	char	*name;
@@ -79,60 +79,78 @@ static char *expand_name(const char *s, int *i, t_shell *shell)
    - Soporta: ${VAR}, ${?}, ${$}, ${0}, ${DIGITOS} (vacío)
    - Si falta '}', devuelve literal "${" consumiendo solo '{'
 */
-static char *expand_braced(const char *s, int *i, t_shell *shell)
+static char	*expand_braced(const char *s, int *i, t_shell *shell)
 {
-	int   j;
-	char *name;
-	char *val;
+	int		j;
+	char	*name;
+	char	*val;
+	int		start;
 
 	if (s[*i] != '{')
 		return (NULL);
-
 	j = *i + 1; /* apunta al primer char tras '{' */
-
 	/* ${} -> vacío (consumimos todo si hay '}') */
 	if (s[j] == '}')
 	{
 		*i = j + 1;
 		return (ft_strdup(""));
 	}
-
 	/* ${?} / ${$} / ${0} / ${<digits>} */
 	if (s[j] == '?')
 	{
 		j++;
-		if (s[j] == '}') { *i = j + 1; return ft_itoa(shell->exit_status); }
-		(*i)++; return ft_strdup("${"); /* degradado literal */
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (ft_itoa(shell->exit_status));
+		}
+		(*i)++;
+		return (ft_strdup("${")); /* degradado literal */
 	}
 	if (s[j] == '$')
 	{
 		j++;
-		if (s[j] == '}') { *i = j + 1; return ft_itoa(getpid()); }
-		(*i)++; return ft_strdup("${");
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (ft_itoa(getpid()));
+		}
+		(*i)++;
+		return (ft_strdup("${"));
 	}
 	if (s[j] == '0')
 	{
 		j++;
-		if (s[j] == '}') { *i = j + 1; return dup_program_name(shell); }
-		(*i)++; return ft_strdup("${");
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (dup_program_name(shell));
+		}
+		(*i)++;
+		return (ft_strdup("${"));
 	}
 	if (ft_isdigit((unsigned char)s[j]))
 	{
-		while (ft_isdigit((unsigned char)s[j])) j++;
-		if (s[j] == '}') { *i = j + 1; return ft_strdup(""); }
-		(*i)++; return ft_strdup("${");
+		while (ft_isdigit((unsigned char)s[j]))
+			j++;
+		if (s[j] == '}')
+		{
+			*i = j + 1;
+			return (ft_strdup(""));
+		}
+		(*i)++;
+		return (ft_strdup("${"));
 	}
-
 	/* ${VAR_NAME} */
 	if (ft_isalpha((unsigned char)s[j]) || s[j] == '_')
 	{
-		int start = j;
+		start = j;
 		while (ft_isalnum((unsigned char)s[j]) || s[j] == '_')
 			j++;
 		if (s[j] != '}')
 		{
 			(*i)++; /* consumimos solo '{' para emitir "${" y dejar continuar */
-			return ft_strdup("${");
+			return (ft_strdup("${"));
 		}
 		name = ft_substr(s, start, j - start);
 		if (!name)
@@ -144,32 +162,28 @@ static char *expand_braced(const char *s, int *i, t_shell *shell)
 			return (ft_strdup(""));
 		return (ft_strdup(val));
 	}
-
 	/* Cualquier otro patrón: tratamos como literal "${" */
 	(*i)++;
 	return (ft_strdup("${"));
 }
 
-
 /* ========= CORREGIDA: respeta $"..." y $'...' (descarta el '$') =========
    Precondición: expand_value se llama con *i en el primer carácter TRAS '$'.
    Casos:
    - $"...": quitamos el '$' y dejamos que el parser trate las comillas.
    - $'...': idem (sin implementar ANSI-C escapes).
 */
-char *expand_value(const char *s, int *i, t_shell *shell)
+char	*expand_value(const char *s, int *i, t_shell *shell)
 {
-	char *br;
-	char *sp;
-	char *nm;
+	char	*br;
+	char	*sp;
+	char	*nm;
 
 	if (!s)
 		return (ft_strdup(""));
-
 	/* Fin de cadena tras '$' -> literal "$" */
 	if (!s[*i])
 		return (ft_strdup("$"));
-
 	/* ${...} antes que el resto */
 	if (s[*i] == '{')
 	{
@@ -178,21 +192,17 @@ char *expand_value(const char *s, int *i, t_shell *shell)
 			return (br);
 		/* si no devolvió, seguimos con flujo normal */
 	}
-
 	/* Especiales: ?, $$, 0, dígitos y otros que ya defines */
 	sp = expand_specials(s, i, shell);
 	if (sp)
 		return (sp);
-
 	/* NUEVO: si lo siguiente es una comilla, descarta el '$' */
 	if (s[*i] == '"' || s[*i] == '\'')
 		return (ft_strdup("")); /* <-- antes devolvía "$" */
-
 	/* Nombre de variable clásico */
 	nm = expand_name(s, i, shell);
 	if (nm)
 		return (nm);
-
 	/* Por defecto: NO consumir el siguiente char → conserva "$" literal */
 	return (ft_strdup("$"));
 }
diff --git a/src/expand/expand_tilde.c b/src/expand/expand_tilde.c
index dea5cf8..5f5f144 100644
--- a/src/expand/expand_tilde.c
+++ b/src/expand/expand_tilde.c
@@ -10,35 +10,36 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
-char *expand_tilde_internal(const char *str, t_shell *shell)
+char	*expand_tilde_internal(const char *str, t_shell *shell)
 {
-    char *home;
-    char *out;
-
-    if (!str || *str != '~')
-        return ft_strdup(str);
+	char	*home;
+	char	*out;
 
-    if (ft_strlen(str) == 1 || str[1] == '/')
-    {
-        home = find_var(shell->env, "HOME");
-        if (!home || *home == '\0')
-            return ft_strdup(str);
-        if (ft_strlen(str) == 1)
-            return ft_strdup(home);
-        out = ft_strjoin(home, str + 1); /* "~" + "/..." */
-        return out;
-    }
-    /* ~user -> no implementado: copia tal cual */
-    return ft_strdup(str);
+	if (!str || *str != '~')
+		return (ft_strdup(str));
+	if (ft_strlen(str) == 1 || str[1] == '/')
+	{
+		home = find_var(shell->env, "HOME");
+		if (!home || *home == '\0')
+			return (ft_strdup(str));
+		if (ft_strlen(str) == 1)
+			return (ft_strdup(home));
+		out = ft_strjoin(home, str + 1); /* "~" + "/..." */
+		return (out);
+	}
+	/* ~user -> no implementado: copia tal cual */
+	return (ft_strdup(str));
 }
 
-size_t get_tilde_prefix_len(const char *str)
+size_t	get_tilde_prefix_len(const char *str)
 {
-    if (!str || *str != '~') return 0;
-    if (ft_strlen(str) == 1 || str[1] == '/') return 1 + (str[1] == '/');
-    return 1;
+	if (!str || *str != '~')
+		return (0);
+	if (ft_strlen(str) == 1 || str[1] == '/')
+		return (1 + (str[1] == '/'));
+	return (1);
 }
diff --git a/src/expand/expand_utils.c b/src/expand/expand_utils.c
index cb58b99..e12864d 100644
--- a/src/expand/expand_utils.c
+++ b/src/expand/expand_utils.c
@@ -10,24 +10,24 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
-char *find_var(t_env *env, char *name)
+char	*find_var(t_env *env, char *name)
 {
-    while (env)
-    {
-        if (ft_strcmp(env->key, name) == 0)
-            return (env->value ? env->value : "");
-        env = env->next;
-    }
-    return "";
+	while (env)
+	{
+		if (ft_strcmp(env->key, name) == 0)
+			return (env->value ? env->value : "");
+		env = env->next;
+	}
+	return ("");
 }
 
-char *get_program_name_str(t_shell *shell)
+char	*get_program_name_str(t_shell *shell)
 {
-    if (!shell->program_name)
-        return ft_strdup("minishell");
-    return ft_strdup(shell->program_name);
+	if (!shell->program_name)
+		return (ft_strdup("minishell"));
+	return (ft_strdup(shell->program_name));
 }
diff --git a/src/expand/handle_expand_cases.c b/src/expand/handle_expand_cases.c
index 0d122a1..25f4677 100644
--- a/src/expand/handle_expand_cases.c
+++ b/src/expand/handle_expand_cases.c
@@ -10,28 +10,32 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "expand.h"
 #include "env.h"
+#include "expand.h"
+#include "minishell.h"
 
-size_t handle_exit_status_len(t_shell *shell)
+size_t	handle_exit_status_len(t_shell *shell)
 {
-    char   *s = ft_itoa(shell->exit_status);
-    size_t  n;
+	char	*s;
+	size_t	n;
 
-    if (!s) return (size_t)-1;
-    n = ft_strlen(s);
-    free(s);
-    return n;
+	s = ft_itoa(shell->exit_status);
+	if (!s)
+		return ((size_t)-1);
+	n = ft_strlen(s);
+	free(s);
+	return (n);
 }
 
-size_t handle_pid_len(void)
+size_t	handle_pid_len(void)
 {
-    char   *s = ft_itoa(getpid());
-    size_t  n;
+	char	*s;
+	size_t	n;
 
-    if (!s) return (size_t)-1;
-    n = ft_strlen(s);
-    free(s);
-    return n;
+	s = ft_itoa(getpid());
+	if (!s)
+		return ((size_t)-1);
+	n = ft_strlen(s);
+	free(s);
+	return (n);
 }
diff --git a/src/expand/quote_removal.c b/src/expand/quote_removal.c
index 711efd6..aec5758 100644
--- a/src/expand/quote_removal.c
+++ b/src/expand/quote_removal.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
 #include "expand.h"
+#include "minishell.h"
 
 static char	*quote_remove_like_bash(const char *s)
 {
@@ -84,8 +84,8 @@ static char	*quote_remove_like_bash(const char *s)
 				i += 2;
 				continue ;
 			}
-			if (s[i + 1] && (s[i + 1] == '$' || s[i + 1] == '`'
-					|| s[i + 1] == '"' || s[i + 1] == '\\'))
+			if (s[i + 1] && (s[i + 1] == '$' || s[i + 1] == '`' || s[i
+					+ 1] == '"' || s[i + 1] == '\\'))
 			{
 				i++;
 				out[j++] = s[i];
diff --git a/src/expand/word_splitting.c b/src/expand/word_splitting.c
index 87a9dc6..7f464ef 100644
--- a/src/expand/word_splitting.c
+++ b/src/expand/word_splitting.c
@@ -10,122 +10,195 @@
 /*                                                                            */
 /* ************************************************************************** */
 
+#include "expand.h" // t_quote
+#include "lexer.h"  // try_add_token, t_token, types
 #include "minishell.h"
-#include "lexer.h"   // try_add_token, t_token, types
-#include "expand.h"  // t_quote
 
 /* IFS por defecto: espacio, tab y newline */
-static int is_ifs_space(unsigned char c)
+static int	is_ifs_space(unsigned char c)
 {
-    return (c == ' ' || c == '\t' || c == '\n');
+	return (c == ' ' || c == '\t' || c == '\n');
 }
 
 /* Divide SOLO palabras (T_WORD) respetando comillas y backslashes */
-static t_token *split_word_respecting_quotes(const char *s)
+static t_token	*split_word_respecting_quotes(const char *s)
 {
-    t_token *head = NULL;
-    size_t   n = ft_strlen(s);
-    char    *buf = malloc(n + 1);
-    size_t   i = 0, j;
-    t_quote  q;
+	t_token	*head;
+	size_t	n;
+	char	*buf;
+	size_t	i;
+	t_quote	q;
+	char	c;
+	char	*field;
 
-    if (!buf)
-        return NULL;
-
-    /* saltar IFS inicial (no escapado) */
-    while (s[i] && is_ifs_space((unsigned char)s[i]))
-        i++;
-
-    while (s[i])
-    {
-        j = 0; q = NO_QUOTE;
-        while (s[i])
-        {
-            char c = s[i];
-            if (q == NO_QUOTE)
-            {
-                if (c == '\\')
-                {
-                    if (s[i+1] == '\n') { i += 2; continue; }
-                    if (s[i+1]) { buf[j++] = '\\'; buf[j++] = s[i+1]; i += 2; continue; }
-                    buf[j++] = '\\'; i++; continue;
-                }
-                if (c == '\'') { q = SINGLE_QUOTE; buf[j++] = c; i++; continue; }
-                if (c == '"')  { q = DOUBLE_QUOTE; buf[j++] = c; i++; continue; }
-                if (is_ifs_space((unsigned char)c)) break;
-                buf[j++] = c; i++; continue;
-            }
-            else if (q == SINGLE_QUOTE)
-            { buf[j++] = c; i++; if (c == '\'') q = NO_QUOTE; continue; }
-            else /* DOUBLE_QUOTE */
-            {
-                if (c == '"') { buf[j++] = c; i++; q = NO_QUOTE; continue; }
-                if (c == '\\')
-                {
-                    if (s[i+1] == '\n') { i += 2; continue; }
-                    if (s[i+1]) { buf[j++] = '\\'; buf[j++] = s[i+1]; i += 2; continue; }
-                }
-                buf[j++] = c; i++; continue;
-            }
-        }
-        if (j > 0)
-        {
-            char *field = malloc(j + 1);
-            if (!field) { free_token_list(head); free(buf); return NULL; }
-            ft_memcpy(field, buf, j); field[j] = '\0';
-            if (!try_add_token(&head, field, T_WORD, NO_QUOTE))
-            { free(field); free_token_list(head); free(buf); return NULL; }
-        }
-        while (s[i] && is_ifs_space((unsigned char)s[i]))
-            i++;
-    }
-    free(buf);
-    return head;
+	head = NULL;
+	n = ft_strlen(s);
+	buf = malloc(n + 1);
+	i = 0, j;
+	if (!buf)
+		return (NULL);
+	/* saltar IFS inicial (no escapado) */
+	while (s[i] && is_ifs_space((unsigned char)s[i]))
+		i++;
+	while (s[i])
+	{
+		j = 0;
+		q = NO_QUOTE;
+		while (s[i])
+		{
+			c = s[i];
+			if (q == NO_QUOTE)
+			{
+				if (c == '\\')
+				{
+					if (s[i + 1] == '\n')
+					{
+						i += 2;
+						continue ;
+					}
+					if (s[i + 1])
+					{
+						buf[j++] = '\\';
+						buf[j++] = s[i + 1];
+						i += 2;
+						continue ;
+					}
+					buf[j++] = '\\';
+					i++;
+					continue ;
+				}
+				if (c == '\'')
+				{
+					q = SINGLE_QUOTE;
+					buf[j++] = c;
+					i++;
+					continue ;
+				}
+				if (c == '"')
+				{
+					q = DOUBLE_QUOTE;
+					buf[j++] = c;
+					i++;
+					continue ;
+				}
+				if (is_ifs_space((unsigned char)c))
+					break ;
+				buf[j++] = c;
+				i++;
+				continue ;
+			}
+			else if (q == SINGLE_QUOTE)
+			{
+				buf[j++] = c;
+				i++;
+				if (c == '\'')
+					q = NO_QUOTE;
+				continue ;
+			}
+			else /* DOUBLE_QUOTE */
+			{
+				if (c == '"')
+				{
+					buf[j++] = c;
+					i++;
+					q = NO_QUOTE;
+					continue ;
+				}
+				if (c == '\\')
+				{
+					if (s[i + 1] == '\n')
+					{
+						i += 2;
+						continue ;
+					}
+					if (s[i + 1])
+					{
+						buf[j++] = '\\';
+						buf[j++] = s[i + 1];
+						i += 2;
+						continue ;
+					}
+				}
+				buf[j++] = c;
+				i++;
+				continue ;
+			}
+		}
+		if (j > 0)
+		{
+			field = malloc(j + 1);
+			if (!field)
+			{
+				free_token_list(head);
+				free(buf);
+				return (NULL);
+			}
+			ft_memcpy(field, buf, j);
+			field[j] = '\0';
+			if (!try_add_token(&head, field, T_WORD, NO_QUOTE))
+			{
+				free(field);
+				free_token_list(head);
+				free(buf);
+				return (NULL);
+			}
+		}
+		while (s[i] && is_ifs_space((unsigned char)s[i]))
+			i++;
+	}
+	free(buf);
+	return (head);
 }
 
-void    perform_word_splitting(t_shell *shell)
+void	perform_word_splitting(t_shell *shell)
 {
-    t_token *current = shell->tokens;
-    t_token *prev = NULL;
-
-    while (current)
-    {
-        t_token *next_original = current->next;
-
-        /* IMPORTANTÍSIMO:
-           - SOLO dividimos si es una PALABRA (T_WORD)
-           - y si no venía completamente entrecomillada */
-        if (current->type == T_WORD && current->quoted == NO_QUOTE)
-        {
-            t_token *split = split_word_respecting_quotes(current->value);
-            if (split == NULL)
-            {
-                /* Expansión → vacío sin comillas: elimina el token */
-                if (prev) prev->next = next_original;
-                else shell->tokens = next_original;
-                free(current->value);
-                free(current);
-                current = next_original;
-                continue;
-            }
-            /* Inserta lista nueva en lugar del token original */
-            if (prev) prev->next = split;
-            else shell->tokens = split;
-
-            t_token *last = split;
-            while (last->next) last = last->next;
-            last->next = next_original;
-
-            free(current->value);
-            free(current);
+	t_token	*current;
+	t_token	*prev;
+	t_token	*next_original;
+	t_token	*split;
+	t_token	*last;
 
-            prev = last;
-            current = next_original;
-        }
-        else
-        {
-            prev = current;
-            current = next_original;
-        }
-    }
+	current = shell->tokens;
+	prev = NULL;
+	while (current)
+	{
+		next_original = current->next;
+		/* IMPORTANTÍSIMO:
+			- SOLO dividimos si es una PALABRA (T_WORD)
+			- y si no venía completamente entrecomillada */
+		if (current->type == T_WORD && current->quoted == NO_QUOTE)
+		{
+			split = split_word_respecting_quotes(current->value);
+			if (split == NULL)
+			{
+				/* Expansión → vacío sin comillas: elimina el token */
+				if (prev)
+					prev->next = next_original;
+				else
+					shell->tokens = next_original;
+				free(current->value);
+				free(current);
+				current = next_original;
+				continue ;
+			}
+			/* Inserta lista nueva en lugar del token original */
+			if (prev)
+				prev->next = split;
+			else
+				shell->tokens = split;
+			last = split;
+			while (last->next)
+				last = last->next;
+			last->next = next_original;
+			free(current->value);
+			free(current);
+			prev = last;
+			current = next_original;
+		}
+		else
+		{
+			prev = current;
+			current = next_original;
+		}
+	}
 }
diff --git a/src/lexer/lexer.c b/src/lexer/lexer.c
index 8d5da21..842817d 100644
--- a/src/lexer/lexer.c
+++ b/src/lexer/lexer.c
@@ -6,116 +6,92 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/11 16:07:05 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:40:49 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 15:45:16 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
 
-/*
-** Reglas principales que seguimos (resumen):
-** - Comentarios: un '#' que comienza una palabra (inicio de línea, tras espacio
-**   no comillado o tras un operador) e *imprimible* y *no comillado* inicia un
-**   comentario hasta fin de línea. (Bash: en modo interactivo depende de
-**   shopt interactive_comments; aquí lo activamos siempre en no-interactivo).
-**   Ref: Bash manual, "Comments". :contentReference[oaicite:0]{index=0}
-**
-** - Comillas:
-**   * '...': literal, sin escapes, hasta la próxima ' (no se puede anidar). :contentReference[oaicite:1]{index=1}
-**   * "...": backslash sólo escapa: $, `, ", \ y newline para continuación de
-**            línea. (El resto de backslashes se preservan). :contentReference[oaicite:2]{index=2}
-**   * fuera de comillas: '\' escapa el siguiente carácter; '\<newline>'
-**     elimina ambos (continuación de línea POSIX). :contentReference[oaicite:3]{index=3}
-**
-** - Operadores reconocidos: ||, &&, |, ;, &, <, >, >>, <<, <<<, >|, <&, >&,
-**   2>, 2>>, &>, &>>, paréntesis y llaves. (Algunos son Bash-specific, p.ej. &>, <<<). :contentReference[oaicite:4]{index=4}
-**
-** Nota: la *expansión* ($VAR, ~, etc.) no es parte del lexer; aquí sólo
-** tokenizamos y marcamos si el token estaba comillado.
-*/
-
-static t_token *free_null_token_list(t_token **lst)
+/* helper: clona la línea y aplica el strip de comentarios bash */
+static char	*clone_and_strip(const char *raw)
 {
-    free_token_list(*lst);
-    *lst = NULL;
-    return (NULL);
-}
+	char	*dup;
 
-/* Detecta prefijos de fd redundantes: "1>", "0<", "2>&1"...;
- * aquí solo los saltamos para simplificar equivalencias de bash.
- * (No altera el AST, sólo evita tokens numéricos sueltos). */
-static int  skip_default_fd_prefix(const char *s)
-{
-    if (s[0] == '1' && (s[1] == '>' || (s[1] == '<' && s[2] == '<')))
-        return 1; /* 1>, 1<< */
-    if (s[0] == '0' && (s[1] == '<' || (s[1] == '<' && s[2] == '<')))
-        return 1; /* 0<, 0<< */
-    if (s[0] == '2' && s[1] == '>' && s[2] == '&' && s[3] == '1')
-        return 1; /* 2>&1 */
-    return 0;
+	dup = ft_strdup(raw);
+	if (!dup)
+		return (NULL);
+	strip_comment_if_applicable(dup);
+	return (dup);
 }
 
-/* Sufijos fd redundantes tras un operador (>1, >>1, <&0, >&1...) */
-static int  skip_default_fd_suffix(const char *s)
+/* helper: salta espacios (fuera de comillas) */
+static int	skip_spaces(const char *s, int i)
 {
-    if (s[0] == '>' && s[1] == '1' && s[2] != '>')
-        return 1; /* >1 */
-    if (s[0] == '>' && s[1] == '>' && s[2] == '1')
-        return 1; /* >>1 */
-    if (s[0] == '<' && s[1] == '&' && s[2] == '0')
-        return 1; /* <&0 */
-    if (s[0] == '>' && s[1] == '&' && s[2] == '1')
-        return 1; /* >&1 */
-    if (s[0] == '<' && s[1] == '<' && s[2] == '<' && s[3] == '1')
-        return 1; /* <<<1 */
-    return 0;
+	while (s[i] && ft_isspace(s[i]))
+		i++;
+	return (i);
 }
 
-t_token *lexer(const char *raw_line)
+/* helper: lexea un token (operador o palabra) y avanza next_i */
+static int	lex_one(const char *line, int i, t_token **lst, int *next_i)
 {
-    t_token *lst = NULL;
-    int     i = 0, next_i = 0;
-
-    if (!raw_line)
-        return NULL;
-
-    /* Hacemos una copia mutable para poder cortar comentarios de forma segura */
-    char *line = ft_strdup(raw_line);
-    if (!line)
-        return NULL;
+	int	ni;
 
-    /* Comentarios estilo bash: si # comienza palabra descomillada -> corta línea. */
-    strip_comment_if_applicable(line); /* :contentReference[oaicite:5]{index=5} */
+	if (is_operator(line + i, NULL, NULL))
+	{
+		ni = get_operator(line, i, &*lst);
+		if (ni < 0)
+			return (-1);
+		*next_i = ni;
+		return (0);
+	}
+	ni = get_word(line, i, &*lst);
+	if (ni < 0)
+		return (-1);
+	*next_i = ni;
+	return (0);
+}
 
-    while (line[i])
-    {
-        /* Saltar espacios fuera de comillas */
-        while (line[i] && ft_isspace(line[i]))
-            i++;
-        if (!line[i])
-            break;
+/* paso de bucle: salta espacios, lexea 1 token, avanza índice
+ * return:  0 = seguir;  1 = fin;  -1 = error */
+static int	lexer_step(char *line, int *i, t_token **lst)
+{
+	int	next_i;
 
-        /* Normaliza casos 1>, 0<, 2>&1 (los fd explícitos por defecto) */
-        i += skip_default_fd_prefix(line + i);
+	*i = skip_spaces(line, *i);
+	if (!line[*i])
+		return (1);
+	if (lex_one(line, *i, lst, &next_i) < 0)
+		return (-1);
+	*i = next_i;
+	return (0);
+}
 
-        if (is_operator(line + i, NULL, NULL))
-        {
-            next_i = get_operator(line, i, &lst);
-            if (next_i < 0)
-                return free_null_token_list(&lst);
-            /* Saltar sufijos redundantes tras el operador */
-            next_i += skip_default_fd_suffix(line + next_i);
-        }
-        else
-        {
-            next_i = get_word(line, i, &lst);
-            if (next_i < 0)
-                return free_null_token_list(&lst);
-        }
-        i = next_i;
-    }
+t_token	*lexer(const char *raw_line)
+{
+	t_token	*lst;
+	char	*line;
+	int		i;
+	int		st;
 
-    free(line);
-    return lst;
+	lst = NULL;
+	if (!raw_line)
+		return (NULL);
+	line = clone_and_strip(raw_line);
+	if (!line)
+		return (NULL);
+	i = 0;
+	while (line[i])
+	{
+		st = lexer_step(line, &i, &lst);
+		if (st < 0)
+		{
+			free(line);
+			return (free_null_token_list(&lst));
+		}
+		if (st > 0)
+			break ;
+	}
+	free(line);
+	return (lst);
 }
diff --git a/src/lexer/lexer_get_opertator.c b/src/lexer/lexer_get_opertator.c
index b5c1361..0c96917 100644
--- a/src/lexer/lexer_get_opertator.c
+++ b/src/lexer/lexer_get_opertator.c
@@ -6,28 +6,27 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/26 14:55:24 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:41:35 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 15:26:45 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
 
-int     get_operator(const char *line, int i, t_token **lst)
+int	get_operator(const char *line, int i, t_token **lst)
 {
-        t_token_type    type;
-        int             len;
-        char            *op_str;
+	t_token_type	type;
+	int				len;
+	char			*op_str;
 
-        if (!is_operator(line + i, &type, &len))
-                return (i);
-        op_str = ft_substr(line, i, len);
-        if (!op_str)
-        {
-                free_lexer_list_on_error(lst);
-                return (-1);
-        }
-        if (!try_add_token(lst, op_str, type, NO_QUOTE))
-                return (-1);
-        return (i + len);
+	if (!is_operator(line + i, &type, &len))
+		return (i);
+	op_str = ft_substr(line, i, len);
+	if (!op_str)
+	{
+		free_lexer_list_on_error(lst);
+		return (-1);
+	}
+	if (!try_add_token(lst, op_str, type, NO_QUOTE))
+		return (-1);
+	return (i + len);
 }
diff --git a/src/lexer/lexer_get_word.c b/src/lexer/lexer_get_word.c
index 5bcb22d..1b9358f 100644
--- a/src/lexer/lexer_get_word.c
+++ b/src/lexer/lexer_get_word.c
@@ -6,12 +6,11 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/26 14:25:33 by acoronad          #+#    #+#             */
-/*   Updated: 2025/11/01 15:08:40 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 15:25:53 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
 
 static int	word_end(const char *s, int i)
 {
@@ -50,7 +49,7 @@ static int	word_end(const char *s, int i)
 			if (ft_isspace(s[i]))
 				break ;
 			if (is_operator(s + i, NULL, NULL) && s[i] != '=')
-				break;
+				break ;
 			i++;
 			continue ;
 		}
@@ -61,9 +60,8 @@ static int	word_end(const char *s, int i)
 			i++;
 			continue ;
 		}
-		if (s[i] == '\\' && (s[i + 1] == '$' || s[i + 1] == '`'
-				|| s[i + 1] == '"' || s[i + 1] == '\\'
-				|| s[i + 1] == '\n'))
+		if (s[i] == '\\' && (s[i + 1] == '$' || s[i + 1] == '`' || s[i
+				+ 1] == '"' || s[i + 1] == '\\' || s[i + 1] == '\n'))
 		{
 			if (s[i + 1])
 				i += 2;
@@ -92,7 +90,7 @@ int	get_word(const char *line, int i, t_token **lst)
 	qtype = NO_QUOTE;
 	if (end < 0)
 	{
-		fprintf(stderr, "minishell: syntax error: unclosed quote\n");
+		ft_dprintf(2, "minishell: syntax error: unclosed quote\n");
 		free_lexer_list_on_error(lst);
 		return (-1);
 	}
diff --git a/src/lexer/lexer_strip_comments.c b/src/lexer/lexer_strip_comments.c
index 5f2d754..24c61e9 100644
--- a/src/lexer/lexer_strip_comments.c
+++ b/src/lexer/lexer_strip_comments.c
@@ -11,104 +11,124 @@
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
 
-/*
-** Bash: un comentario inicia si un '#' **comienza una palabra** no comillada:
-** - inicio de línea
-** - tras espacio no comillado
-** - tras un operador
-** Desde ahí hasta fin de línea se ignora. :contentReference[oaicite:6]{index=6}
-**
-** Aquí lo aplicamos siempre (en modo no interactivo de minishell).
-*/
-void    strip_comment_if_applicable(char *line)
+void	strip_comment_if_applicable(char *line)
 {
-    int i = 0;
-    t_quote q = NO_QUOTE;
-    int at_word_start = 1; /* al principio de la línea estamos al inicio de palabra */
+	int		i;
+	t_quote	q;
+	char	c;
+	int		j;
+				t_token_type t;
+				int len;
+	int		j;
 
-    if (!line)
-        return ;
-
-    while (line[i])
-    {
-        char c = line[i];
-
-        /* Gestión de escapes fuera/dentro de comillas según bash */
-        if (q == NO_QUOTE)
-        {
-            if (c == '\\')
-            {
-                if (line[i + 1] == '\n')
-                {
-                    /* continuación de línea: elimina ambos */
-                    /* desplazamos resto hacia atrás */
-                    int j = i; 
-                    while (line[j + 2]) { line[j] = line[j + 2]; j++; }
-                    line[j] = '\0';
-                    continue;
-                }
-                /* salta el próximo carácter como literal */
-                if (line[i + 1]) i += 2; else i++;
-                at_word_start = 0;
-                continue;
-            }
-            if (c == '\'') { q = SINGLE_QUOTE; i++; at_word_start = 0; continue; }
-            if (c == '"')  { q = DOUBLE_QUOTE; i++; at_word_start = 0; continue; }
-
-            /* Si # comienza palabra y estamos fuera de comillas -> cortar */
-            if (c == '#' && at_word_start)
-            {
-                line[i] = '\0';
-                return ;
-            }
-
-            /* espacios reinician inicio-de-palabra */
-            if (ft_isspace(c))
-                at_word_start = 1;
-            else
-            {
-                /* si el carácter actual inicia un operador, el siguiente es inicio-de-palabra */
-                t_token_type t; int len;
-                if (is_operator(line + i, &t, &len))
-                {
-                    i += len;
-                    at_word_start = 1;
-                    continue;
-                }
-                at_word_start = 0;
-            }
-            i++;
-        }
-        else if (q == SINGLE_QUOTE)
-        {
-            /* dentro de comillas simples: todo literal hasta la siguiente ' */
-            if (c == '\'') q = NO_QUOTE;
-            i++;
-            at_word_start = 0;
-        }
-        else /* DOUBLE_QUOTE */
-        {
-            /* Dentro de dobles comillas, \ sólo escapa $, `, ", \ y newline. :contentReference[oaicite:7]{index=7} */
-            if (c == '\\' && (line[i + 1] == '$' || line[i + 1] == '`'
-                || line[i + 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '\n'))
-            {
-                if (line[i + 1] == '\n')
-                {
-                    /* quita la continuación de línea */
-                    int j = i;
-                    while (line[j + 2]) { line[j] = line[j + 2]; j++; }
-                    line[j] = '\0';
-                    continue;
-                }
-                i += (line[i + 1] ? 2 : 1);
-                at_word_start = 0;
-                continue;
-            }
-            if (c == '"') q = NO_QUOTE;
-            i++;
-            at_word_start = 0;
-        }
-    }
+	i = 0;
+	q = NO_QUOTE;
+	int at_word_start = 1;
+		/* al principio de la línea estamos al inicio de palabra */
+	if (!line)
+		return ;
+	while (line[i])
+	{
+		c = line[i];
+		/* Gestión de escapes fuera/dentro de comillas según bash */
+		if (q == NO_QUOTE)
+		{
+			if (c == '\\')
+			{
+				if (line[i + 1] == '\n')
+				{
+					/* continuación de línea: elimina ambos */
+					/* desplazamos resto hacia atrás */
+					j = i;
+					while (line[j + 2])
+					{
+						line[j] = line[j + 2];
+						j++;
+					}
+					line[j] = '\0';
+					continue ;
+				}
+				/* salta el próximo carácter como literal */
+				if (line[i + 1])
+					i += 2;
+				else
+					i++;
+				at_word_start = 0;
+				continue ;
+			}
+			if (c == '\'')
+			{
+				q = SINGLE_QUOTE;
+				i++;
+				at_word_start = 0;
+				continue ;
+			}
+			if (c == '"')
+			{
+				q = DOUBLE_QUOTE;
+				i++;
+				at_word_start = 0;
+				continue ;
+			}
+			/* Si # comienza palabra y estamos fuera de comillas -> cortar */
+			if (c == '#' && at_word_start)
+			{
+				line[i] = '\0';
+				return ;
+			}
+			/* espacios reinician inicio-de-palabra */
+			if (ft_isspace(c))
+				at_word_start = 1;
+			else
+			{
+				/* si el carácter actual inicia un operador,
+					el siguiente es inicio-de-palabra */
+				if (is_operator(line + i, &t, &len))
+				{
+					i += len;
+					at_word_start = 1;
+					continue ;
+				}
+				at_word_start = 0;
+			}
+			i++;
+		}
+		else if (q == SINGLE_QUOTE)
+		{
+			/* dentro de comillas simples: todo literal hasta la siguiente ' */
+			if (c == '\'')
+				q = NO_QUOTE;
+			i++;
+			at_word_start = 0;
+		}
+		else /* DOUBLE_QUOTE */
+		{
+			/* Dentro de dobles comillas, \ sólo escapa $, `, ",
+				\ y newline. :contentReference[oaicite:7]{index=7} */
+			if (c == '\\' && (line[i + 1] == '$' || line[i + 1] == '`' || line[i
+					+ 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '\n'))
+			{
+				if (line[i + 1] == '\n')
+				{
+					/* quita la continuación de línea */
+					j = i;
+					while (line[j + 2])
+					{
+						line[j] = line[j + 2];
+						j++;
+					}
+					line[j] = '\0';
+					continue ;
+				}
+				i += (line[i + 1] ? 2 : 1);
+				at_word_start = 0;
+				continue ;
+			}
+			if (c == '"')
+				q = NO_QUOTE;
+			i++;
+			at_word_start = 0;
+		}
+	}
 }
diff --git a/src/lexer/lexer_types.c b/src/lexer/lexer_types.c
index 480aceb..0351ee5 100644
--- a/src/lexer/lexer_types.c
+++ b/src/lexer/lexer_types.c
@@ -6,70 +6,62 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/11 16:42:46 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/24 14:42:23 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 15:20:15 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
 
-t_token_type    get_pipe_and_or(const char *str, int len)
+t_token_type	get_pipe_and_or(const char *str, int len)
 {
-    if (len == 2 && str[0] == '|' && str[1] == '|') return (T_OR);
-    if (len == 2 && str[0] == '&' && str[1] == '&') return (T_AND);
-    if (len == 1 && str[0] == '|') return (T_PIPE);
-    if (len == 1 && str[0] == '&') return (T_BG);
-    if (len == 1 && str[0] == ';') return (T_SEMI);
-    if (len == 1 && str[0] == '(') return (T_LPAREN);
-    if (len == 1 && str[0] == ')') return (T_RPAREN);
-    if (len == 1 && str[0] == '{') return (T_LBRACE);
-    if (len == 1 && str[0] == '}') return (T_RBRACE);
-    return (T_UNKNOWN);
+	if (len == 2 && str[0] == '|' && str[1] == '|')
+		return (T_OR);
+	if (len == 2 && str[0] == '&' && str[1] == '&')
+		return (T_AND);
+	if (len == 1 && str[0] == '|')
+		return (T_PIPE);
+	if (len == 1 && str[0] == '&')
+		return (T_BG);
+	if (len == 1 && str[0] == ';')
+		return (T_SEMI);
+	if (len == 1 && str[0] == '(')
+		return (T_LPAREN);
+	if (len == 1 && str[0] == ')')
+		return (T_RPAREN);
+	return (T_UNKNOWN);
 }
 
-t_token_type    get_semi_redir_left(const char *str, int len)
+t_token_type	get_semi_redir_left(const char *str, int len)
 {
-    if (len == 1 && str[0] == '<') return (T_REDIR_IN);
-    if (len == 2 && str[0] == '<' && str[1] == '<') return (T_HEREDOC);
-    if (len == 3 && str[0] == '<' && str[1] == '<' && str[2] == '<') return (T_HEREDOC_STR);
-    if (len == 2 && str[0] == '<' && str[1] == '&') return (T_DUP_IN);
-    if (len == 1 && str[0] == '=') return (T_EQUAL);
-    return (T_UNKNOWN);
+	if (len == 1 && str[0] == '<')
+		return (T_REDIR_IN);
+	if (len == 2 && str[0] == '<' && str[1] == '<')
+		return (T_HEREDOC);
+	if (len == 3 && str[0] == '<' && str[1] == '<' && str[2] == '<')
+		return (T_HEREDOC_STR);
+	if (len == 2 && str[0] == '<' && str[1] == '&')
+		return (T_DUP_IN);
+	return (T_UNKNOWN);
 }
 
-t_token_type    get_redir_right(const char *str, int len)
+t_token_type	get_redir_right(const char *str, int len)
 {
-    if (len == 2 && str[0] == '>' && str[1] == '>') return (T_APPEND);
-    if (len == 2 && str[0] == '>' && str[1] == '|') return (T_FORCE_OUT);
-    if (len == 2 && str[0] == '>' && str[1] == '&') return (T_DUP_OUT);
-    if (len == 1 && str[0] == '>') return (T_REDIR_OUT);
-    return (T_UNKNOWN);
+	if (len == 2 && str[0] == '>' && str[1] == '>')
+		return (T_APPEND);
+	if (len == 2 && str[0] == '>' && str[1] == '|')
+		return (T_FORCE_OUT);
+	if (len == 2 && str[0] == '>' && str[1] == '&')
+		return (T_DUP_OUT);
+	if (len == 1 && str[0] == '>')
+		return (T_REDIR_OUT);
+	return (T_UNKNOWN);
 }
 
-t_token_type    get_redir_special(const char *str, int len)
+t_token_type	get_redir_special(const char *str, int len)
 {
-    if (len == 3 && str[0] == '&' && str[1] == '>' && str[2] == '>') return (T_APPEND_ALL);
-    if (len == 2 && str[0] == '&' && str[1] == '>') return (T_REDIR_ALL);
-    if (len == 3 && str[0] == '2' && str[1] == '>' && str[2] == '>') return (T_APPEND_ERR);
-    if (len == 2 && str[0] == '2' && str[1] == '>') return (T_REDIR_ERR);
-    return (T_UNKNOWN);
-}
-
-t_token_type    get_token_type(const char *str, int len)
-{
-    t_token_type type;
-
-    type = get_redir_special(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    type = get_redir_right(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    type = get_semi_redir_left(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    type = get_pipe_and_or(str, len);
-    if (type != T_UNKNOWN) return type;
-
-    return T_WORD;
+	if (len == 3 && str[0] == '&' && str[1] == '>' && str[2] == '>')
+		return (T_APPEND_ALL);
+	if (len == 2 && str[0] == '&' && str[1] == '>')
+		return (T_REDIR_ALL);
+	return (T_UNKNOWN);
 }
diff --git a/src/lexer/lexer_utils.c b/src/lexer/lexer_utils.c
index d1f1c4c..81fe769 100644
--- a/src/lexer/lexer_utils.c
+++ b/src/lexer/lexer_utils.c
@@ -5,189 +5,70 @@
 /*                                                    +:+ +:+         +:+     */
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/06/11 16:36:48 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/31 22:12:03 by acoronad         ###   ########.fr       */
+/*   Created: 2025/11/05 15:41:21 by acoronad          #+#    #+#             */
+/*   Updated: 2025/11/05 15:55:24 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
 
-t_token	*token_new(char *value, t_token_type type, t_quote quote)
+/* pone type/len si no son NULL */
+static void	op_set(t_token_type *type, int *len, t_token_type t, int l)
 {
-	t_token	*tok;
-
-	tok = (t_token *)malloc(sizeof(t_token));
-	if (!tok)
-		return (NULL);
-	tok->value = value;
-	tok->type = type;
-	tok->quoted = quote;
-	tok->next = NULL;
-	return (tok);
-}
-
-void	token_addback(t_token **lst, t_token *new)
-{
-	t_token	*tmp;
-
-	if (!lst || !new)
-		return ;
-	if (!*lst)
-	{
-		*lst = new;
-		return ;
-	}
-	tmp = *lst;
-	while (tmp->next)
-		tmp = tmp->next;
-	tmp->next = new;
-}
-
-void	free_token_list(t_token *tok)
-{
-	t_token	*next;
-
-	while (tok)
-	{
-		next = tok->next;
-		free(tok->value);
-		free(tok);
-		tok = next;
-	}
+	if (type) *type = t;
+	if (len)  *len  = l;
 }
 
-void	next_token(t_token **cur)
+/* operadores de 3 caracteres */
+static int	op_match_len3(const char *s, t_token_type *type, int *len)
 {
-	if (cur && *cur)
-		*cur = (*cur)->next;
+	if (!s) return (0);
+	if (ft_strncmp(s, "<<<", 3) == 0)
+		return (op_set(type, len, T_HEREDOC_STR, 3), 1);
+	if (ft_strncmp(s, "&>>", 3) == 0)
+		return (op_set(type, len, T_APPEND_ALL, 3), 1);
+	return (0);
 }
 
-int	is_operator(const char *str, t_token_type *type, int *len)
+/* operadores de 2 caracteres */
+static int	op_match_len2(const char *s, t_token_type *type, int *len)
 {
-	static const char		*ops[] = {
-		"<<<", ">>", "<<", "||", "&&", "&>>", "&>", ">|", "<&", ">&",
-		"2>>", "2>", "|", "&", ";", "<", ">", "(", ")", "{", "}", "="
-	};
-	static const int		lens[] = {
-		3, 2, 2, 2, 2, 3, 2, 2, 2, 2,
-		3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
-	};
-	static const t_token_type types[] = {
-		T_HEREDOC_STR, T_APPEND, T_HEREDOC, T_OR, T_AND, T_APPEND_ALL,
-		T_REDIR_ALL, T_FORCE_OUT, T_DUP_IN, T_DUP_OUT, T_APPEND_ERR,
-		T_REDIR_ERR, T_PIPE, T_BG, T_SEMI, T_REDIR_IN, T_REDIR_OUT,
-		T_LPAREN, T_RPAREN, T_LBRACE, T_RBRACE, T_EQUAL
-	};
-	int						i;
-
-	i = 0;
-	while (i < (int)(sizeof(lens) / sizeof(lens[0]))
-		&& i < (int)(sizeof(types) / sizeof(types[0])))
-	{
-		if (ft_strncmp(str, ops[i], lens[i]) == 0)
-		{
-			if (type)
-				*type = types[i];
-			if (len)
-				*len = lens[i];
-			return (1);
-		}
-		i++;
-	}
+	if (!s) return (0);
+	if (ft_strncmp(s, ">>", 2) == 0)  return (op_set(type, len, T_APPEND, 2), 1);
+	if (ft_strncmp(s, "<<", 2) == 0)  return (op_set(type, len, T_HEREDOC, 2), 1);
+	if (ft_strncmp(s, "||", 2) == 0)  return (op_set(type, len, T_OR, 2), 1);
+	if (ft_strncmp(s, "&&", 2) == 0)  return (op_set(type, len, T_AND, 2), 1);
+	if (ft_strncmp(s, "&>", 2) == 0)  return (op_set(type, len, T_REDIR_ALL, 2), 1);
+	if (ft_strncmp(s, ">|", 2) == 0)  return (op_set(type, len, T_FORCE_OUT, 2), 1);
+	if (ft_strncmp(s, "<&", 2) == 0)  return (op_set(type, len, T_DUP_IN, 2), 1);
+	if (ft_strncmp(s, ">&", 2) == 0)  return (op_set(type, len, T_DUP_OUT, 2), 1);
 	return (0);
 }
 
-void	free_lexer_list_on_error(t_token **lst)
+/* operadores de 1 caracter */
+static int	op_match_len1(const char *s, t_token_type *type, int *len)
 {
-	if (lst && *lst)
-	{
-		free_token_list(*lst);
-		*lst = NULL;
-	}
+	if (!s) return (0);
+	if (*s == '|') return (op_set(type, len, T_PIPE, 1), 1);
+	if (*s == '&') return (op_set(type, len, T_BG, 1), 1);
+	if (*s == ';') return (op_set(type, len, T_SEMI, 1), 1);
+	if (*s == '<') return (op_set(type, len, T_REDIR_IN, 1), 1);
+	if (*s == '>') return (op_set(type, len, T_REDIR_OUT, 1), 1);
+	if (*s == '(') return (op_set(type, len, T_LPAREN, 1), 1);
+	if (*s == ')') return (op_set(type, len, T_RPAREN, 1), 1);
+	return (0);
 }
 
-int	try_add_token(t_token **lst, char *str, t_token_type type, t_quote quote)
+/* principal (≤25 líneas, sin globals) */
+int	is_operator(const char *str, t_token_type *type, int *len)
 {
-	t_token	*tok;
-
-	tok = token_new(str, type, quote);
-	if (!tok)
-	{
-		ft_strdel(&str);
+	if (!str)
 		return (0);
-	}
-	token_addback(lst, tok);
-	return (1);
-}
-
-static void	copy_escaped_pair(const char *src, size_t *i, char *out, size_t *j)
-{
-	(*i)++;
-	out[*j] = src[*i];
-	(*j)++;
-	(*i)++;
-}
-
-char	*remove_backslashes_for_token(const char *src, t_quote quote)
-{
-	char	*out;
-	size_t	i;
-	size_t	j;
-	size_t	n;
-
-	if (!src)
-		return (NULL);
-	n = ft_strlen(src);
-	out = (char *)malloc(n + 1);
-	if (!out)
-		return (NULL);
-	i = 0;
-	j = 0;
-	if (quote == SINGLE_QUOTE)
-	{
-		while (i < n)
-		{
-			out[j] = src[i];
-			j++;
-			i++;
-		}
-		out[j] = '\0';
-		return (out);
-	}
-	if (quote == DOUBLE_QUOTE)
-	{
-		while (i < n)
-		{
-			if (src[i] == '\\' && (i + 1) < n && (src[i + 1] == '$'
-					|| src[i + 1] == '`' || src[i + 1] == '"'
-					|| src[i + 1] == '\\'))
-				copy_escaped_pair(src, &i, out, &j);
-			else if (src[i] == '\\' && (i + 1) < n && src[i + 1] == '\n')
-				i += 2;
-			else
-			{
-				out[j] = src[i];
-				j++;
-				i++;
-			}
-		}
-		out[j] = '\0';
-		return (out);
-	}
-	while (i < n)
-	{
-		if (src[i] == '\\' && (i + 1) < n && src[i + 1] == '\n')
-			i += 2;
-		else if (src[i] == '\\' && (i + 1) < n)
-			copy_escaped_pair(src, &i, out, &j);
-		else
-		{
-			out[j] = src[i];
-			j++;
-			i++;
-		}
-	}
-	out[j] = '\0';
-	return (out);
+	if (op_match_len3(str, type, len))
+		return (1);
+	if (op_match_len2(str, type, len))
+		return (1);
+	if (op_match_len1(str, type, len))
+		return (1);
+	return (0);
 }
diff --git a/src/parser/heredoc_read.c b/src/parser/heredoc_read.c
index ad232d0..d712248 100644
--- a/src/parser/heredoc_read.c
+++ b/src/parser/heredoc_read.c
@@ -15,34 +15,68 @@
 ** o -1 en error/interrupción.
 */
 
-int heredoc_read(char *delimiter)
+int	heredoc_read(char *delimiter)
 {
-    int   pipefd[2];
-    char *line;
+	int		pipefd[2];
+	char	*line;
 
-    if (!delimiter)
-        return (-1);
-    if (pipe(pipefd) < 0)
-    {
-        perror("minishell: pipe");
-        return (-1);
-    }
-    signal(SIGQUIT, SIG_DFL);
-    signal(SIGINT, SIG_DFL);
-    while (1)
-    {
-        line = readline("> ");
-        if (!line)
-            break ;
-        if (ft_strcmp(line, delimiter) == 0)
-        {
-            free(line);
-            break ;
-        }
-        write(pipefd[1], line, ft_strlen(line));
-        write(pipefd[1], "\n", 1);
-        free(line);
-    }
-    close(pipefd[1]);
-    return (pipefd[0]);
+	if (!delimiter)
+		return (-1);
+	if (pipe(pipefd) < 0)
+	{
+		perror("minishell: pipe");
+		return (-1);
+	}
+	signal(SIGQUIT, SIG_DFL);
+	signal(SIGINT, SIG_DFL);
+	while (1)
+	{
+		line = readline("> ");
+		if (!line)
+			break ;
+		if (ft_strcmp(line, delimiter) == 0)
+		{
+			free(line);
+			break ;
+		}
+		write(pipefd[1], line, ft_strlen(line));
+		write(pipefd[1], "\n", 1);
+		free(line);
+	}
+	close(pipefd[1]);
+	return (pipefd[0]);
 }
+
+/*
+//heredoc_read.c
+int	read_heredoc_body(int script_fd, const char *delim, int quoted, int *out_fd)
+{
+	char	*line;
+	size_t	n;
+
+	int   tmp = mkstemp(tmpname); // o pipe()
+	if (tmp < 0) return (-1);
+	while (1)
+	{
+		line = get_next_line(script_fd); // en
+			-s y no-interactivo: del mismo flujo
+		if (!line) return (close(tmp), -1); // EOF inesperado: error sintaxis
+		// quitar '\n' final si hay
+		n = ft_strlen(line);
+		if (n && line[n-1]=='\n') line[n-1]='\0';
+		// fin del heredoc si coincide EXACTO con delim
+		if (!ft_strcmp(line, delim))
+		{
+			free(line);
+			break ;
+		}
+		// escribir (posible expansión si !quoted)
+		write(tmp, line, ft_strlen(line));
+		write(tmp, "\n", 1);
+		free(line);
+	}
+	lseek(tmp, 0, SEEK_SET);
+	*out_fd = tmp;
+	return (0);
+}
+*/
\ No newline at end of file
diff --git a/src/parser/parse_and_or.c b/src/parser/parse_and_or.c
index 454733b..b845f76 100644
--- a/src/parser/parse_and_or.c
+++ b/src/parser/parse_and_or.c
@@ -10,9 +10,9 @@
 /*                                                                            */
 /* ************************************************************************** */
 
+#include "ast.h"
 #include "minishell.h"
 #include "parser.h"
-#include "ast.h"
 
 t_ast	*parse_and_or(t_token **cur)
 {
@@ -24,18 +24,17 @@ t_ast	*parse_and_or(t_token **cur)
 	left = parse_pipeline(cur);
 	if (!left)
 		return (NULL);
-
 	while (*cur && ((*cur)->type == T_AND || (*cur)->type == T_OR))
 	{
 		if ((*cur)->type == T_AND)
 			node_type = N_AND;
 		else
 			node_type = N_OR;
-
 		next_token(cur);
 		if (!*cur)
 		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
+			ft_dprintf(2,
+				"minishell: syntax error near unexpected token 'newline'\n");
 			free_ast(left);
 			return (NULL);
 		}
diff --git a/src/parser/parse_arguments.c b/src/parser/parse_arguments.c
index 3836291..f284a8c 100644
--- a/src/parser/parse_arguments.c
+++ b/src/parser/parse_arguments.c
@@ -10,8 +10,8 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "parser.h"
 #include "lexer.h"
+#include "parser.h"
 
 char	**add_argument(char **argv, int *argc, int *size, const char *value)
 {
diff --git a/src/parser/parse_background.c b/src/parser/parse_background.c
index f241d72..7796716 100644
--- a/src/parser/parse_background.c
+++ b/src/parser/parse_background.c
@@ -10,10 +10,10 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "parser.h"
 #include "ast.h"
 #include "lexer.h"
+#include "minishell.h"
+#include "parser.h"
 
 t_ast	*parse_background(t_token **cur)
 {
@@ -24,7 +24,6 @@ t_ast	*parse_background(t_token **cur)
 	left = parse_sequence(cur);
 	if (!left)
 		return (NULL);
-
 	while (*cur && (*cur)->type == T_BG)
 	{
 		next_token(cur);
diff --git a/src/parser/parse_command_and_redirection.c b/src/parser/parse_command_and_redirection.c
index 0564150..7a67fe5 100644
--- a/src/parser/parse_command_and_redirection.c
+++ b/src/parser/parse_command_and_redirection.c
@@ -15,10 +15,9 @@
 t_ast	*parse_command_and_redirections(t_token **cur)
 {
 	if (*cur && (*cur)->type == T_LPAREN)
-		return parse_subshell(cur);
+		return (parse_subshell(cur));
 	if (*cur && ((*cur)->type == T_WORD || is_redirection(*cur)))
-		return parse_simple_command(cur);
-
+		return (parse_simple_command(cur));
 	ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n",
 		*cur ? (*cur)->value : "newline");
 	return (NULL);
diff --git a/src/parser/parse_pipeline.c b/src/parser/parse_pipeline.c
index 073a4d7..5589682 100644
--- a/src/parser/parse_pipeline.c
+++ b/src/parser/parse_pipeline.c
@@ -10,10 +10,10 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "parser.h"
 #include "ast.h"
 #include "lexer.h"
+#include "minishell.h"
+#include "parser.h"
 
 t_ast	*parse_pipeline(t_token **cur)
 {
@@ -24,13 +24,13 @@ t_ast	*parse_pipeline(t_token **cur)
 	left = parse_command_and_redirections(cur);
 	if (!left)
 		return (NULL);
-
 	while (*cur && (*cur)->type == T_PIPE)
 	{
 		next_token(cur);
 		if (!*cur)
 		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
+			ft_dprintf(2,
+				"minishell: syntax error near unexpected token 'newline'\n");
 			free_ast(left);
 			return (NULL);
 		}
diff --git a/src/parser/parse_redirections.c b/src/parser/parse_redirections.c
index dcacd1b..8ffc542 100644
--- a/src/parser/parse_redirections.c
+++ b/src/parser/parse_redirections.c
@@ -6,37 +6,44 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/26 01:03:45 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 18:01:15 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 15:30:04 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
+#include "ast.h"
 #include "lexer.h"
+#include "minishell.h"
 #include "parser.h"
-#include "ast.h"
 
 static t_redir_type	token_type_to_redir_type(t_token_type type)
 {
-	if (type == T_REDIR_IN)      return REDIR_IN;
-	if (type == T_REDIR_OUT)     return REDIR_OUT;
-	if (type == T_APPEND)        return REDIR_APPEND;
-	if (type == T_HEREDOC)       return REDIR_HEREDOC;
-	if (type == T_REDIR_ERR)     return REDIR_ERR;
-	if (type == T_APPEND_ERR)    return REDIR_APPEND_ERR;
-	if (type == T_REDIR_ALL)     return REDIR_ALL;
-	if (type == T_APPEND_ALL)    return REDIR_APPEND_ALL;
-	if (type == T_FORCE_OUT)     return REDIR_FORCE;
-	if (type == T_DUP_IN)        return REDIR_DUP_IN;
-	if (type == T_DUP_OUT)       return REDIR_DUP_OUT;
-	return REDIR_INVALID;
+	if (type == T_REDIR_IN)
+		return (REDIR_IN);
+	if (type == T_REDIR_OUT)
+		return (REDIR_OUT);
+	if (type == T_APPEND)
+		return (REDIR_APPEND);
+	if (type == T_HEREDOC)
+		return (REDIR_HEREDOC);
+	if (type == T_REDIR_ALL)
+		return (REDIR_ALL);
+	if (type == T_APPEND_ALL)
+		return (REDIR_APPEND_ALL);
+	if (type == T_FORCE_OUT)
+		return (REDIR_FORCE);
+	if (type == T_DUP_IN)
+		return (REDIR_DUP_IN);
+	if (type == T_DUP_OUT)
+		return (REDIR_DUP_OUT);
+	return (REDIR_INVALID);
 }
 
 int	is_redirection(t_token *tok)
 {
-	if (!tok) return 0;
+	if (!tok)
+		return (0);
 	return (tok->type == T_REDIR_IN || tok->type == T_REDIR_OUT
 		|| tok->type == T_APPEND || tok->type == T_HEREDOC
-		|| tok->type == T_REDIR_ERR || tok->type == T_APPEND_ERR
 		|| tok->type == T_REDIR_ALL || tok->type == T_APPEND_ALL
 		|| tok->type == T_FORCE_OUT || tok->type == T_DUP_IN
 		|| tok->type == T_DUP_OUT);
@@ -44,28 +51,32 @@ int	is_redirection(t_token *tok)
 
 int	parse_redirections(t_token **cur, t_ast **head, t_ast **tail)
 {
+	t_token			*redir_tok;
+	t_redir_type	rtype;
+		t_token *file_tok;
+		t_ast *new_redir;
+		int fd;
+
 	while (*cur && is_redirection(*cur))
 	{
-		t_token      *redir_tok = *cur;
-		t_redir_type  rtype     = token_type_to_redir_type(redir_tok->type);
-		t_token      *file_tok;
-		t_ast        *new_redir;
-		int           fd;
-
+		redir_tok = *cur;
+		rtype = token_type_to_redir_type(redir_tok->type);
 		next_token(cur);
 		file_tok = *cur;
 		if (!file_tok || file_tok->type != T_WORD || rtype == REDIR_INVALID)
 		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n",
+			ft_dprintf(2,
+				"minishell: syntax error near unexpected token '%s'\n",
 				file_tok ? file_tok->value : "newline");
 			return (0);
 		}
-
 		if (rtype == REDIR_DUP_OUT || rtype == REDIR_DUP_IN)
 		{
 			if (!ft_isposfdstr(file_tok->value))
 			{
-				ft_dprintf(2, "minishell: syntax error near unexpected token '%s'\n", file_tok->value);
+				ft_dprintf(2,
+					"minishell: syntax error near unexpected token '%s'\n",
+					file_tok->value);
 				return (0);
 			}
 			fd = ft_atoi(file_tok->value);
@@ -74,19 +85,27 @@ int	parse_redirections(t_token **cur, t_ast **head, t_ast **tail)
 		else if (rtype == REDIR_HEREDOC)
 		{
 			/* Guardamos SOLO el delimitador; se leerá en ejecución */
-			new_redir = ast_new_redir(NULL, ft_strdup(file_tok->value), rtype, -1);
+			new_redir = ast_new_redir(NULL, ft_strdup(file_tok->value), rtype,
+					-1);
 		}
 		else
 		{
-			new_redir = ast_new_redir(ft_strdup(file_tok->value), NULL, rtype, -1);
+			new_redir = ast_new_redir(ft_strdup(file_tok->value), NULL, rtype,
+					-1);
 		}
-
 		if (!new_redir)
 			return (0);
-
 		next_token(cur);
-		if (!*head) { *head = new_redir; *tail = new_redir; }
-		else { (*tail)->bin.right = new_redir; *tail = new_redir; }
+		if (!*head)
+		{
+			*head = new_redir;
+			*tail = new_redir;
+		}
+		else
+		{
+			(*tail)->bin.right = new_redir;
+			*tail = new_redir;
+		}
 	}
 	return (1);
 }
diff --git a/src/parser/parse_sequence.c b/src/parser/parse_sequence.c
index 94d764c..875738e 100644
--- a/src/parser/parse_sequence.c
+++ b/src/parser/parse_sequence.c
@@ -10,9 +10,9 @@
 /*                                                                            */
 /* ************************************************************************** */
 
+#include "ast.h"
 #include "minishell.h"
 #include "parser.h"
-#include "ast.h"
 
 t_ast	*parse_sequence(t_token **cur)
 {
@@ -23,13 +23,13 @@ t_ast	*parse_sequence(t_token **cur)
 	left = parse_and_or(cur);
 	if (!left)
 		return (NULL);
-
 	while (*cur && (*cur)->type == T_SEMI)
 	{
 		next_token(cur);
 		if (!*cur)
 		{
-			ft_dprintf(2, "minishell: syntax error near unexpected token 'newline'\n");
+			ft_dprintf(2,
+				"minishell: syntax error near unexpected token 'newline'\n");
 			free_ast(left);
 			return (NULL);
 		}
diff --git a/src/parser/parse_simple_command.c b/src/parser/parse_simple_command.c
index 8f7cfc3..75036a5 100644
--- a/src/parser/parse_simple_command.c
+++ b/src/parser/parse_simple_command.c
@@ -14,11 +14,13 @@
 
 t_ast	*parse_simple_command(t_token **cur)
 {
-	t_ast	*redir_head = NULL;
-	t_ast	*redir_tail = NULL;
+	t_ast	*redir_head;
+	t_ast	*redir_tail;
 	t_ast	*cmd_node;
 	char	**argv;
 
+	redir_head = NULL;
+	redir_tail = NULL;
 	/* caso subshell: ( ... ) [redirs] */
 	if (*cur && (*cur)->type == T_LPAREN)
 	{
@@ -33,33 +35,28 @@ t_ast	*parse_simple_command(t_token **cur)
 		cmd_node->subshell.redirections = redir_head;
 		return (cmd_node);
 	}
-
 	/* redirecciones iniciales */
 	if (!parse_redirections(cur, &redir_head, &redir_tail))
 		return (NULL);
-
-/* parse_simple_command.c */
-
-    argv = parse_arguments(cur);
-    if (!argv)
-    {
-        /* === ANTES: error si había redirecciones sin argv ===
-        if (redir_head) {
-            free_ast(redir_head);
-            ft_dprintf(2,"minishell: syntax error: empty command before redirection\n");
-            return (NULL);
-        }
-        ft_dprintf(2,"minishell: syntax error: empty command or unexpected token\n");
-        return (NULL);
-        */
-
-        /* === AHORA: comportamiento bash — permitir solo redirecciones === */
-        if (redir_head)
-            return ast_new_command(NULL, redir_head);  /* argv == NULL */
-        ft_dprintf(2, "minishell: syntax error: empty command\n");
-        return (NULL);
-    }
-
+	/* parse_simple_command.c */
+	argv = parse_arguments(cur);
+	if (!argv)
+	{
+		/* === ANTES: error si había redirecciones sin argv ===
+		if (redir_head) {
+			free_ast(redir_head);
+			ft_dprintf(2,"minishell: syntax error: empty command before redirection\n");
+			return (NULL);
+		}
+		ft_dprintf(2,"minishell: syntax error: empty command or unexpected token\n");
+		return (NULL);
+		*/
+		/* === AHORA: comportamiento bash — permitir solo redirecciones === */
+		if (redir_head)
+			return (ast_new_command(NULL, redir_head)); /* argv == NULL */
+		ft_dprintf(2, "minishell: syntax error: empty command\n");
+		return (NULL);
+	}
 	/* redirecciones finales */
 	if (!parse_redirections(cur, &redir_head, &redir_tail))
 	{
@@ -67,7 +64,6 @@ t_ast	*parse_simple_command(t_token **cur)
 		free_ast(redir_head);
 		return (NULL);
 	}
-
 	cmd_node = ast_new_command(argv, redir_head);
 	if (!cmd_node)
 	{
diff --git a/src/parser/parse_simple_utils.c b/src/parser/parse_simple_utils.c
index 2310ab3..205bb9f 100644
--- a/src/parser/parse_simple_utils.c
+++ b/src/parser/parse_simple_utils.c
@@ -10,10 +10,10 @@
 /*                                                                            */
 /* ************************************************************************** */
 
+#include "ast.h"
+#include "lexer.h"
 #include "minishell.h"
 #include "parser.h"
-#include "ast.h"   
-#include "lexer.h"
 
 int	is_lparen(t_token *tok)
 {
diff --git a/src/parser/parse_subshell.c b/src/parser/parse_subshell.c
index db41155..16c0323 100644
--- a/src/parser/parse_subshell.c
+++ b/src/parser/parse_subshell.c
@@ -10,10 +10,10 @@
 /*                                                                            */
 /* ************************************************************************** */
 
-#include "minishell.h"
-#include "parser.h"
 #include "ast.h"
 #include "lexer.h"
+#include "minishell.h"
+#include "parser.h"
 
 t_ast	*parse_subshell(t_token **cur)
 {
diff --git a/src/shell/cleanup_shell.c b/src/shell/cleanup_shell.c
index 47e29c4..7e5b33f 100644
--- a/src/shell/cleanup_shell.c
+++ b/src/shell/cleanup_shell.c
@@ -6,17 +6,12 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/17 03:25:37 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/31 22:12:22 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/04 17:12:12 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
-#include "env.h"
-#include <string.h>
-#include <errno.h>
 
-/* --- NUEVO: helper sin 'for' para Norma --- */
 static int	has_slash_local(const char *s)
 {
 	int	i;
@@ -35,33 +30,20 @@ static int	has_slash_local(const char *s)
 
 int	print_exec_error(t_shell *shell, const char *cmd, int err_code)
 {
-	int	ret;
-
 	if (!cmd || !*cmd)
-	{
-		ft_dprintf(2, "minishell: : command not found\n");
-		shell->exit_status = 127;
-		return (127);
-	}
+		return (shell->exit_status = 127, ft_dprintf(2,
+				"minishell: : command not found\n"), 127);
 	if (!has_slash_local(cmd) && err_code == ENOENT)
-	{
-		ft_dprintf(2, "minishell: %s: command not found\n", cmd);
-		ret = 127;
-	}
-	else
-	{
-		ft_dprintf(2, "minishell: %s: %s\n", cmd, strerror(err_code));
-		if (err_code == EACCES || err_code == ENOEXEC
-			|| err_code == EISDIR || err_code == EPERM)
-			ret = 126;
-		else if (err_code == ENOENT || err_code == ENOTDIR
-			|| err_code == ENAMETOOLONG || err_code == ELOOP)
-			ret = 127;
-		else
-			ret = 126;
-	}
-	shell->exit_status = ret;
-	return (ret);
+		return (shell->exit_status = 127, ft_dprintf(2, "minishell:
+				%s: command not found\n", cmd), 127);
+	ft_dprintf(2, "minishell: %s: %s\n", cmd, strerror(err_code));
+	if (err_code == EACCES || err_code == ENOEXEC || err_code == EISDIR
+		|| err_code == EPERM)
+		return (shell->exit_status = 126);
+	if (err_code == ENOENT || err_code == ENOTDIR || err_code == ENAMETOOLONG
+		|| err_code == ELOOP)
+		return (shell->exit_status = 127);
+	return (shell->exit_status = 126);
 }
 
 void	cleanup_loop(t_shell *shell)
diff --git a/src/shell/handle_help_version.c b/src/shell/handle_help_version.c
index d1bea1a..19550d8 100644
--- a/src/shell/handle_help_version.c
+++ b/src/shell/handle_help_version.c
@@ -33,11 +33,14 @@ void	print_help(void)
 	ft_dprintf(1, "Usage:  ./minishell [option] [script-file]\n");
 	ft_dprintf(1, "Options:\n");
 	ft_dprintf(1, "        -c command      execute command\n");
-	ft_dprintf(1, "        script-file     execute commands from script file\n");
+	ft_dprintf(1,
+		"        script-file     execute commands from script file\n");
 	ft_dprintf(1, "        --help          display this help and exit\n");
-	ft_dprintf(1, "        --version       output version information and exit\n");
+	ft_dprintf(1,
+		"        --version       output version information and exit\n");
 	ft_dprintf(1, "\n");
-	ft_dprintf(1, "If no option or script-file is given, minishell starts in interactive mode.\n");
+	ft_dprintf(1, "If no option or script-file is given,
+		minishell starts in interactive mode.\n");
 }
 
 void	print_usage(const char *invalid)
@@ -47,9 +50,11 @@ void	print_usage(const char *invalid)
 	ft_dprintf(2, "Usage:  ./minishell [option] [script-file]\n");
 	ft_dprintf(2, "Options:\n");
 	ft_dprintf(2, "        -c command      execute command\n");
-	ft_dprintf(2, "        script-file     execute commands from script file\n");
+	ft_dprintf(2,
+		"        script-file     execute commands from script file\n");
 	ft_dprintf(2, "        --help          display this help and exit\n");
-	ft_dprintf(2, "        --version       output version information and exit\n");
+	ft_dprintf(2,
+		"        --version       output version information and exit\n");
 }
 
 void	print_version(void)
diff --git a/src/shell/init_shell.c b/src/shell/init_shell.c
index 18699ea..dee0c3f 100644
--- a/src/shell/init_shell.c
+++ b/src/shell/init_shell.c
@@ -6,12 +6,11 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/17 03:25:09 by acoronad          #+#    #+#             */
-/*   Updated: 2025/06/27 19:56:47 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/04 17:14:48 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "env.h"
 
 int	init_shell_name(t_shell *shell, char **argv)
 {
@@ -20,19 +19,21 @@ int	init_shell_name(t_shell *shell, char **argv)
 	shell->program_name = ft_strdup(argv[0]);
 	if (!shell->program_name)
 	{
-		ft_dprintf(2, "minishell: Error fatal: No se pudo asignar el nombre del programa.\n");
+		ft_dprintf(2,
+			"minishell: Error fatal: No se pudo asignar el nombre del programa.\n");
 		return (1);
 	}
 	return (0);
 }
 
-int init_env(t_shell *shell, char **envp)
+int	init_env(t_shell *shell, char **envp)
 {
-    shell->env = init_env_list(envp);
-    if (!shell->env)
-    {
-        ft_dprintf(2, "minishell: Error fatal: No se pudo inicializar el entorno.\n");
-        return (1);
-    }
-    return (0);
+	shell->env = init_env_list(envp);
+	if (!shell->env)
+	{
+		ft_dprintf(2,
+			"minishell: Error fatal: No se pudo inicializar el entorno.\n");
+		return (1);
+	}
+	return (0);
 }
diff --git a/src/shell/run_interactive.c b/src/shell/run_interactive.c
index 9747e7e..e3aa26c 100644
--- a/src/shell/run_interactive.c
+++ b/src/shell/run_interactive.c
@@ -6,100 +6,43 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/10 13:09:44 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/27 00:41:11 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 13:46:25 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
 
-/* helpers de cierre de comillas/backslash (tus versiones) */
-static int ft_quotes_closed(const char *line)
+static int	is_blank(const char *s)
 {
-    int i = 0, state = 0;
-    while (line && line[i])
-    {
-        if (!state && (line[i] == '\'' || line[i] == '"')) state = line[i];
-        else if (state == '\'' && line[i] == '\'') state = 0;
-        else if (state == '"' && line[i] == '\\' &&
-                 (line[i + 1] == '"' || line[i + 1] == '\\' || line[i + 1] == '`')) i++;
-        else if (state == '"' && line[i] == '"') state = 0;
-        else if (!state && line[i] == '\\' && line[i + 1]) i++;
-        i++;
-    }
-    return (state == 0);
+	int	i;
+
+	if (!s)
+		return (1);
+	i = 0;
+	while (s[i] && ft_isspace((unsigned char)s[i]))
+		i++;
+	return (s[i] == '\0');
 }
 
-static int ft_backslach_closed(char *line)
+void	run_interactive(t_shell *shell)
 {
-    int i, count;
-
-    if (!line) return (1);
-    i = (int)ft_strlen(line) - 1;
-    count = 0;
-    while (i >= 0 && line[i] == '\\') { count++; i--; }
-    return ((count % 2) == 0);
-}
-
-char *read_line_interactive(t_shell *shell)
-{
-    char *next;
-
-    /* aseguramos prompt limpio y TTY sano */
-    setup_prompt_signals();
-    g_signal = 0;
-
-    shell->line = readline("\001\033[1;35m\002minishell$ \001\033[0m\002");
-    if (!shell->line)
-        return NULL;
-
-    while (!ft_quotes_closed(shell->line) || !ft_backslach_closed(shell->line))
-    {
-        setup_prompt_signals();
-        next = readline("> ");
-        if (!next) { free(shell->line); shell->line = NULL; return NULL; }
-        shell->line = ft_strjoin_free_s1(shell->line, "\n");
-        if (!shell->line) { free(next); return NULL; }
-        shell->line = ft_strjoin_free_s1(shell->line, next);
-        free(next);
-    }
-    return shell->line;
-}
-void run_interactive(t_shell *shell)
-{
-    shell->is_interactive = 1;
-
-    while (1)
-    {
-        setup_prompt_signals();          /* prompt: INT handler + QUIT ignorado */
-        if (shell->line) { free(shell->line); shell->line = NULL; }
-
-        shell->line = read_line_interactive(shell); /* usa readline con el prompt */
-
-        if (!shell->line)                 /* Ctrl-D en línea vacía */
-            break;
-
-        if (shell->line[0] == '\0') {     /* Enter vacío o Ctrl-C en prompt */
-            free(shell->line);
-            shell->line = NULL;
-            continue;
-        }
-
-        add_history(shell->line);
-
-        /* PADRE ignora señales mientras ejecuta (y las restablece el hijo) */
-        setup_exec_parent_signals();
-
-        if (shell->tokens) { free_token_list(shell->tokens); shell->tokens = NULL; }
-        shell_exec(shell);
-
-        /* Al volver de ejecutar, vuelve al modo prompt */
-        setup_prompt_signals();
-        cleanup_loop(shell);
-
-        if (shell->should_exit)
-            break;
-    }
-    if (shell->is_interactive)
-        write(1, "exit\n", 5);
-    rl_clear_history();
+	shell->is_interactive = 1;
+	while (1)
+	{
+		setup_prompt_signals();
+		cleanup_loop(shell); /* limpia line/tokens previos */
+		shell->line = read_line_interactive(shell);
+		if (!shell->line) /* Ctrl-D en prompt vacío */
+			break ;
+		if (is_blank(shell->line)) /* ignora líneas vacías/espacios */
+			continue ;
+		add_history(shell->line);
+		setup_exec_parent_signals();
+		shell_exec(shell); /* cleanup se hace al inicio del bucle */
+		if (shell->should_exit)
+			break ;
+	}
+	if (shell->is_interactive) /* Bash imprime "exit" al salir de REPL */
+		write(1, "exit\n", 5);
+	rl_clear_history();
 }
diff --git a/src/shell/run_non_interactive.c b/src/shell/run_non_interactive.c
index 2e773cc..edf496d 100644
--- a/src/shell/run_non_interactive.c
+++ b/src/shell/run_non_interactive.c
@@ -6,66 +6,53 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/10/22 20:32:53 by acoronad          #+#    #+#             */
-/*   Updated: 2025/11/04 14:50:20 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 13:53:06 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "lexer.h"
-#include "parser.h"
-#include "expand.h"
-#include "exec.h"
 
 // Quita '\n' final si existe (opcionalmente también '\r' si llegara CRLF).
-static void chomp_nl(char *s)
+// Compatibilidad CRLF: si el script viene de Windows, acabará en \r\n.
+// Sin el strip de \r, el último token podría quedar con un \r colgando (p. ej.,
+	"echo\r")
+
+static void	strip_nl(char *s)
 {
-    size_t len;
+	size_t	len;
 
-    if (!s)
-        return;
-    len = ft_strlen(s);
-    if (len && s[len - 1] == '\n')
-    {
-        s[len - 1] = '\0';
-        if (len >= 2 && s[len - 2] == '\r') // por si viniera CRLF
-            s[len - 2] = '\0';
-    }
+	if (!s)
+		return ;
+	len = ft_strlen(s);
+	if (len && s[len - 1] == '\n')
+	{
+		s[len - 1] = '\0';
+		if (len >= 2 && s[len - 2] == '\r')
+			s[len - 2] = '\0';
+	}
 }
 
-void run_non_interactive(t_shell *shell)
+void	run_non_interactive(t_shell *shell)
 {
-    char *line;
+	char	*line;
 
-    shell->is_interactive = 0;
-    // En no-interactivo, el caller debe haber llamado a setup_default_signals()
-    // para no redibujar prompt y dejar señales por defecto.
-    while (1)
-    {
-        if (shell->line)
-        {
-            free(shell->line);
-            shell->line = NULL;
-        }
-        line = get_next_line(STDIN_FILENO);   // <-- usamos tu GNL
-        if (!line)
-            break;                            // EOF o error -> salir bucle
-        chomp_nl(line);                        // quitamos '\n' final
-        shell->line = line;
-        if (*shell->line)                      // ignorar líneas vacías
-        {
-            // El padre no debe imprimir nada ni reaccionar a SIGINT/SIGQUIT.
-            // Los hijos restaurarán señales por defecto antes de execve().
-            setup_exec_parent_signals();
-            if (shell->tokens)
-            {
-                free_token_list(shell->tokens);
-                shell->tokens = NULL;
-            }
-            shell_exec(shell);
-        }
-        cleanup_loop(shell);
-        if (shell->should_exit)
-            break;
-    }
-    // Importante: NO imprimir "exit\n" aquí (solo en modo interactivo).
+	shell->is_interactive = 0;
+	setup_default_signals();
+	while (1)
+	{
+		cleanup_loop(shell); /* limpia line/tokens previos */
+		line = get_next_line(STDIN_FILENO);
+		if (!line)
+			break ;
+		strip_nl(line);
+		shell->line = line;
+		if (*shell->line)
+		{
+			setup_exec_parent_signals();
+			shell_exec(shell);
+		}
+		if (shell->should_exit)
+			break ;
+	}
+	/* no imprimir "exit\n" en no-interactivo */
 }
diff --git a/src/shell/shell_exec.c b/src/shell/shell_exec.c
index cffe79e..e9b6d11 100644
--- a/src/shell/shell_exec.c
+++ b/src/shell/shell_exec.c
@@ -6,7 +6,7 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/11 14:49:39 by acoronad          #+#    #+#             */
-/*   Updated: 2025/11/04 14:40:54 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/04 14:56:27 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
diff --git a/src/shell/shell_modes.c b/src/shell/shell_modes.c
index 7e728ca..0e085d6 100644
--- a/src/shell/shell_modes.c
+++ b/src/shell/shell_modes.c
@@ -6,58 +6,69 @@
 /*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/06/26 12:52:57 by acoronad          #+#    #+#             */
-/*   Updated: 2025/10/22 20:48:01 by acoronad         ###   ########.fr       */
+/*   Updated: 2025/11/05 14:35:33 by acoronad         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "minishell.h"
-#include "signals.h"
-//#include "exec.h"
 
-/*
-static int	run_one_command_mode(char **argv, t_shell *shell)
+/* ejecuta -c "cmd" y sale (no interactivo) */
+int	run_c_mode(t_shell *sh, const char *cmd)
 {
-	shell->is_one_command = 1;
-	shell->is_interactive = 0;
-	execute_one_command(argv[2], shell);
-	return (shell->exit_status);
-}
-
-static int	run_script_mode(char **argv, t_shell *shell)
-{
-	shell->is_script = 1;
-	shell->is_interactive = 0;
-	execute_script(argv[1], shell);
-	return (shell->exit_status);
+	setup_default_signals();
+	sh->is_interactive = 0;
+	if (!cmd)
+		return (2);
+	if (sh->line)
+	{
+		free(sh->line);
+		sh->line = NULL;
+	}
+	sh->line = ft_strdup(cmd);
+	if (!sh->line)
+		return (1);
+	if (sh->tokens)
+	{
+		free_token_list(sh->tokens);
+		sh->tokens = NULL;
+	}
+	shell_exec(sh);
+	cleanup_loop(sh);
+	return (sh->exit_status);
 }
 
-static int	handle_invalid_args(char *program_name)
+/* lee desde stdin (-s) hasta EOF (no interactivo) */
+int	run_s_mode(t_shell *sh)
 {
-	print_usage(program_name);
-	return (2);
+	setup_default_signals();
+	sh->is_interactive = 0;
+	run_non_interactive(sh);
+	return (sh->exit_status);
 }
-*/
 
-int run_shell_modes(int argc, char **argv, char **envp, t_shell *shell)
+/* entrypoint: interactivo / no-interactivo / -c / -s */
+int	run_shell_modes(int argc, char **argv, char **envp, t_shell *shell)
 {
-    int ret;
+	int		ret;
+	t_opts	opt;
 
-    ret = handle_help_version(argc, argv);
-    if (ret != -1)
-        return (ret);
-
-    if (init_env(shell, envp) != 0)
-        return (1);
-
-    shell->is_interactive = isatty(STDIN_FILENO) && isatty(STDOUT_FILENO);
-
-    if (shell->is_interactive) {
-        setup_signals();         // señales base
-        run_interactive(shell);  // con prompt
-    } else {
-        setup_default_signals(); // señales por defecto (no prompt)
-        run_non_interactive(shell);
-    }
-    return shell->exit_status;
+	ret = handle_help_version(argc, argv);
+	if (ret != -1)
+		return (ret);
+	if (init_env(shell, envp) != 0)
+		return (1);
+	ret = parse_args_simple(argc, argv, &opt);
+	if (ret != 0)
+		return (ret);
+	if (opt.cstr)
+		return (run_c_mode(shell, opt.cstr));
+	if (opt.flag_s)
+		return (run_s_mode(shell));
+	shell->is_interactive = (opt.flag_i || (isatty(STDIN_FILENO)
+				&& isatty(STDERR_FILENO)));
+	if (shell->is_interactive)
+		run_interactive(shell);
+	else
+		run_non_interactive(shell);
+	return (shell->exit_status);
 }
-
diff --git a/src/signals/signals.c b/src/signals/signals.c
index 947d92b..c770761 100644
--- a/src/signals/signals.c
+++ b/src/signals/signals.c
@@ -13,52 +13,59 @@
 #include "minishell.h"
 
 /* Única global permitida */
-volatile sig_atomic_t g_signal = 0;
+volatile sig_atomic_t	g_signal = 0;
 
 /* -------------------------------------------------------------------------- */
 /*  ECHOCTL on/off: muestra los controles como ^C/^\\ si está activo.         */
 /*  (No guardamos estado global adicional; simplemente forzamos el bit.)      */
 /* -------------------------------------------------------------------------- */
-void    set_echoctl(int enable)
+void	set_echoctl(int enable)
 {
-    struct termios t;
+	struct termios	t;
 
-    if (tcgetattr(STDIN_FILENO, &t) == -1)
-        return;
+	if (tcgetattr(STDIN_FILENO, &t) == -1)
+		return ;
 #ifdef ECHOCTL
-    if (enable)
-        t.c_lflag |= ECHOCTL;
-    else
-        t.c_lflag &= ~ECHOCTL;
+	if (enable)
+		t.c_lflag |= ECHOCTL;
+	else
+		t.c_lflag &= ~ECHOCTL;
 #endif
-    tcsetattr(STDIN_FILENO, TCSANOW, &t);
+	tcsetattr(STDIN_FILENO, TCSANOW, &t);
 }
 
 /* Compat con tu código existente */
-void    disable_vquit(void)   { set_echoctl(0); }
-void    restore_vquit(void)   { set_echoctl(1); }
+void	disable_vquit(void)
+{
+	set_echoctl(0);
+}
+void	restore_vquit(void)
+{
+	set_echoctl(1);
+}
 
 /* -------------------------------------------------------------------------- */
 /*  Handler de SIGINT en el PROMPT:                                           */
 /*  - Escribe salto de línea                                                  */
 /*  - Limpia la línea de readline y redibuja el prompt                        */
-/*  - Marca g_signal para que el bucle principal ponga exit_status=130         */
+/* 
+	- Marca g_signal para que el bucle principal ponga exit_status=130         */
 /* -------------------------------------------------------------------------- */
-void    handle_sigint(int sig)
+void	handle_sigint(int sig)
 {
-    (void)sig;
-    g_signal = 1;
-    write(STDOUT_FILENO, "\n", 1);
-    rl_replace_line("", 0);
-    rl_on_new_line();
-    rl_redisplay();
+	(void)sig;
+	g_signal = 1;
+	write(STDOUT_FILENO, "\n", 1);
+	rl_replace_line("", 0);
+	rl_on_new_line();
+	rl_redisplay();
 }
 
 /* En el prompt, Ctrl-\ no hace nada */
-void    handle_sigquit(int sig)
+void	handle_sigquit(int sig)
 {
-    (void)sig;
-    /* nada */
+	(void)sig;
+	/* nada */
 }
 
 /* -------------------------------------------------------------------------- */
@@ -67,30 +74,30 @@ void    handle_sigquit(int sig)
 /*  - SIGINT -> handler que aborta línea.                                     */
 /*  - SIGQUIT -> ignorado.                                                    */
 /* -------------------------------------------------------------------------- */
-void    setup_prompt_signals(void)
+void	setup_prompt_signals(void)
 {
-    set_echoctl(1);
-    signal(SIGINT,  handle_sigint);
-    signal(SIGQUIT, SIG_IGN);
+	set_echoctl(1);
+	signal(SIGINT, handle_sigint);
+	signal(SIGQUIT, SIG_IGN);
 }
 
 /* Padre durante ejecución de comandos: no debe matar al hijo al pulsar ^C/^\ */
-void    setup_exec_parent_signals(void)
+void	setup_exec_parent_signals(void)
 {
-    signal(SIGINT,  SIG_IGN);
-    signal(SIGQUIT, SIG_IGN);
+	signal(SIGINT, SIG_IGN);
+	signal(SIGQUIT, SIG_IGN);
 }
 
 /* Defaults (modo no-interactivo). También lo puedes usar si quieres resetear. */
-void    setup_default_signals(void)
+void	setup_default_signals(void)
 {
-    set_echoctl(1); /* ver ^C/^\ en programas */
-    signal(SIGINT,  SIG_DFL);
-    signal(SIGQUIT, SIG_DFL);
+	set_echoctl(1); /* ver ^C/^\ en programas */
+	signal(SIGINT, SIG_DFL);
+	signal(SIGQUIT, SIG_DFL);
 }
 
 /* Compat: muchos sitios llaman a setup_signals() al inicio -> prompt. */
-void    setup_signals(void)
+void	setup_signals(void)
 {
-    setup_prompt_signals();
+	setup_prompt_signals();
 }
