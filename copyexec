/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_and_or.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:12:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:49:04 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_and(t_ast *node, t_shell *shell)
{
	int	ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret == 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}

int	execute_or(t_ast *node, t_shell *shell)
{
	int	ret;

	ret = execute_ast(node->bin.left, shell);
	if (ret != 0)
		ret = execute_ast(node->bin.right, shell);
	else
		shell->exit_status = ret;
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_ast.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/17 04:37:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:48:43 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_ast(t_ast *node, t_shell *shell)
{
	int	ret;

	if (!node)
		return (0);
	if (node->type == N_COMMAND)
		ret = execute_command(node, shell);
	else if (node->type == N_PIPE)
		ret = execute_pipe(node, shell);
	else if (node->type == N_AND)
		ret = execute_and(node, shell);
	else if (node->type == N_OR)
		ret = execute_or(node, shell);
	else if (node->type == N_SUBSHELL)
		ret = execute_subshell(node, shell);
	else if (node->type == N_SEQUENCE)
		ret = execute_sequence(node, shell);
	else if (node->type == N_BACKGROUND)
		ret = execute_background(node, shell);
	else if (node->type == N_REDIR)
	{
		ft_dprintf(2,
			"minishell: syntax error near unexpected token `newline'\n");
		shell->exit_status = 2;
		ret = 1;
	}
	else
	{
		ft_dprintf(2, "minishell: command not found\n");
		shell->exit_status = 127;
		ret = 127;
	}
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_background.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:19:18 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:49:41 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_background(t_ast *node, t_shell *shell)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		ft_dprintf(2, "minishell: fork error\n");
		shell->exit_status = 1;
		return (1);
	}
	if (pid == 0)
	{
		/* Hijo: señales por defecto para comportamiento bash-like */
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		_exit(execute_ast(node->bin.left, shell) & 0xFF);
	}
	/* Padre: no espera al hijo en background */
	shell->exit_status = 0;
	ft_dprintf(1, "[1] %d\n", pid);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:20:54 by acoronad          #+#    #+#             */
/*   Updated: 2025/11/07 08:09:48 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	restore_std_fds(int saved_in, int saved_out, int saved_err)
{
	if (saved_in != -1)
	{
		dup2(saved_in, STDIN_FILENO);
		close(saved_in);
	}
	if (saved_out != -1)
	{
		dup2(saved_out, STDOUT_FILENO);
		close(saved_out);
	}
	if (saved_err != -1)
	{
		dup2(saved_err, STDERR_FILENO);
		close(saved_err);
	}
}

int	execute_command(t_ast *node, t_shell *shell)
{
	pid_t	pid;
	char	**env;
	char	*exec_path;
	int		status;
	int		saved_in;
	int		saved_out;
	int		saved_err;
	int		sig;

	saved_in = -1;
	saved_out = -1;
	saved_err = -1;
	if (!node)
	{
		shell->exit_status = 0;
		return (0);
	}
	/* === SOLO REDIRECCIONES (sin argv) ===
		Bash permite comandos vacíos con redirs; aplicamos redirs y devolvemos 0 si no hay error. */
	if ((!node->cmd.argv || !node->cmd.argv[0]) && node->cmd.redirections)
	{
		saved_in = dup(STDIN_FILENO);
		saved_out = dup(STDOUT_FILENO);
		saved_err = dup(STDERR_FILENO);
		if (saved_in == -1 || saved_out == -1 || saved_err == -1)
		{
			perror("minishell: dup");
			if (saved_in != -1)
				close(saved_in);
			if (saved_out != -1)
				close(saved_out);
			if (saved_err != -1)
				close(saved_err);
			shell->exit_status = 1;
			return (1);
		}
		if (apply_redirections(node->cmd.redirections) != 0)
		{
			restore_std_fds(saved_in, saved_out, saved_err);
			shell->exit_status = 1;
			return (1);
		}
		restore_std_fds(saved_in, saved_out, saved_err);
		shell->exit_status = 0;
		return (0);
	}
	/* Comando vacío y sin redirecciones → no hace nada, exit 0 */
	if (!node->cmd.argv || !node->cmd.argv[0])
	{
		shell->exit_status = 0;
		return (0);
	}
	/* argv[0] vacío -> "command not found" */
	if (node->cmd.argv[0][0] == '\0')
	{
		ft_dprintf(2, "minishell: : command not found\n");
		shell->exit_status = 127;
		return (127);
	}
	/* Builtins en el proceso padre con redirecciones aplicadas temporalmente */
	if (is_builtin(node->cmd.argv[0]))
	{
		saved_in = dup(STDIN_FILENO);
		saved_out = dup(STDOUT_FILENO);
		saved_err = dup(STDERR_FILENO);
		if (saved_in == -1 || saved_out == -1 || saved_err == -1)
		{
			perror("minishell: dup");
			if (saved_in != -1)
				close(saved_in);
			if (saved_out != -1)
				close(saved_out);
			if (saved_err != -1)
				close(saved_err);
			shell->exit_status = 1;
			return (1);
		}
		if (apply_redirections(node->cmd.redirections) != 0)
		{
			restore_std_fds(saved_in, saved_out, saved_err);
			shell->exit_status = 1;
			return (1);
		}
		shell->exit_status = run_builtin(node, shell);
		restore_std_fds(saved_in, saved_out, saved_err);
		return (shell->exit_status);
	}
	/* Búsqueda de ejecutable externo */
	exec_path = find_executable(node->cmd.argv[0], shell);
	if (!exec_path)
	{
		if (!ft_strchr(node->cmd.argv[0], '/'))
			return (print_exec_error(shell, node->cmd.argv[0], ENOENT));
		if (errno == 0)
			return (print_exec_error(shell, node->cmd.argv[0], ENOENT));
		return (print_exec_error(shell, node->cmd.argv[0], errno));
	}
	env = env_to_array(shell->env);
	if (!env)
	{
		free(exec_path);
		shell->exit_status = 1;
		return (1);
	}
	pid = fork();
	if (pid < 0)
	{
		status = print_exec_error(shell, node->cmd.argv[0], errno);
		free(exec_path);
		ft_free_strtab(env);
		return (status);
	}
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		if (apply_redirections(node->cmd.redirections) != 0)
			_exit(1);
		execve(exec_path, node->cmd.argv, env);
		print_exec_error(shell, node->cmd.argv[0], errno);
		_exit(127);
	}
	if (waitpid(pid, &status, 0) == -1)
		shell->exit_status = 1;
	else if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
	{
		sig = WTERMSIG(status);
		shell->exit_status = 128 + sig;
		if (sig == SIGINT)
			write(STDOUT_FILENO, "\n", 1);
		else if (sig == SIGQUIT)
			write(STDERR_FILENO, "Quit (core dumped)\n", 19);
	}
	else
		shell->exit_status = 1;
	free(exec_path);
	ft_free_strtab(env);
	return (shell->exit_status);
}

/*
// exec_simple.c (esquema)
int exec_simple(t_ast *cmd, t_shell *sh)
{
	pid_t pid;

	pid = fork();
	if (pid == 0)
	{
		set_child_signals();
		if (!expand_command(cmd, sh->env))           // $VAR + quitar comillas; opcional globbing
			_exit(1);
		if (!apply_redirections(cmd))                // usa tmpfiles de heredoc ya preparados
			_exit(1);
		execve(cmd->argv[0], cmd->argv, sh->envp);
		perror("execve");
		_exit(127);
	}
	set_parent_signals();
	return wait_child_update_status(pid, &sh->exit_status);
}
*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:11:56 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:18 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_pipe(t_ast *node, t_shell *shell)
{
	int	pipefd[2];
	int	st_l = 0, st_r;
	int	sig;

	pid_t pid_l, pid_r;
	st_l = 0, st_r = 0;
	if (pipe(pipefd) == -1)
	{
		ft_dprintf(2, "minishell: pipe error\n");
		shell->exit_status = 1;
		return (1);
	}
	pid_l = fork();
	if (pid_l == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		close(pipefd[0]);
		if (dup2(pipefd[1], STDOUT_FILENO) < 0)
			_exit(1);
		close(pipefd[1]);
		_exit(execute_ast(node->bin.left, shell) & 0xFF);
	}
	pid_r = fork();
	if (pid_r == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		close(pipefd[1]);
		if (dup2(pipefd[0], STDIN_FILENO) < 0)
			_exit(1);
		close(pipefd[0]);
		_exit(execute_ast(node->bin.right, shell) & 0xFF);
	}
	close(pipefd[0]);
	close(pipefd[1]);
	if (waitpid(pid_l, &st_l, 0) < 0)
		st_l = 0;
	if (waitpid(pid_r, &st_r, 0) < 0)
		st_r = 0;
	if (WIFEXITED(st_r))
		shell->exit_status = WEXITSTATUS(st_r);
	else if (WIFSIGNALED(st_r))
	{
		sig = WTERMSIG(st_r);
		if (sig == SIGINT)
			write(STDOUT_FILENO, "\n", 1);
		else if (sig == SIGQUIT)
			write(STDERR_FILENO, "Quit (core dumped)\n", 19);
		shell->exit_status = 128 + sig;
	}
	else
		shell->exit_status = 1;
	return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/07 08:36:49 by acoronad          #+#    #+#             */
/*   Updated: 2025/11/07 17:45:50 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* -------------------------------------------------------------------------- */
/* Helpers                                                                    */
/* -------------------------------------------------------------------------- */
/* Normaliza filename de redirección:
   - Split con comillas respetadas (no glob)
   - 0 campos  -> *out=NULL, return 0  (dejar que open falle en el caller o tratarlo como ambiguo)
   - >1 campos -> ambiguous (return 2)
   - 1 campo   -> quote-removal y devuelve copia en *out (return 1)
*/
static int normalize_redir_filename(const char *raw, char **out_clean)
{
    t_token *lst;
    t_token *nxt;
    int      count;
    char    *clean;

    *out_clean = NULL;
    if (!raw || *raw == '\0')
        return 0; /* vacío */

    lst = split_word_respecting_quotes(raw);
    if (!lst)
        return 0; /* 0 campos tras split */

    count = 0;
    nxt = lst;
    while (nxt)
    {
        count++;
        nxt = nxt->next;
        if (count > 1)
        {
            free_token_list(lst);
            return 2; /* ambiguous */
        }
    }
    /* 1 campo: quote-removal */
    clean = quote_remove_like_bash(lst->value);
    free_token_list(lst);
    if (!clean)
        return 0;
    *out_clean = clean;
    return 1;
}

static int	dup_into(int fd, int target)
{
	if (dup2(fd, target) < 0)
	{
		perror("minishell: dup2");
		close(fd);
		return (1);
	}
	close(fd);
	return (0);
}

static int	open_rdonly(const char *p, int *fd)
{
	*fd = open(p, O_RDONLY);
	if (*fd < 0)
	{
		perror("minishell: open");
		return (1);
	}
	return (0);
}

static int	open_w_trunc(const char *p, int *fd, int force)
{
	int	flags;

	(void)force; /* si implementas 'noclobber', úsalo aquí */
	flags = O_WRONLY | O_CREAT | O_TRUNC;
	*fd = open(p, flags, 0644);
	if (*fd < 0)
	{
		perror("minishell: open");
		return (1);
	}
	return (0);
}

static int	open_w_append(const char *p, int *fd)
{
	*fd = open(p, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (*fd < 0)
	{
		perror("minishell: open");
		return (1);
	}
	return (0);
}

static int	validate_fd(int fd)
{
	if (fd < 0)
	{
		ft_dprintf(2, "minishell: bad file descriptor: %d\n", fd);
		return (0);
	}
	return (1);
}

/* -------------------------------------------------------------------------- */
/* Aplicadores                                                                */
/* -------------------------------------------------------------------------- */

static int apply_in(const char *path_raw)
{
    int   fd;
    char *path;

    switch (normalize_redir_filename(path_raw, &path))
    {
        case 0: /* vacío */
            ft_dprintf(2, "minishell: : No such file or directory\n");
            return 1;
        case 2: /* ambiguous */
            ft_dprintf(2, "minishell: ambiguous redirect\n");
            return 1;
    }
    if (open_rdonly(path, &fd))
    {
        free(path);
        return 1;
    }
    free(path);
    return (dup_into(fd, STDIN_FILENO));
}

static int	apply_in_fd(int fd)
{
	if (fd < 0)
		return (1);
	return (dup_into(fd, STDIN_FILENO));
}

static int apply_out_fd(const char *path_raw, int to_fd, int append, int force)
{
    int   fd;
    char *path;

    switch (normalize_redir_filename(path_raw, &path))
    {
        case 0:
            ft_dprintf(2, "minishell: : No such file or directory\n");
            return 1;
        case 2:
            ft_dprintf(2, "minishell: ambiguous redirect\n");
            return 1;
    }
    if (append)
    {
        if (open_w_append(path, &fd)) { free(path); return 1; }
    }
    else
    {
        if (open_w_trunc(path, &fd, force)) { free(path); return 1; }
    }
    free(path);
    return (dup_into(fd, to_fd));
}


static int apply_all(const char *path_raw, int append, int force)
{
    int   fd;
    char *path;

    switch (normalize_redir_filename(path_raw, &path))
    {
        case 0:
            ft_dprintf(2, "minishell: : No such file or directory\n");
            return 1;
        case 2:
            ft_dprintf(2, "minishell: ambiguous redirect\n");
            return 1;
    }
    if (append)
    {
        if (open_w_append(path, &fd)) { free(path); return 1; }
    }
    else
    {
        if (open_w_trunc(path, &fd, force)) { free(path); return 1; }
    }
    if (dup_into(dup(fd), STDOUT_FILENO)) { close(fd); free(path); return 1; }
    if (dup_into(fd, STDERR_FILENO)) { free(path); return 1; }
    free(path);
    return 0;
}

static int	apply_dup(const t_ast *r)
{
	int	src;

	src = r->redir.redir_fd;
	if (!validate_fd(src))
		return (1);
	if (r->redir.redir_type == REDIR_DUP_IN)
		return (dup_into(dup(src), STDIN_FILENO));
	return (dup_into(dup(src), STDOUT_FILENO));
}

/* -------------------------------------------------------------------------- */
/* Nodo individual                                                            */
/* -------------------------------------------------------------------------- */

static int	apply_one_redir(const t_ast *r)
{
	if (!r || r->type != N_REDIR)
		return (0);

	if (r->redir.redir_type == REDIR_HEREDOC)
	{
		/* prepare_heredocs debió convertirlo a REDIR_IN con heredoc_fd */
		ft_dprintf(2, "minishell: internal error: heredoc not prepared\n");
		return (1);
	}
	if (r->redir.redir_type == REDIR_IN)
	{
		/* Soporte heredoc por pipe: si heredoc_fd >= 0, úsalo */
		if (r->redir.heredoc_fd >= 0)
			return (apply_in_fd(r->redir.heredoc_fd));
		return (apply_in(r->redir.filename));
	}
	if (r->redir.redir_type == REDIR_OUT)
		return (apply_out_fd(r->redir.filename, STDOUT_FILENO, 0, 0));
	if (r->redir.redir_type == REDIR_APPEND)
		return (apply_out_fd(r->redir.filename, STDOUT_FILENO, 1, 0));
	if (r->redir.redir_type == REDIR_ERR)
		return (apply_out_fd(r->redir.filename, STDERR_FILENO, 0, 0));
	if (r->redir.redir_type == REDIR_APPEND_ERR)
		return (apply_out_fd(r->redir.filename, STDERR_FILENO, 1, 0));
	if (r->redir.redir_type == REDIR_ALL)
		return (apply_all(r->redir.filename, 0, 0));
	if (r->redir.redir_type == REDIR_APPEND_ALL)
		return (apply_all(r->redir.filename, 1, 0));
	if (r->redir.redir_type == REDIR_FORCE)
		return (apply_out_fd(r->redir.filename, STDOUT_FILENO, 0, 1));
	if (r->redir.redir_type == REDIR_DUP_IN
		|| r->redir.redir_type == REDIR_DUP_OUT)
		return (apply_dup(r));
	return (0);
}

/* -------------------------------------------------------------------------- */
/* Lista de redirecciones                                                     */
/* -------------------------------------------------------------------------- */

int	apply_redirections(t_ast *redir_list)
{
	t_ast	*cur;

	cur = redir_list;
	while (cur)
	{
		if (apply_one_redir(cur))
			return (1);
		cur = cur->bin.right;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_sequence.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:18:48 by acoronad          #+#    #+#             */
/*   Updated: 2025/06/29 14:18:57 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ast.h"
#include "exec.h"
#include "minishell.h"

int	execute_sequence(t_ast *node, t_shell *shell)
{
	execute_ast(node->bin.left, shell);
	return (execute_ast(node->bin.right, shell));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_subshell.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:13:14 by acoronad          #+#    #+#             */
/*   Updated: 2025/10/27 00:50:32 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_subshell(t_ast *node, t_shell *shell)
{
	pid_t	pid;
	int		st;
	int		sig;

	st = 0;
	pid = fork();
	if (pid < 0)
	{
		ft_dprintf(2, "minishell: fork error\n");
		shell->exit_status = 1;
		return (1);
	}
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		_exit(execute_ast(node->subshell.child, shell) & 0xFF);
	}
	if (waitpid(pid, &st, 0) < 0)
		shell->exit_status = 1;
	else if (WIFEXITED(st))
		shell->exit_status = WEXITSTATUS(st);
	else if (WIFSIGNALED(st))
	{
		sig = WTERMSIG(st);
		if (sig == SIGINT)
			write(STDOUT_FILENO, "\n", 1);
		else if (sig == SIGQUIT)
			write(STDERR_FILENO, "Quit (core dumped)\n", 19);
		shell->exit_status = 128 + sig;
	}
	else
		shell->exit_status = 1;
	return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/29 14:22:42 by acoronad          #+#    #+#             */
/*   Updated: 2025/11/04 14:05:14 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ast.h"
#include "env.h"
#include "exec.h"
#include "minishell.h"
#include <errno.h>
#include <sys/stat.h>

int	is_executable(char *path)
{
	struct stat	st;

	if (stat(path, &st) != 0)
		return (0);
	if (S_ISDIR(st.st_mode))
	{
		errno = EISDIR;
		return (0);
	}
	return (access(path, X_OK) == 0);
}

char	*join_path(const char *dir, const char *file)
{
	char	*tmp;
	size_t	len_dir;
	size_t	len_file;
	size_t	i;

	len_dir = ft_strlen(dir);
	len_file = ft_strlen(file);
	tmp = malloc(len_dir + 1 + len_file + 1);
	if (!tmp)
		return (NULL);
	ft_memcpy(tmp, dir, len_dir);
	tmp[len_dir] = '/';
	i = 0;
	while (i < len_file)
	{
		tmp[len_dir + 1 + i] = file[i];
		i++;
	}
	tmp[len_dir + 1 + len_file] = '\0';
	return (tmp);
}

static int	has_slash(char *cmd)
{
	int	i;

	if (!cmd)
		return (0);
	i = 0;
	while (cmd[i])
	{
		if (cmd[i] == '/')
			return (1);
		i++;
	}
	return (0);
}

static char	*find_path_executable(char *cmd, char **paths)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path(paths[i], cmd);
		if (!full_path)
			return (NULL);
		if (is_executable(full_path))
			return (full_path); // No liberar, lo devolvemos
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*find_executable(char *cmd, t_shell *shell)
{
	char	**paths;
	char	*res;
	char	*path_value;

	if (!cmd)
		return (NULL);
	if (has_slash(cmd))
	{
		if (is_executable(cmd))
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_value = get_env_value(shell, "PATH");
	if (!path_value || path_value[0] == '\0')
		return (NULL);
	paths = ft_split(path_value, ':');
	if (!paths)
		return (NULL);
	res = find_path_executable(cmd, paths);
	ft_free_strtab(paths);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prepare_heredocs.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: acoronad <acoronad@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/07 15:41:31 by acoronad          #+#    #+#             */
/*   Updated: 2025/11/07 17:12:13 by acoronad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/* -------------------------------------------------------------------------- */
/* Señales para modo heredoc                                                  */
/* -------------------------------------------------------------------------- */

static void	hd_sigint(int sig)
{
	(void)sig;
	g_signal = 1;
	write(STDOUT_FILENO, "\n", 1);
	rl_replace_line("", 0);
	rl_on_new_line();
	rl_done = 1;
}

static void	hd_push_signals(struct sigaction *old_int, struct sigaction *old_quit)
{
	struct sigaction	sa;

	g_signal = 0;
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = hd_sigint;
	sa.sa_flags = 0;
	sigaction(SIGINT, &sa, old_int);

	sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_IGN;
	sa.sa_flags = 0;
	sigaction(SIGQUIT, &sa, old_quit);
}

static void	hd_pop_signals(struct sigaction *old_int, struct sigaction *old_quit)
{
	sigaction(SIGINT, old_int, NULL);
	sigaction(SIGQUIT, old_quit, NULL);
}

/* -------------------------------------------------------------------------- */
/* Expansión de línea en heredoc: solo $..., si el delimitador NO estaba quote*/
/* -------------------------------------------------------------------------- */

static char	*hd_expand_line_opt(char *line, t_shell *sh, int quoted)
{
	char	*out;

	if (quoted)
		return (line);
	/* Usa tu API de expansión ligera: solo $..., sin split ni glob */
	out = expand_heredoc_line(line, sh);
	if (!out)
		return (NULL);
	free(line);
	return (out);
}

/* -------------------------------------------------------------------------- */
/* Entrada de texto del heredoc -> escribe en el extremo de escritura del pipe*/
/* -------------------------------------------------------------------------- */

static int	hd_write_to_fd(int fdw, const char *delim, int quoted, t_shell *sh)
{
	char	*line;

	while (!g_signal)
	{
		line = readline("> ");
		if (!line)
			break;
		if (ft_strcmp(line, delim) == 0)
		{
			free(line);
			break;
		}
		line = hd_expand_line_opt(line, sh, quoted);
		if (!line)
			return (0);
		write(fdw, line, ft_strlen(line));
		write(fdw, "\n", 1);
		free(line);
	}
	return (g_signal ? 0 : 1);
}

/* -------------------------------------------------------------------------- */
/* HEREDOC -> PIPE: crea pipe, escribe y convierte el nodo a REDIR_IN (FD)    */
/* -------------------------------------------------------------------------- */

static int	prepare_one_heredoc_node(t_ast *redir, t_shell *sh)
{
	int	p[2];
	int	ok;

	if (pipe(p) < 0)
		return (0);
	/* p[0] lectura -> se quedará en el AST; p[1] escritura -> se usa aquí */
	ok = hd_write_to_fd(p[1], redir->redir.delimiter,
			redir->redir.heredoc_quoted, sh);
	close(p[1]);
	if (!ok)
	{
		/* Ctrl-C o error: cerramos lectura y fijamos status 130 */
		close(p[0]);
		sh->exit_status = 130;
		return (0);
	}
	/* Convertir el nodo: HEREDOC -> IN con FD interno (sin filename) */
	redir->redir.redir_type = REDIR_IN;
	if (redir->redir.delimiter)
	{
		free(redir->redir.delimiter);
		redir->redir.delimiter = NULL;
	}
	if (redir->redir.filename)
	{
		free(redir->redir.filename);
		redir->redir.filename = NULL;
	}
	redir->redir.heredoc_fd = p[0]; /* NUEVO: lectura del pipe para stdin */
	return (1);
}

/* -------------------------------------------------------------------------- */
/* Recorre la lista de redirecciones (bin.right) y prepara heredocs           */
/* -------------------------------------------------------------------------- */

static int	prepare_redirs_list(t_ast *head, t_shell *sh)
{
	t_ast	*r;

	r = head;
	while (r)
	{
		if (r->type == N_REDIR && r->redir.redir_type == REDIR_HEREDOC)
		{
			if (!prepare_one_heredoc_node(r, sh))
				return (0);
		}
		r = r->bin.right;
	}
	return (1);
}

/* -------------------------------------------------------------------------- */
/* Recorrido del AST izquierda->derecha                                       */
/* -------------------------------------------------------------------------- */

static int	walk_prepare_heredocs(t_ast *n, t_shell *sh)
{
	if (!n)
		return (1);
	if (n->type == N_PIPE || n->type == N_SEQUENCE
		|| n->type == N_AND || n->type == N_OR
		|| n->type == N_BACKGROUND)
	{
		if (!walk_prepare_heredocs(n->bin.left, sh))
			return (0);
		return (walk_prepare_heredocs(n->bin.right, sh));
	}
	if (n->type == N_SUBSHELL)
	{
		if (!walk_prepare_heredocs(n->subshell.child, sh))
			return (0);
		return (prepare_redirs_list(n->subshell.redirections, sh));
	}
	if (n->type == N_COMMAND)
		return (prepare_redirs_list(n->cmd.redirections, sh));
	if (n->type == N_REDIR)
		return (prepare_redirs_list(n, sh));
	return (1);
}

/* -------------------------------------------------------------------------- */
/* API pública                                                                */
/* -------------------------------------------------------------------------- */

int	prepare_heredocs(t_ast *root, t_shell *sh)
{
	struct sigaction	old_int;
	struct sigaction	old_quit;
	int					ok;

	hd_push_signals(&old_int, &old_quit);
	ok = walk_prepare_heredocs(root, sh);
	hd_pop_signals(&old_int, &old_quit);
	return (ok);
}
