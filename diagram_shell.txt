
[1mLeyenda de colores[0m
 [31m[RED][0m Punto de entrada / main / modos
 [34m[BLUE][0m CreaciÃ³n / inicializaciÃ³n
 [32m[GREEN][0m Consulta / ejecuciÃ³n / lectura
 [33m[ORANGE][0m LiberaciÃ³n / cleanup
 [35m[PURPLE][0m Helpers / static (visibilidad local)
 [90m[GRAY][0m Dependencias externas (libft/stdlib/rl)

[1mDiagrama de funciones (Ã¡rbol de llamadas por funciÃ³n)[0m

[31mmain(argc, argv, envp) [RED][0m
 â””â”€ (en otro fichero) llama -> [32mrun_shell_modes(argc, argv, envp, &shell)[0m

[32mrun_shell_modes(argc, argv, envp, shell) [RED][0m
 â”œâ”€ calls -> [34mhandle_help_version(argc, argv)[0m
 â”œâ”€ calls -> [34minit_env(shell, envp)[0m
 â”‚ â””â”€ calls -> [34minit_env_list(envp) (en env/*.c)[0m
 â”œâ”€ consulta -> [90misatty(STDIN_FILENO) / isatty(STDOUT_FILENO)[0m
 â”œâ”€ si interactivo -> calls -> [90msetup_signals()[0m
 â”‚ -> calls -> [32mrun_interactive(shell)[0m
 â””â”€ si no interactivo -> calls -> [90msetup_default_signals()[0m
 -> calls -> [32mrun_non_interactive(shell)[0m

[34minit_shell_name(t_shell *shell, char **argv) [BLUE][0m
 â”œâ”€ usa -> [90mft_memset(shell, 0, sizeof(t_shell))[0m
 â”œâ”€ usa -> [90mft_strdup(argv[0])[0m
 â””â”€ devuelve 0 o 1 (error)

[34minit_env(t_shell *shell, char **envp) [BLUE][0m
 â””â”€ calls -> [34minit_env_list(envp)[0m (ve en src/env)

[34mhandle_help_version(argc, argv) [BLUE][0m
 â”œâ”€ compara -> [90mft_strcmp(argv[1], "--help")[0m
 â”œâ”€ compara -> [90mft_strcmp(argv[1], "--version")[0m
 â”œâ”€ en --help -> calls -> [32mprint_help()[0m
 â””â”€ en --version -> calls -> [32mprint_version()[0m

[32mprint_help() [GREEN][0m
 â””â”€ usa -> [90mft_dprintf(1, ...)[0m (imprime ayuda)

[32mprint_version() [GREEN][0m
 â””â”€ usa -> [90mft_dprintf(1, "minishell, version 1.0
")[0m

[32mprint_usage(const char *invalid) [GREEN][0m
 â”œâ”€ si invalid -> usa -> [90mft_dprintf(2, "minishell: : invalid option
", invalid)[0m
 â””â”€ imprime usage con [90mft_dprintf(2,...)[0m

[33mcleanup_shell(t_shell *shell) [ORANGE][0m
 â”œâ”€ si shell->env -> calls -> [33mfree_env_list(shell->env)[0m
 â”œâ”€ si shell->line -> free(line)
 â”œâ”€ si shell->tokens -> calls -> [33mfree_token_list(shell->tokens)[0m
 â”œâ”€ si shell->program_name -> free(program_name)
 â””â”€ calls -> [90mrestore_vquit()[0m

[33mcleanup_loop(t_shell *shell) [ORANGE][0m
 â”œâ”€ libera shell->line si existe
 â””â”€ libera shell->tokens si existe (free_token_list)

[35mhas_slash_local(const char *s) [PURPLE] (static)[0m
 â”œâ”€ helper sin "for" para Norma V4
 â””â”€ recorre con while (s[i]) y busca /

[32mprint_exec_error(t_shell *shell, const char *cmd, int err_code) [GREEN][0m
 â”œâ”€ valida cmd vacÃ­o -> imprime "command not found" y set exit_status 127
 â”œâ”€ usa -> [35mhas_slash_local(cmd)[0m para decidir mensaje
 â”œâ”€ usa -> [90mstrerror(err_code)[0m para mensaje detallado
 â””â”€ setea shell->exit_status con el cÃ³digo adecuado (126/127)

[35mft_quotes_closed(const char *line) [PURPLE] (static)[0m
 â””â”€ helper que recorre line con while y gestiona estados de comillas/backslash

[35mft_backslach_closed(char *line) [PURPLE] (static)[0m
 â””â”€ helper que cuenta backslashes finales con while y devuelve paridad

[32mread_line_interactive(t_shell *shell) [GREEN][0m
 â”œâ”€ calls -> [90msetup_prompt_signals()[0m y g_signal = 0
 â”œâ”€ shell->line = [90mreadline(prompt ANSI colored)[0m
 â”œâ”€ mientras !ft_quotes_closed(shell->line) || !ft_backslach_closed(...) -> pide more lines
 â”œâ”€ usa -> [90madd_history(shell->line)[0m (en caller)
 â””â”€ retorna shell->line o NULL si EOF

[32mrun_interactive(t_shell *shell) [GREEN][0m
 â”œâ”€ set is_interactive = 1
 â”œâ”€ bucle while (1):
 â”‚ â”œâ”€ setup_prompt_signals()
 â”‚ â”œâ”€ libera shell->line si existe
 â”‚ â”œâ”€ shell->line = read_line_interactive(shell)
 â”‚ â”œâ”€ si NULL -> break (Ctrl-D)
 â”‚ â”œâ”€ si lÃ­nea vacÃ­a -> free y continue
 â”‚ â”œâ”€ add_history(shell->line)
 â”‚ â”œâ”€ setup_exec_parent_signals()
 â”‚ â”œâ”€ libera tokens si existen
 â”‚ â”œâ”€ calls -> [32mshell_exec(shell)[0m
 â”‚ â”œâ”€ setup_prompt_signals()
 â”‚ â”œâ”€ cleanup_loop(shell)
 â”‚ â””â”€ if (shell->should_exit) break
 â””â”€ al salir: imprime "exit
" y rl_clear_history()

[35mchomp_nl(char *s) [PURPLE] (static)[0m
 â””â”€ quita terminador n (y optional r) del final con ft_strlen y ajustes

[32mrun_non_interactive(t_shell *shell) [GREEN][0m
 â”œâ”€ set is_interactive = 0
 â”œâ”€ while (1):
 â”‚ â”œâ”€ libera shell->line si existe
 â”‚ â”œâ”€ line = [90mget_next_line(STDIN_FILENO)[0m (tu GNL)
 â”‚ â”œâ”€ si !line -> break
 â”‚ â”œâ”€ chomp_nl(line)
 â”‚ â”œâ”€ shell->line = line
 â”‚ â”œâ”€ if (*shell->line) -> setup_exec_parent_signals(); libera tokens; calls -> shell_exec(shell)
 â”‚ â”œâ”€ cleanup_loop(shell)
 â”‚ â””â”€ if (shell->should_exit) break
 â””â”€ no imprime "exit" al final (solo modo interactivo)

[32mshell_exec(t_shell *shell) [GREEN][0m
 â”œâ”€ shell->tokens = [90mlexer(shell->line)[0m
 â”œâ”€ si !tokens -> shell->exit_status = 2; return 2
 â”œâ”€ calls -> [90mexpand_variables(shell)[0m
 â”œâ”€ shell->ast = [90mbuild_ast(shell->tokens)[0m
 â”œâ”€ free_token_list(shell->tokens); shell->tokens = NULL
 â”œâ”€ si !ast -> shell->exit_status = 2; return 2
 â””â”€ calls -> [90mexecute_ast(shell->ast, shell)[0m -> devuelve shell->exit_status

[32mtoken_type_str(t_token_type type) [GREEN][0m
 â””â”€ devuelve literal de tipo de token (if chain)

[35mquote_type_str(t_quote q) [PURPLE] (static)[0m
 â””â”€ devuelve literal del tipo de comilla

[32mprueba_lexer / prueba_expansion / prueba_env [GREEN] (debug helpers)[0m
 â”œâ”€ imprimen tokens / env / expansiÃ³n iterando con while
 â””â”€ usan -> [90mprintf(...) / token_type_str / quote_type_str[0m

[35mprint_indent(int level) [PURPLE] (static)[0m
 â””â”€ imprime indent con while (level--) printf(" ")

[32mprueba_ast(t_shell *shell) [GREEN][0m
 â”œâ”€ valida shell y shell->ast
 â””â”€ calls -> [32mprint_ast_debug(shell->ast, 0)[0m

[32mprint_ast_debug(t_ast *node, int level) [GREEN][0m
 â”œâ”€ recorrido recursivo del AST, imprime campos segun node->type
 â”œâ”€ usa print_indent(level)
 â”œâ”€ para N_COMMAND imprime argv (nota: el cÃ³digo actual usa for en el snippet; ojo Norminette)
 â””â”€ para binarios y subshells recurre con while en listas enlazadas y print_ast_debug

[90mDependencias externas (usadas)[0m
 readline, add_history, rl_clear_history, isatty, get_next_line (tu GNL),
 ft_strlen, ft_strdup, ft_memset, ft_dprintf, ft_strcmp, ft_strjoin_free_s1,
 malloc, free, strerror, printf

[1mFunciones llamadas en la ejecuciÃ³n (segÃºn estos ficheros)[0m

 [32mshell_exec[0m â€” llamado desde run_interactive y run_non_interactive.
 [34minit_env[0m â€” llamado desde run_shell_modes para inicializar env (usa init_env_list).
 [33mcleanup_shell[0m â€” previsto para llamarse al salir (main), y free_env_list lo usa en otros sitios.
 [32mread_line_interactive[0m â€” llamado desde run_interactive.
 [32mrun_interactive / run_non_interactive[0m â€” llamados desde run_shell_modes segÃºn isatty.

[1mFunciones/Helpers static (visibilidad local)[0m
 [35mhas_slash_local, ft_quotes_closed, ft_backslach_closed, chomp_nl,
 quote_type_str, env-count-style helpers, print_indent[0m

[1mNotas rÃ¡pidas (normas y observaciones)[0m
 - Algunas funciones de debug usan "for" (ej. recorrer argv o arrays) â€” revisa Norminette
 y reemplaza por while en las funciones que deban pasar la Norma V4.
 - MantÃ©n funciones <=25 lÃ­neas, <=80 columnas, <=4 variables locales y <=4 parÃ¡metros.
 - Static functions tienen alcance local; no exponer si no es necesario.

